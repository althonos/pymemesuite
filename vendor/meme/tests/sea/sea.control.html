<!DOCTYPE HTML>
<html>
  <head>
    <meta charset="UTF-8">
    <title>SEA results</title>
    <script type="text/javascript">
      //@JSON_VAR data
      var data = {
        "version": "5.4.0",
        "revision": "69feb327044e186cd629db061c94b8584d0ca60e",
        "release": "Mon Aug 16 16:18:19 2021 -0700",
        "program": "SEA",
        "cmd": [
          "sea", "--verbosity", "1", "--oc", "results/sea2", "--p",
          "common/Klf1-200-100.fa", "--n",
          "common/Klf1-200-100-shuffled.py2.fa", "--motif-pseudo", "0",
          "--hofract", "0", "--m", "common/Jaspar-subset.meme", "--m",
          "common/Jaspar-subset2.meme", "--thresh", "10"
        ],
        "options": {
          "objfun": "Differential Enrichment",
          "test": "Fisher Exact Test",
          "order": 2,
          "seed": 0,
          "pseudocount": 0,
          "thresh_type": "evalue",
          "thresh": 10,
          "hofract": 0,
          "is_holdout": false,
          "strands": "both",
          "align": "center",
          "noseqs": "false"
        },
        "motif_dbs": [
          {
            "source": "common/Jaspar-subset.meme",
            "count": 11
          }, {
            "source": "common/Jaspar-subset2.meme",
            "count": 2
          }
        ],
        "alphabet": {
          "name": "DNA",
          "like": "dna",
          "ncore": 4,
          "symbols": [
            {
              "symbol": "A",
              "name": "Adenine",
              "colour": "CC0000",
              "complement": "T"
            }, {
              "symbol": "C",
              "name": "Cytosine",
              "colour": "0000CC",
              "complement": "G"
            }, {
              "symbol": "G",
              "name": "Guanine",
              "colour": "FFB300",
              "complement": "C"
            }, {
              "symbol": "T",
              "aliases": "U",
              "name": "Thymine",
              "colour": "008000",
              "complement": "A"
            }, {
              "symbol": "N",
              "aliases": "X.",
              "name": "Any base",
              "equals": "ACGT"
            }, {
              "symbol": "V",
              "name": "Not T",
              "equals": "ACG"
            }, {
              "symbol": "H",
              "name": "Not G",
              "equals": "ACT"
            }, {
              "symbol": "D",
              "name": "Not C",
              "equals": "AGT"
            }, {
              "symbol": "B",
              "name": "Not A",
              "equals": "CGT"
            }, {
              "symbol": "M",
              "name": "Amino",
              "equals": "AC"
            }, {
              "symbol": "R",
              "name": "Purine",
              "equals": "AG"
            }, {
              "symbol": "W",
              "name": "Weak",
              "equals": "AT"
            }, {
              "symbol": "S",
              "name": "Strong",
              "equals": "CG"
            }, {
              "symbol": "Y",
              "name": "Pyrimidine",
              "equals": "CT"
            }, {
              "symbol": "K",
              "name": "Keto",
              "equals": "GT"
            }
          ]
        },
        "background": {
          "source": "--control--",
          "frequencies": [0.2484, 0.2516, 0.2516, 0.2484]
        },
        "sequence_db": {
          "source": "common/Klf1-200-100.fa",
          "count": 169,
          "maxlen": 100,
          "holdout": 0
        },
        "control_db": {
          "source": "common/Klf1-200-100-shuffled.py2.fa",
          "count": 169,
          "holdout": 0
        },
        "motifs": [
          {
            "db": 0,
            "id": "MA0039.2",
            "alt": "Klf4",
            "len": 10,
            "consensus": "DGGGYGKGGC",
            "motif_evalue": 0,
            "motif_nsites": 4340,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0039.2&rm=present&collection=CORE",
            "pwm": [
              [0.338561, 0.018681, 0.235701, 0.407057], 
              [0.020276, 0.002074, 0.976267, 0.001382], 
              [0.003223, 0.002993, 0.990792, 0.002993], 
              [0.003221, 0.008282, 0.984817, 0.003681], 
              [0.063693, 0.441941, 0.002529, 0.491837], 
              [0.005064, 0.003453, 0.983656, 0.007827], 
              [0.009671, 0.01842, 0.501727, 0.470182], 
              [0.060872, 0.010606, 0.8997, 0.028822], 
              [0.0284, 0.030016, 0.874856, 0.066728], 
              [0.058742, 0.660962, 0.064755, 0.215541]
            ],
            "pvalue": "8.74e-16",
            "log_pvalue": -34.6733,
            "evalue": "1.14e-14",
            "log_evalue": -32.1084,
            "qvalue": "1.14e-14",
            "log_qvalue": -32.1084,
            "tp": 73,
            "fp": 10,
            "enr_ratio": 6.72727,
            "score_thresh": 7.99487,
            "total_sites": 73,
            "site_distr": [
              0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1,
              1, 3, 1, 1, 0, 0, 1, 2, 0, 0, 2, 0, 0, 2, 1, 2, 0, 1, 0, 1, 2,
              0, 0, 1, 2, 2, 0, 0, 0, 1, 1, 3, 0, 3, 3, 0, 0, 2, 2, 1, 1, 0,
              1, 2, 1, 2, 0, 2, 2, 2, 0, 0, 1, 1, 2, 2, 0, 0, 0, 0, 0, 0, 1,
              0, 0, 0, 0, 0, 1
            ],
            "max_sites": 2,
            "site_hist": [0, 61, 12]
          }, {
            "db": 0,
            "id": "MA0140.1",
            "alt": "Tal1::Gata1",
            "len": 18,
            "consensus": "CTGBNNNNNDSAGATAAG",
            "motif_evalue": 0,
            "motif_nsites": 2945,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0140.1&rm=present&collection=CORE",
            "pwm": [
              [0.135962, 0.451734, 0.210061, 0.202243], 
              [0.088715, 0.150918, 0.176751, 0.583617], 
              [0.044497, 0.061821, 0.652514, 0.241168], 
              [0.089983, 0.253311, 0.416978, 0.239728], 
              [0.227165, 0.21562, 0.263158, 0.294058], 
              [0.238031, 0.233277, 0.306621, 0.222071], 
              [0.22539, 0.252885, 0.318398, 0.203327], 
              [0.241941, 0.23719, 0.302341, 0.218527], 
              [0.248898, 0.224483, 0.292302, 0.234317], 
              [0.338086, 0.138153, 0.319077, 0.204684], 
              [0.178947, 0.397963, 0.305942, 0.117148], 
              [0.664744, 0.010519, 0.012555, 0.312182], 
              [0.001018, 0.002376, 0.996606, 0], 
              [0.993553, 0.002375, 0.000679, 0.003393], 
              [0.005433, 0.008829, 0.010187, 0.975552], 
              [0.941216, 0.002039, 0.007815, 0.04893], 
              [0.809378, 0.017329, 0.127761, 0.045532], 
              [0.186054, 0.187075, 0.544558, 0.082313]
            ],
            "pvalue": "2.64e-9",
            "log_pvalue": -19.751,
            "evalue": "3.44e-8",
            "log_evalue": -17.186,
            "qvalue": "1.72e-8",
            "log_qvalue": -17.8792,
            "tp": 35,
            "fp": 2,
            "enr_ratio": 12,
            "score_thresh": 8.74206,
            "total_sites": 35,
            "site_distr": [
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1,
              1, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0,
              0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0,
              0, 0, 2, 1, 2, 1, 0, 1, 0, 1, 2, 0, 2, 0, 0, 0, 0, 1, 0
            ],
            "max_sites": 2,
            "site_hist": [0, 30, 5]
          }, {
            "db": 0,
            "id": "MA0300.1",
            "alt": "GAT1",
            "len": 8,
            "consensus": "YYGATAAG",
            "motif_evalue": 0,
            "motif_nsites": 100,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0300.1&rm=present&collection=CORE",
            "pwm": [
              [0.128713, 0.435644, 0.188119, 0.247525], 
              [0.17, 0.42, 0.05, 0.36], [0, 0, 1, 0], [1, 0, 0, 0], 
              [0, 0, 0, 1], [1, 0, 0, 0], [1, 0, 0, 0], 
              [0.030303, 0.090909, 0.848485, 0.030303]
            ],
            "pvalue": "1.55e-5",
            "log_pvalue": -11.0737,
            "evalue": "2.02e-4",
            "log_evalue": -8.5087,
            "qvalue": "6.72e-5",
            "log_qvalue": -9.60732,
            "tp": 28,
            "fp": 4,
            "enr_ratio": 5.8,
            "score_thresh": 5.99019,
            "total_sites": 28,
            "site_distr": [
              0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1,
              0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 2, 0, 1, 2, 0, 1, 0, 1, 2,
              0, 2, 0, 0, 0, 1, 1, 0
            ],
            "max_sites": 2,
            "site_hist": [0, 27, 1]
          }, {
            "db": 0,
            "id": "MA0035.2",
            "alt": "Gata1",
            "len": 11,
            "consensus": "DSAGATAAGVV",
            "motif_evalue": 0,
            "motif_nsites": 4000,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0035.2&rm=present&collection=CORE",
            "pwm": [
              [0.35575, 0.14, 0.3105, 0.19375], 
              [0.177, 0.40825, 0.30875, 0.106], 
              [0.6955, 0.00775, 0.0025, 0.29425], [0, 0, 1, 0], [1, 0, 0, 0], 
              [0.00675, 0.00725, 0.02725, 0.95875], 
              [0.97175, 0, 0.0015, 0.02675], 
              [0.8875, 0.001, 0.09575, 0.01575], 
              [0.19975, 0.17025, 0.574, 0.056], 
              [0.358, 0.22425, 0.34, 0.07775], 
              [0.37175, 0.20725, 0.27475, 0.14625]
            ],
            "pvalue": "3.13e-5",
            "log_pvalue": -10.3731,
            "evalue": "4.06e-4",
            "log_evalue": -7.80813,
            "qvalue": "1.02e-4",
            "log_qvalue": -9.19442,
            "tp": 35,
            "fp": 8,
            "enr_ratio": 4,
            "score_thresh": 6.4214,
            "total_sites": 35,
            "site_distr": [
              0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0,
              0, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              1, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 2, 1, 1, 2, 0, 1, 0, 1, 3, 0,
              2, 0, 0, 0, 0
            ],
            "max_sites": 2,
            "site_hist": [0, 34, 1]
          }, {
            "db": 0,
            "id": "MA0309.1",
            "alt": "GZF3",
            "len": 8,
            "consensus": "YGATAASR",
            "motif_evalue": 0,
            "motif_nsites": 100,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0309.1&rm=present&collection=CORE",
            "pwm": [
              [0.18, 0.39, 0.02, 0.41], [0, 0, 1, 0], [1, 0, 0, 0], 
              [0, 0, 0, 1], [1, 0, 0, 0], [0.73, 0.09, 0, 0.18], 
              [0.039604, 0.376238, 0.584158, 0], [0.39, 0.18, 0.27, 0.16]
            ],
            "pvalue": "2.15e-4",
            "log_pvalue": -8.44408,
            "evalue": "2.80e-3",
            "log_evalue": -5.87913,
            "qvalue": "5.59e-4",
            "log_qvalue": -7.48857,
            "tp": 19,
            "fp": 2,
            "enr_ratio": 6.66667,
            "score_thresh": 8.94851,
            "total_sites": 19,
            "site_distr": [
              0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
              1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
              0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 2, 0, 1, 2, 0, 0, 0, 1,
              0, 0, 2, 0, 0, 0, 0, 1
            ],
            "max_sites": 1,
            "site_hist": [0, 19]
          }, {
            "db": 0,
            "id": "MA0079.1",
            "alt": "SP1",
            "len": 10,
            "consensus": "KRGGCDGGGT",
            "motif_evalue": 0,
            "motif_nsites": 8,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0079.1&rm=present&collection=CORE",
            "pwm": [
              [0.125, 0.125, 0.5, 0.25], [0.25, 0.125, 0.5, 0.125], 
              [0, 0, 1, 0], [0, 0, 1, 0], [0, 0.625, 0.25, 0.125], 
              [0.25, 0, 0.5, 0.25], [0, 0.125, 0.625, 0.25], 
              [0, 0, 0.75, 0.25], [0.125, 0.125, 0.75, 0], 
              [0.25, 0, 0, 0.75]
            ],
            "pvalue": "1.04e-3",
            "log_pvalue": -6.86539,
            "evalue": "1.36e-2",
            "log_evalue": -4.30045,
            "qvalue": "2.26e-3",
            "log_qvalue": -6.0922,
            "tp": 41,
            "fp": 16,
            "enr_ratio": 2.47059,
            "score_thresh": 6.23822,
            "total_sites": 41,
            "site_distr": [
              0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 2, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0,
              1, 0, 0, 0, 0, 2, 0, 0, 1, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 2, 2,
              0, 0, 1, 0, 1, 0, 0, 0, 1, 2, 0, 0, 0, 2, 0, 0, 2, 0, 0, 1, 1,
              0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 1
            ],
            "max_sites": 3,
            "site_hist": [0, 30, 10, 1]
          }, {
            "db": 0,
            "id": "MA0270.1",
            "alt": "AFT2",
            "len": 8,
            "consensus": "SACACCCB",
            "motif_evalue": 0,
            "motif_nsites": 100,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0270.1&rm=present&collection=CORE",
            "pwm": [
              [0.08, 0.45, 0.27, 0.2], [0.7, 0, 0.3, 0], [0, 1, 0, 0], 
              [1, 0, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], [0, 1, 0, 0], 
              [0.090909, 0.424242, 0.272727, 0.212121]
            ],
            "pvalue": "4.32e-3",
            "log_pvalue": -5.4446,
            "evalue": "5.62e-2",
            "log_evalue": -2.87965,
            "qvalue": "8.02e-3",
            "log_qvalue": -4.82556,
            "tp": 20,
            "fp": 5,
            "enr_ratio": 3.5,
            "score_thresh": 9.56795,
            "total_sites": 20,
            "site_distr": [
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,
              0, 0, 0, 0, 0, 2, 1, 1, 0, 0, 0, 0, 1, 0, 0, 2, 0, 0, 0, 1, 0,
              0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 1
            ],
            "max_sites": 2,
            "site_hist": [0, 17, 3]
          }, {
            "db": 0,
            "id": "MA0079.2",
            "alt": "SP1",
            "len": 10,
            "consensus": "CCCCKCCCCC",
            "motif_evalue": 0,
            "motif_nsites": 35,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0079.2&rm=present&collection=CORE",
            "pwm": [
              [0, 0.914286, 0.028571, 0.057143], 
              [0, 0.857143, 0.028571, 0.114286], [0, 1, 0, 0], 
              [0.114286, 0.771429, 0, 0.114286], 
              [0.057143, 0.142857, 0.428571, 0.371429], 
              [0, 0.8, 0.028571, 0.171429], [0.028571, 0.885714, 0, 0.085714], 
              [0, 0.685714, 0.085714, 0.228571], 
              [0.171429, 0.714286, 0, 0.114286], 
              [0.085714, 0.742857, 0.085714, 0.085714]
            ],
            "pvalue": "3.10e-2",
            "log_pvalue": -3.47283,
            "evalue": "4.03e-1",
            "log_evalue": -0.907883,
            "qvalue": "5.04e-2",
            "log_qvalue": -2.98732,
            "tp": 12,
            "fp": 3,
            "enr_ratio": 3.25,
            "score_thresh": 8.39507,
            "total_sites": 12,
            "site_distr": [
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
              0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
              2, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0,
              0, 0, 0, 0, 0, 0
            ],
            "max_sites": 3,
            "site_hist": [0, 10, 1, 1]
          }, {
            "db": 0,
            "id": "MA0443.1",
            "alt": "btd",
            "len": 10,
            "consensus": "AGGGGGCGGR",
            "motif_evalue": 0,
            "motif_nsites": 30,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0443.1&rm=present&collection=CORE",
            "pwm": [
              [0.466667, 0.1, 0.233333, 0.2], [0.333333, 0, 0.666667, 0], 
              [0.133333, 0, 0.6, 0.266667], [0.066667, 0, 0.933333, 0], 
              [0, 0, 1, 0], [0, 0, 1, 0], [0.066667, 0.933333, 0, 0], 
              [0, 0, 1, 0], [0, 0, 0.666667, 0.333333], 
              [0.5, 0.033333, 0.333333, 0.133333]
            ],
            "pvalue": "8.45e-2",
            "log_pvalue": -2.47046,
            "evalue": "1.10e0",
            "log_evalue": 0.0944864,
            "qvalue": "1.10e-1",
            "log_qvalue": -2.2081,
            "tp": 21,
            "fp": 10,
            "enr_ratio": 2,
            "score_thresh": 0.943573,
            "total_sites": 21,
            "site_distr": [
              0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1,
              0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
              0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
              0, 2, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
              0, 0, 1, 0, 0, 0
            ],
            "max_sites": 2,
            "site_hist": [0, 20, 1]
          }, {
            "db": 1,
            "id": "MA0443.1",
            "alt": "btd",
            "len": 10,
            "consensus": "AGGGGGCGGR",
            "motif_evalue": 0,
            "motif_nsites": 30,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0443.1&rm=present&collection=CORE",
            "pwm": [
              [0.466667, 0.1, 0.233333, 0.2], [0.333333, 0, 0.666667, 0], 
              [0.133333, 0, 0.6, 0.266667], [0.066667, 0, 0.933333, 0], 
              [0, 0, 1, 0], [0, 0, 1, 0], [0.066667, 0.933333, 0, 0], 
              [0, 0, 1, 0], [0, 0, 0.666667, 0.333333], 
              [0.5, 0.033333, 0.333333, 0.133333]
            ],
            "pvalue": "8.45e-2",
            "log_pvalue": -2.47046,
            "evalue": "1.10e0",
            "log_evalue": 0.0944864,
            "qvalue": "1.10e-1",
            "log_qvalue": -2.2081,
            "tp": 21,
            "fp": 10,
            "enr_ratio": 2,
            "score_thresh": 0.943573,
            "total_sites": 21,
            "site_distr": [
              0, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1,
              0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0,
              0, 2, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
              0, 2, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,
              0, 0, 1, 0, 0, 0
            ],
            "max_sites": 2,
            "site_hist": [0, 20, 1]
          }, {
            "db": 0,
            "id": "MA0091.1",
            "alt": "TAL1::TCF3",
            "len": 12,
            "consensus": "NSAMCATCTGKT",
            "motif_evalue": 0,
            "motif_nsites": 44,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0091.1&rm=present&collection=CORE",
            "pwm": [
              [0.295455, 0.318182, 0.181818, 0.204545], 
              [0.204545, 0.227273, 0.454545, 0.113636], 
              [0.886364, 0, 0.068182, 0.045455], [0.454545, 0.545455, 0, 0], 
              [0, 0.977273, 0.022727, 0], [1, 0, 0, 0], 
              [0, 0.022727, 0.25, 0.727273], [0.272727, 0.727273, 0, 0], 
              [0, 0, 0, 1], [0, 0, 0.977273, 0.022727], 
              [0, 0.068182, 0.454545, 0.477273], 
              [0.090909, 0.090909, 0.045455, 0.772727]
            ],
            "pvalue": "1.83e-1",
            "log_pvalue": -1.69636,
            "evalue": "2.38e0",
            "log_evalue": 0.86859,
            "qvalue": "2.17e-1",
            "log_qvalue": -1.5293,
            "tp": 20,
            "fp": 11,
            "enr_ratio": 1.75,
            "score_thresh": 0.507237,
            "total_sites": 20,
            "site_distr": [
              1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0,
              1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
              0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
              0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
              0, 0, 0, 0
            ],
            "max_sites": 1,
            "site_hist": [0, 20]
          }, {
            "db": 1,
            "id": "MA0039.1",
            "alt": "Klf4",
            "len": 10,
            "consensus": "WAARGRAAGG",
            "motif_evalue": 0,
            "motif_nsites": 49,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0039.1&rm=present&collection=CORE",
            "pwm": [
              [0.367347, 0.183673, 0.040816, 0.408163], 
              [0.673469, 0, 0.265306, 0.061224], 
              [0.612245, 0.061224, 0.306122, 0.020408], 
              [0.469388, 0.020408, 0.387755, 0.122449], 
              [0.265306, 0.122449, 0.591837, 0.020408], 
              [0.408163, 0.081633, 0.469388, 0.040816], 
              [0.734694, 0.081633, 0.102041, 0.081633], 
              [0.653061, 0.040816, 0.265306, 0.040816], 
              [0.265306, 0.020408, 0.673469, 0.040816], 
              [0.040816, 0.020408, 0.938776, 0]
            ],
            "pvalue": "2.90e-1",
            "log_pvalue": -1.23633,
            "evalue": "3.78e0",
            "log_evalue": 1.32862,
            "qvalue": "3.15e-1",
            "log_qvalue": -1.15628,
            "tp": 150,
            "fp": 137,
            "enr_ratio": 1.0942,
            "score_thresh": 1.36546,
            "total_sites": 150,
            "site_distr": [
              1, 1, 4, 2, 4, 2, 1, 2, 3, 0, 3, 1, 3, 4, 2, 0, 0, 1, 0, 2, 2,
              2, 2, 2, 0, 1, 1, 1, 1, 1, 4, 1, 2, 4, 0, 0, 1, 4, 1, 2, 2, 3,
              4, 3, 2, 6, 4, 0, 1, 5, 1, 3, 0, 0, 2, 0, 0, 1, 2, 1, 1, 2, 1,
              1, 2, 1, 2, 2, 1, 0, 1, 3, 3, 1, 1, 3, 1, 4, 2, 1, 0, 1, 1, 0,
              2, 1, 0, 1, 1, 1
            ],
            "max_sites": 13,
            "site_hist": [0, 22, 31, 35, 15, 16, 11, 7, 5, 4, 1, 2, 0, 1]
          }, {
            "db": 0,
            "id": "MA0163.1",
            "alt": "PLAG1",
            "len": 14,
            "consensus": "GGGGCCCAAGGGGG",
            "motif_evalue": 0,
            "motif_nsites": 18,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0163.1&rm=present&collection=CORE",
            "pwm": [
              [0, 0, 1, 0], [0.166667, 0, 0.777778, 0.055556], [0, 0, 1, 0], 
              [0, 0, 0.944444, 0.055556], [0, 0.777778, 0.222222, 0], 
              [0, 0.833333, 0.055556, 0.111111], 
              [0.222222, 0.555556, 0.055556, 0.166667], 
              [0.666667, 0, 0, 0.333333], [0.611111, 0.277778, 0.111111, 0], 
              [0.111111, 0, 0.777778, 0.111111], [0, 0, 1, 0], [0, 0, 1, 0], 
              [0, 0, 0.888889, 0.111111], [0.111111, 0, 0.888889, 0]
            ],
            "pvalue": "5.00e-1",
            "log_pvalue": -0.693147,
            "evalue": "6.50e0",
            "log_evalue": 1.8718,
            "qvalue": "5.00e-1",
            "log_qvalue": -0.693147,
            "tp": 1,
            "fp": 0,
            "enr_ratio": 2,
            "score_thresh": 13.8231,
            "total_sites": 1,
            "site_distr": [
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0
            ],
            "max_sites": 1,
            "site_hist": [0, 1]
          }
        ]
      };
    </script>
    <script type="text/javascript">
var site_url = "https://meme-suite.org/meme";

    </script>
    <script type="text/javascript">
/*
 * $
 *
 * Shorthand function for getElementById
 */
function $(el) {
  return document.getElementById(el);
}

/*
	"new" icon
*/
var new_icon_src = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABwAAAAQCAMAAAAyEe/dAAAACVBMVEX//wAAAAD////s2cV/AAAAdUlEQVQYlXVRBxLAIAhL+P+jC2HZhXcBZEWEldDsZcLIcAhHWWnK8SDcWQhMFUHdAQ1CqQ5+CWPmlHojl+nCJNRtzu4qRc3IUzmTVpXYK0nox0z0PI1stgchdK7lEv7ekhvalw8WW547Gyzedt/2/gLx8WXjXF/1AYFriNAWAAAAAElFTkSuQmCC";

/*
 * See http://stackoverflow.com/a/5450113/66387
 * Does string multiplication like the perl x operator.
 */
function string_mult(pattern, count) {
    if (count < 1) return '';
    var result = '';
    while (count > 1) {
        if (count & 1) result += pattern;
        count >>= 1, pattern += pattern;
    }
    return result + pattern;
}

/*
 * See http://stackoverflow.com/questions/814613/how-to-read-get-data-from-a-url-using-javascript
 * Slightly modified with information from
 * https://developer.mozilla.org/en/DOM/window.location
 */
function parse_params() {
  "use strict";
  var search, queryStart, queryEnd, query, params, nvPairs, i, nv, n, v;
  search = window.location.search;
  queryStart = search.indexOf("?") + 1;
  queryEnd   = search.indexOf("#") + 1 || search.length + 1;
  query      = search.slice(queryStart, queryEnd - 1);

  if (query === search || query === "") return {};

  params  = {};
  nvPairs = query.replace(/\+/g, " ").split("&");

  for (i = 0; i < nvPairs.length; i++) {
    nv = nvPairs[i].split("=");
    n  = decodeURIComponent(nv[0]);
    v  = decodeURIComponent(nv[1]);
    // allow a name to be used multiple times
    // storing each value in the array
    if (!(n in params)) {
      params[n] = [];
    }
    params[n].push(nv.length === 2 ? v : null);
  }
  return params;
}

/*
 * coords
 *
 * Calculates the x and y offset of an element.
 * From http://www.quirksmode.org/js/findpos.html
 * with alterations to take into account scrolling regions
 */
function coords(elem) {
  var myX = myY = 0;
  if (elem.getBoundingClientRect) {
    var rect;
    rect = elem.getBoundingClientRect();
    myX = rect.left + ((typeof window.pageXOffset !== "undefined") ?
        window.pageXOffset : document.body.scrollLeft);
    myY = rect.top + ((typeof window.pageYOffset !== "undefined") ?
        window.pageYOffset : document.body.scrollTop);
  } else {
    // this fall back doesn't properly handle absolutely positioned elements
    // inside a scrollable box
    var node;
    if (elem.offsetParent) {
      // subtract all scrolling
      node = elem;
      do {
        myX -= node.scrollLeft ? node.scrollLeft : 0;
        myY -= node.scrollTop ? node.scrollTop : 0;
      } while (node = node.parentNode);
      // this will include the page scrolling (which is unwanted) so add it back on
      myX += (typeof window.pageXOffset !== "undefined") ? window.pageXOffset : document.body.scrollLeft;
      myY += (typeof window.pageYOffset !== "undefined") ? window.pageYOffset : document.body.scrollTop;
      // sum up offsets
      node = elem;
      do {
        myX += node.offsetLeft;
        myY += node.offsetTop;
      } while (node = node.offsetParent);
    }
  }
  return [myX, myY];
}

/*
 * position_popup
 *
 * Positions a popup relative to an anchor element.
 *
 * The available positions are:
 * 0 - Centered below the anchor.
 */
function position_popup(anchor, popup, position) {
  "use strict";
  var a_x, a_y, a_w, a_h, p_x, p_y, p_w, p_h;
  var a_xy, spacer, margin, scrollbar, page_w;
  // define constants
  spacer = 5;
  margin = 15;
  scrollbar = 15;
  // define the positions and widths
  a_xy = coords(anchor);
  a_x = a_xy[0];
  a_y = a_xy[1];
  a_w = anchor.offsetWidth;
  a_h = anchor.offsetHeight;
  p_w = popup.offsetWidth;
  p_h = popup.offsetHeight;
  page_w = null;
  if (window.innerWidth) {
    page_w = window.innerWidth;
  } else if (document.body) {
    page_w = document.body.clientWidth;
  }
  // check the position type is defined
  if (typeof position !== "number") {
    position = 0;
  }
  // calculate the popup position
  switch (position) {
    case 1:
      p_x = a_x + a_w + spacer;
      p_y = a_y + (a_h / 2) - (p_h / 2);
      break;
    case 0:
    default:
      p_x = a_x + (a_w / 2) - (p_w / 2);
      p_y = a_y + a_h + spacer;
      break;
  }
  // constrain the popup position
  if (p_x < margin) {
    p_x = margin;
  } else if (page_w != null && (p_x + p_w) > (page_w - margin - scrollbar)) {
    p_x = page_w - margin - scrollbar - p_w;
  }
  if (p_y < margin) {
    p_y = margin;
  }
  // position the popup
  popup.style.left = p_x + "px";
  popup.style.top = p_y + "px";
}

function lookup_help_popup(popup_id) {
  var _body, pop, info;
  pop = document.getElementById(popup_id);
  if (pop == null) {
    _body = document.getElementsByTagName("body")[0];
    pop = document.createElement("div");
    pop.className = "pop_content";
    pop.id = popup_id;
    pop.style.backgroundColor = "#FFC";
    pop.style.borderColor = "black";
    info = document.createElement("p");
    info.style.fontWeight = "bold";
    info.appendChild(document.createTextNode("Error: No popup for topic \"" + popup_id + "\"."));
    pop.appendChild(info);
    // this might cause problems with the menu, but as this only happens
    // when something is already wrong I don't think that's too much of a problem
    _body.insertBefore(pop, _body.firstChild);
  }
  if (document.getElementsByTagName('body')[0].hasAttribute("data-autobtns")) {
    if (!/\bauto_buttons\b/.test(pop.className)) {
      pop.className += " auto_buttons";
      var back_btn_sec = document.createElement("div");
      back_btn_sec.className = "nested_only pop_back_sec";
      var back_btn = document.createElement("span");
      back_btn.className = "pop_back";
      back_btn.appendChild(document.createTextNode("<< back"));
      back_btn.addEventListener("click", function(e) {
        help_return();
      }, false);
      back_btn_sec.appendChild(back_btn);
      pop.insertBefore(back_btn_sec, pop.firstChild);
      var close_btn_sec = document.createElement("div");
      close_btn_sec.className = "pop_close_sec";
      var close_btn = document.createElement("span");
      close_btn.className = "pop_close";
      close_btn.appendChild(document.createTextNode("close"));
      close_btn.addEventListener("click", function(e) {
        help_popup();
      }, false);
      close_btn_sec.appendChild(close_btn);
      pop.appendChild(close_btn_sec);
    }
  }
  return pop;
}

/*
 * help_popup
 *
 * Moves around help pop-ups so they appear
 * below an activator.
 */
function help_popup(activator, popup_id) {
  "use strict";
  var pop;
  // set default values
  if (typeof help_popup.popup === "undefined") {
    help_popup.popup = [];
  }
  if (typeof help_popup.activator === "undefined") {
    help_popup.activator = null;
  }
  var last_pop = (help_popup.popup.length > 0 ? help_popup.popup[help_popup.popup.length - 1] : null);
  if (typeof(activator) == "undefined") { // no activator so hide
    if (last_pop != null) {
      last_pop.style.display = 'none';
      help_popup.popup = [];
    }
    return;
  }
  pop = lookup_help_popup(popup_id);
  if (pop == last_pop) {
    if (activator == help_popup.activator) {
      //hide popup (as we've already shown it for the current help button)
      last_pop.style.display = 'none';
      help_popup.popup = [];
      return; // toggling complete!
    }
  } else if (last_pop != null) {
    //activating different popup so hide current one
    last_pop.style.display = 'none';
  }
  help_popup.popup = [pop];
  help_popup.activator = activator;
  toggle_class(pop, "nested", false);
  //must make the popup visible to measure it or it has zero width
  pop.style.display = 'block';
  position_popup(activator, pop);
}

/*
 * help_refine
 * 
 * Intended for links within a help popup. Stores a stack of state so
 * you can go back.
 */
function help_refine(popup_id) {
  if (help_popup.popup == null || help_popup.popup.length == 0 || help_popup.activator == null) {
    //throw new Error("Cannot refine a help popup when one is not shown!");
    var pop = lookup_help_popup(popup_id);
    var act_id = popup_id + '_act';
    var activator = document.getElementById(act_id);
    help_popup(activator, popup_id);
  }
  var pop = lookup_help_popup(popup_id);
  var last_pop = help_popup.popup[help_popup.popup.length - 1];
  if (pop == last_pop) return; // slightly odd, but no real cause for alarm
  help_popup.popup.push(pop);
  toggle_class(pop, "nested", true);
  last_pop.style.display = "none";
  //must make the popup visible to measure it or it has zero width
  pop.style.display = "block";
  position_popup(help_popup.activator, pop);
}

/*
 * help_return
 * 
 * Intended for links within a help popup. Stores a stack of state so
 * you can go back.
 */
function help_return() {
  if (help_popup.popup == null || help_popup.popup.length == 0 || help_popup.activator == null) {
    throw new Error("Can not return to a earlier help popup when one is not shown!");
  }
  var last_pop = help_popup.popup.pop();
  last_pop.style.display = "none";
  var pop = (help_popup.popup.length > 0 ? help_popup.popup[help_popup.popup.length - 1] : null);
  if (pop != null) {
    toggle_class(pop, "nested", help_popup.popup.length > 1);
    pop.style.display = "block";
    position_popup(help_popup.activator, pop);
  } else {
    help_popup.activator = null;
  }
}

/*
 * update_scroll_pad
 *
 * Creates padding at the bottom of the page to allow
 * scrolling of anything into view.
 */
function update_scroll_pad() {
  var page, pad;
  page = (document.compatMode === "CSS1Compat") ? document.documentElement : document.body;
  pad = $("scrollpad");
  if (pad === null) {
    pad = document.createElement("div");
    pad.id = 'scrollpad';
    document.getElementsByTagName('body')[0].appendChild(pad);
  }
  pad.style.height = Math.abs(page.clientHeight - 100) + "px";
}

function substitute_classes(node, remove, add) {
  "use strict";
  var list, all, i, cls, classes;
  list = node.className.split(/\s+/);
  all = {};
  for (i = 0; i < list.length; i++) {
    if (list[i].length > 0) all[list[i]] = true;
  }
  for (i = 0; i < remove.length; i++) {
    if (all.hasOwnProperty(remove[i])) {
      delete all[remove[i]];
    }
  }
  for (i = 0; i < add.length; i++) {
    all[add[i]] = true;
  }
  classes = "";
  for (cls in all) {
    classes += cls + " ";
  }
  node.className = classes;
}

/*
 * toggle_class
 *
 * Adds or removes a class from the node. If the parameter 'enabled' is not 
 * passed then the existence of the class will be toggled, otherwise it will be
 * included if enabled is true.
 */
function toggle_class(node, cls, enabled) {
  var classes = node.className;
  var list = classes.replace(/^\s+/, '').replace(/\s+$/, '').split(/\s+/);
  var found = false;
  for (var i = 0; i < list.length; i++) {
    if (list[i] == cls) {
      list.splice(i, 1);
      i--;
      found = true;
    }
  }
  if (typeof enabled == "undefined") {
    if (!found) list.push(cls);
  } else {
    if (enabled) list.push(cls);
  }
  node.className = list.join(" ");
}

/*
 * find_child
 *
 * Searches child nodes in depth first order and returns the first it finds
 * with the className specified.
 * TODO replace with querySelector
 */
function find_child(node, className) {
  var pattern;
  if (node == null || typeof node !== "object") {
    return null;
  }
  if (typeof className === "string") {
    pattern = new RegExp("\\b" + className + "\\b");
  } else {
    pattern = className;
  }
  if (node.nodeType == Node.ELEMENT_NODE && 
      pattern.test(node.className)) {
    return node;
  } else {
    var result = null;
    for (var i = 0; i < node.childNodes.length; i++) {
      result = find_child(node.childNodes[i], pattern);
      if (result != null) break;
    }
    return result;
  }
}

/*
 * find_parent
 *
 * Searches parent nodes outwards from the node and returns the first it finds
 * with the className specified.
 */
function find_parent(node, className) {
  var pattern;
  pattern = new RegExp("\\b" + className + "\\b");
  do {
    if (node.nodeType == Node.ELEMENT_NODE && 
        pattern.test(node.className)) {
      return node;
    }
  } while (node = node.parentNode);
  return null;
}

/*
 * find_parent_tag
 *
 * Searches parent nodes outwards from the node and returns the first it finds
 * with the tag name specified. HTML tags should be specified in upper case.
 */
function find_parent_tag(node, tag_name) {
  do {
    if (node.nodeType == Node.ELEMENT_NODE && node.tagName == tag_name) {
      return node;
    }
  } while (node = node.parentNode);
  return null;
}

/*
 * __toggle_help
 *
 * Uses the 'topic' property of the this object to
 * toggle display of a help topic.
 *
 * This function is not intended to be called directly.
 */
function __toggle_help(e) {
  if (!e) e = window.event;
  if (e.type === "keydown") {
    if (e.keyCode !== 13 && e.keyCode !== 32) {
      return;
    }
    // stop a submit or something like that
    e.preventDefault();
  }

  help_popup(this, this.getAttribute("data-topic"));
}

function setup_help_button(button) {
  "use strict";
  var topic;
  if (button.hasAttribute("data-topic")) {
    topic = button.getAttribute("data-topic");
    if (document.getElementById(topic) != null) {
      button.tabIndex = "0"; // make keyboard selectable
      button.addEventListener("click", function() {
        help_popup(button, topic);
      }, false);
      button.addEventListener("keydown", function(e) {
        // toggle only on Enter or Spacebar, let other keys do their thing
        if (e.keyCode !== 13 && e.keyCode !== 32) return;
        // stop a submit or something like that
        e.preventDefault();
        help_popup(button, topic);
      }, false);
    } else {
      button.style.visibility = "hidden";
    }
  }
  button.className += " active";
}

/*
 * help_button
 *
 * Makes a help button for the passed topic.
 */
function help_button(topic) {
  var btn = document.createElement("div");
  btn.className = "help";
  btn.setAttribute("data-topic", topic);
  setup_help_button(btn);
  return btn;
}

/*
 * prepare_download
 *
 * Sets the attributes of a link to setup a file download using the given content.
 * If no link is provided then create one and click it.
 */
function prepare_download(content, mimetype, filename, link) {
  "use strict";
  // if no link is provided then create one and click it
  var click_link = false;
  if (!link) {
    link = document.createElement("a");
    click_link = true;
  }
  try {
    // Use a BLOB to convert the text into a data URL.
    // We could do this manually with a base 64 conversion.
    // This will only be supported on modern browsers,
    // hence the try block.
    var blob = new Blob([content], {type: mimetype});
    var reader = new FileReader();
    reader.onloadend = function() {
      // If we're lucky the browser will also support the download
      // attribute which will let us suggest a file name to save the link.
      // Otherwise it is likely that the filename will be unintelligible. 
      link.setAttribute("download", filename);
      link.href = reader.result;
      if (click_link) {
        // must add the link to click it
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    }
    reader.readAsDataURL(blob);
  } catch (error) {
    if (console && console.log) console.log(error);
    // probably an old browser
    link.href = "";
    link.visible = false;
  }
}

/*
 * add_cell
 *
 * Add a cell to the table row.
 */
function add_cell(row, node, cls, click_action) {
  var cell = row.insertCell(row.cells.length);
  if (node) cell.appendChild(node);
  if (cls && cls !== "") cell.className = cls;
  if (click_action) cell.addEventListener("click", click_action, false);
}

/*
 * add_header_cell
 *
 * Add a header cell to the table row.
 */
function add_header_cell(row, node, help_topic, cls, colspan, is_new) {
  var th = document.createElement("th");
  if (node) th.appendChild(node);
  if (help_topic && help_topic !== "") th.appendChild(help_button(help_topic));
  if (is_new && is_new !== "") {
    var br = document.createElement("span");
    br.innerHTML = "<br>";
    th.appendChild(br);
    var new_icon = document.createElement("img");
    new_icon.src = new_icon_src;
    new_icon.alt = "NEW";
    th.appendChild(new_icon);
  }
  if (cls && cls !== "") th.className = cls;
  if (typeof colspan == "number" && colspan > 1) th.colSpan = colspan;
  row.appendChild(th);
}

/*
 * add_text_cell
 *
 * Add a text cell to the table row.
 */
function add_text_cell(row, text, cls, action) {
  var node = null;
  if (typeof(text) != 'undefined') node = document.createTextNode(text);
  add_cell(row, node, cls, action);
}

/*
 * add_text_header_cell
 *
 * Add a text header cell to the table row.
 */
function add_text_header_cell(row, text, help_topic, cls, action, colspan, is_new) {
  var node = null;
  if (typeof(text) != 'undefined') {
    var nbsp = (help_topic ? "\u00A0" : "");
    var str = "" + text;
    var parts = str.split(/\n/);
    if (parts.length === 1) {
      if (action) {
        node = document.createElement("span");
        node.appendChild(document.createTextNode(str + nbsp));
      } else {
        node = document.createTextNode(str + nbsp);
      }
    } else {
      node = document.createElement("span");
      for (var i = 0; i < parts.length; i++) {
        if (i !== 0) {
          node.appendChild(document.createElement("br"));
        }
        node.appendChild(document.createTextNode(parts[i]));
      }
    }
    if (action) {
      node.addEventListener("click", action, false);
      node.style.cursor = "pointer";
    }
  }
  add_header_cell(row, node, help_topic, cls, colspan, is_new);
}

function setup_help() {
  "use strict";
  var help_buttons, i;
  help_buttons = document.querySelectorAll(".help:not(.active)");
  for (i = 0; i < help_buttons.length; i++) {
    setup_help_button(help_buttons[i]);
  }
}

function setup_scrollpad() {
  "use strict";
  if (document.getElementsByTagName('body')[0].hasAttribute("data-scrollpad") && document.getElementById("scrollpad") == null) {
    window.addEventListener("resize", update_scroll_pad, false);
    update_scroll_pad();
  }
}

// anon function to avoid polluting global scope
(function() {
  "use strict";
  window.addEventListener("load", function load(evt) {
    window.removeEventListener("load", load, false);
    setup_help();
    setup_scrollpad();
  }, false);
})();

/*
 *  make_link
 *
 *  Creates a text node and if a URL is specified it surrounds it with a link.
 *  If the URL doesn't begin with "http://" it automatically adds it, as
 *  relative links don't make much sense in this context.
 */
function make_link(text, url) {
  var textNode = null;
  var link = null;
  if (typeof text !== "undefined" && text !== null) textNode = document.createTextNode(text);
  if (typeof url === "string") {
    if (url.indexOf("//") == -1) {
      url = "http://" + url;
    }
    link = document.createElement('a');
    link.href = url;
    if (textNode) link.appendChild(textNode);
    return link;
  }
  return textNode;
}

//
// Function to create an HTML paragraph describing the 
// MEME Suite background model source.
//
function make_background_source(title, source, text) {
  var paraNode = document.createElement("P");
  var titleNode = document.createElement("B");
  var textNode1 = document.createTextNode("\u00A0\u00A0\u00A0\u00A0" + title + ": ");
  titleNode.appendChild(textNode1);
  var source_text = ((source == "--motif--") ? "the (first) motif file" : (source == "--nrdb--") ? "an old version of the NCBI non-redundant database" : (source == "--uniform--") ? "the uniform model" : (source == "--query--") ? "the query file" : (source == "--sequences--") ? "built from the (primary) sequences" : (source == "--control--") ? "built from the control (negative) sequences" : ((source == "--negatives--") ? "built from the negative (control) sequences" : "the file '" + source + "'"));
  if (text) { return source_text; }
  var textNode2 = document.createTextNode(source_text);
  paraNode.appendChild(titleNode);
  paraNode.appendChild(textNode2);
  return paraNode;
}

// Function to create a help button
function make_help_button(container, help_topic) {
  container.appendChild(help_button(help_topic));
}

// Function to toggle display.
function change_display(id) {
  var element=document.getElementById(id);
  element.style.display=(element.style.display=='none') ? element.style.display='inline' : element.style.display='none';
}

    </script>
    <script type="text/javascript">
//======================================================================
// start Alphabet object
//======================================================================
var Alphabet = function(alphabet, background) {
  "use strict";
  var i, j, sym, aliases, complement, comp_e_sym, ambigs, generate_background;
  generate_background = (background == null);
  if (generate_background) {
    background = [];
    for (i = 0; i < alphabet.ncore; i++) background[i] = 1.0 / alphabet.ncore;
  } else if (alphabet.ncore != background.length) {
    throw new Error("The background length does not match the alphabet length.");
  }
  this.name = alphabet.name;
  this.like = (alphabet.like != null ? alphabet.like.toUpperCase() : null);
  this.ncore = alphabet.ncore;
  this.symbols = alphabet.symbols;
  this.background = background;
  this.genbg = generate_background;
  this.encode = {};
  this.encode2core = {};
  this.complement = {};
  // check if all symbols are same case
  var seen_uc = false;
  var seen_lc = false;
  var check_case = function (syms) {
    var s, sym;
    if (typeof syms === "string") {
      for (s = 0; s < syms.length; s++) {
        sym = syms.charAt(s);
        if (sym >= 'a' && sym <= 'z') seen_lc = true;
        else if (sym >= 'A' && sym <= 'Z') seen_uc = true;
      }
    }
  };
  for (i = 0; i < this.symbols.length; i++) {
    check_case(this.symbols[i].symbol);
    check_case(this.symbols[i].aliases);
  }
  // now map symbols to indexes
  var update_array = function(array, syms, index) {
    var s, sym;
    if (typeof syms === "string") {
      for (s = 0; s < syms.length; s++) {
        sym = syms.charAt(s);
        array[sym] = index;
        // when only a single case is used, then encode as case insensitive
        if (seen_uc != seen_lc) {
          if (sym >= 'a' && sym <= 'z') {
            array[sym.toUpperCase()] = index;
          } else if (sym >= 'A' && sym <= 'Z') {
            array[sym.toLowerCase()] = index;
          }
        }
      }
    }
  }
  // map core symbols to index
  for (i = 0; i < this.ncore; i++) {
    update_array(this.encode2core, this.symbols[i].symbol, i);
    update_array(this.encode, this.symbols[i].symbol, i);
    update_array(this.encode2core, this.symbols[i].aliases, i);
    update_array(this.encode, this.symbols[i].aliases, i);
  }
  // map ambiguous symbols to index
  ambigs = {};
  for (i = this.ncore; i < this.symbols.length; i++) {
    update_array(this.encode, this.symbols[i].symbol, i);
    update_array(this.encode, this.symbols[i].aliases, i);
    ambigs[this.symbols[i].equals] = i;
  }
  // determine complements
  for (i = 0; i < this.ncore; i++) {
    complement = this.symbols[i].complement;
    if (typeof complement === "string") {
      this.complement[i] = this.encode2core[complement];
    }
  }
  next_symbol:
  for (i = this.ncore; i < this.symbols.length; i++) {
    complement = "";
    for (j = 0; j < this.symbols[i].equals.length; j++) {
      comp_e_sym = this.complement[this.encode2core[this.symbols[i].equals.charAt(j)]];
      if (typeof comp_e_sym !== "number") continue next_symbol;
      complement += this.symbols[comp_e_sym].symbol;
    }
    complement = complement.split("").sort().join("");
    if (typeof ambigs[complement] === "number") {
      this.complement[i] = ambigs[complement];
    }
  }
  // determine case insensitivity
  this.case_insensitive = true;
  if (seen_uc == seen_lc) {
    // when there is a mixture of cases it probably won't
    // be case insensitive but we still need to check
    loop:
    for (i = 0; i < this.symbols.length; i++) {
      sym = this.symbols[i].symbol;
      if (sym >= 'A' && sym <= 'Z') {
        if (this.encode[sym.toLowerCase()] != i) {
          this.case_insensitive = false;
          break loop;
        }
      } else if (sym >= 'a' && sym <= 'z') {
        if (this.encode[sym.toUpperCase()] != i) {
          this.case_insensitive = false;
          break loop;
        }
      }
      aliases = this.symbols[i].aliases;
      if (aliases != null) {
        for (j = 0; j < aliases.length; j++) {
          sym = aliases.charAt(j);
          if (sym >= 'A' && sym <= 'Z') {
            if (this.encode[sym.toLowerCase()] != i) {
              this.case_insensitive = false;
              break loop;
            }
          } else if (sym >= 'a' && sym <= 'z') {
            if (this.encode[sym.toUpperCase()] != i) {
              this.case_insensitive = false;
              break loop;
            }
          }
        }
      }
    }
  }
  // normalise aliases to remove the prime symbol and eliminate
  // the alternate cases when the alphabet is case insensitive
  var seen, out;
  for (i = 0; i < this.symbols.length; i++) {
    sym = this.symbols[i].symbol;
    aliases = this.symbols[i].aliases;
    if (typeof aliases != "string") aliases = "";
    seen = {};
    out = [];
    if (this.case_insensitive) {
      sym = sym.toUpperCase();
      aliases = aliases.toUpperCase();
    }
    seen[sym] = true;
    for (j = 0; j < aliases.length; j++) {
      if (!seen[aliases.charAt(j)]) {
        seen[aliases.charAt(j)] = true;
        out.push(aliases.charAt(j));
      }
    }
    this.symbols[i].aliases = out.sort().join("");
  }
};
// return the name of the alphabet
Alphabet.prototype.get_alphabet_name = function() {
  return this.name;
};
// return if the alphabet can be complemented
Alphabet.prototype.has_complement = function() {
  return (typeof this.symbols[0].complement === "string");
};
// return true if an uppercase letter has the same meaning as the lowercase form
Alphabet.prototype.is_case_insensitive = function() {
  return this.case_insensitive;
};
// return the information content of an alphabet letter
Alphabet.prototype.get_ic = function() {
  return Math.log(this.ncore) / Math.LN2;
};
// return the count of the core alphabet symbols
Alphabet.prototype.get_size_core = function() {
  return this.ncore;
};
// return the count of all alphabet symbols
Alphabet.prototype.get_size_full = function() {
  return this.symbols.length;
};
// return the symbol for the given alphabet index
Alphabet.prototype.get_symbol = function(alph_index) {
  "use strict";
  if (alph_index < 0 || alph_index >= this.symbols.length) {
    throw new Error("Alphabet index out of bounds");
  }
  return this.symbols[alph_index].symbol;
};
// return the aliases for the given alphabet index
Alphabet.prototype.get_aliases = function(alph_index) {
  "use strict";
  if (alph_index < 0 || alph_index >= this.symbols.length) {
    throw new Error("Alphabet index out of bounds");
  }
  var sym_obj = this.symbols[alph_index];
  return (sym_obj.aliases != null ? sym_obj.aliases : "");
};
// return the name for the given alphabet index
Alphabet.prototype.get_name = function(alph_index) {
  "use strict";
  var sym;
  if (alph_index < 0 || alph_index >= this.symbols.length) {
    throw new Error("Alphabet index out of bounds");
  }
  sym = this.symbols[alph_index];
  return (typeof sym.name === "string" ? sym.name : sym.symbol);
};
// return the alphabet it is like or null
Alphabet.prototype.get_like = function() {
  "use strict";
  return this.like;
};
// return the index of the complement for the given alphabet index
Alphabet.prototype.get_complement = function(alph_index) {
  var comp_e_sym = this.complement[alph_index];
  if (typeof comp_e_sym === "number") {
    return comp_e_sym;
  } else {
    return -1;
  }
};
// return a string containing the core symbols
Alphabet.prototype.get_symbols = function() {
  "use strict";
  var i, core_symbols;
  core_symbols = "";
  for (i = 0; i < this.ncore; i++) {
    core_symbols += this.symbols[i].symbol;
  }
  return core_symbols;
};
// return if the background was not a uniform generated background
Alphabet.prototype.has_bg = function() {
  "use strict";
  return !this.genbg;
};
// get the background frequency for the index
Alphabet.prototype.get_bg_freq = function(alph_index) {
  "use strict";
  var freq, i, symbols;
  if (alph_index >= 0) {
    if (alph_index < this.ncore) {
      return this.background[alph_index];
    } else if (alph_index < this.symbols.length) {
      freq = 0;
      symbols = this.symbols[alph_index].equals;
      for (i = 0; i < symbols.length; i++) {
        freq += this.background[this.encode2core[symbols.charAt(i)]];
      }
      return freq;
    } 
  }
  throw new Error("The alphabet index is out of range.");
};
// get the colour of the index
Alphabet.prototype.get_colour = function(alph_index) {
  "use strict";
  if (alph_index < 0 || alph_index >= this.symbols.length) {
    throw new Error("BAD_ALPHABET_INDEX");
  }
  if (typeof this.symbols[alph_index].colour != "string") {
    return "black";
  }
  return "#" + this.symbols[alph_index].colour;
};
// get the rgb components of the colour at the index
Alphabet.prototype.get_rgb = function(alph_index) {
  "use strict";
  if (alph_index < 0 || alph_index >= this.symbols.length) {
    throw new Error("BAD_ALPHABET_INDEX");
  }
  if (typeof this.symbols[alph_index].colour != "string") {
    return {"red": 0, "green": 0, "blue": 0};
  }
  var colour = this.symbols[alph_index].colour;
  var red = parseInt(colour.substr(0, 2), 16) / 255;
  var green = parseInt(colour.substr(2, 2), 16) / 255;
  var blue = parseInt(colour.substr(4, 2), 16) / 255;
  return {"red": red, "green": green, "blue": blue};
};
// convert a symbol into the index
Alphabet.prototype.get_index = function(letter) {
  "use strict";
  var alph_index;
  alph_index = this.encode[letter];
  if (typeof alph_index === "undefined") {
    return -1;
  }
  return alph_index;
};
// convert a symbol into the list of core indexes that it equals
Alphabet.prototype.get_indexes = function(letter) {
  "use strict";
  var alph_index, comprise_str, i, comprise_list;
  alph_index = this.encode[letter];
  if (typeof alph_index === "undefined") {
    throw new Error("Unknown letter");
  }
  comprise_str = this.symbols[alph_index].equals;
  comprise_list = [];
  if (typeof comprise_str == "string") {
    for (i = 0; i < comprise_str.length; i++) {
      comprise_list.push(this.encode2core[comprise_str.charAt(i)]);
    }
  } else {
    comprise_list.push(alph_index);
  }
  return comprise_list;
};
// check if a symbol is the primary way of representing the symbol in the alphabet
Alphabet.prototype.is_prime_symbol = function(letter) {
  var alph_index;
  alph_index = this.encode[letter];
  if (alph_index == null) return false;
  if (this.is_case_insensitive()) {
    return (this.symbols[alph_index].symbol.toUpperCase() == letter.toUpperCase());
  } else {
    return (this.symbols[alph_index].symbol == letter);
  }
};
// compare 2 alphabets
Alphabet.prototype.equals = function(other) {
  "use strict";
  var i, sym1, sym2;
  // first check that it's actually an alphabet object
  if (!(typeof other === "object" && other != null && other instanceof Alphabet)) {
    return false;
  }
  // second shortcircuit if it's the same object
  if (this === other) return true;
  // compare
  if (this.name !== other.name) return false;
  if (this.ncore !== other.ncore) return false;
  if (this.symbols.length !== other.symbols.length) return false;
  for (i = 0; i < this.symbols.length; i++) {
    sym1 = this.symbols[i];
    sym2 = other.symbols[i];
    if (sym1.symbol !== sym2.symbol) return false;
    if (sym1.aliases !== sym2.aliases) return false;
    if (sym1.name !== sym2.name) return false;
    if (typeof sym1.colour !== typeof sym2.colour || 
        (typeof sym1.colour === "string" && typeof sym2.colour === "string" &&
         parseInt(sym1.colour, 16) != parseInt(sym2.colour, 16))) {
      return false;
    }
    if (sym1.complement !== sym2.complement) return false;
    if (sym1.equals !== sym2.equals) return false;
  }
  return true;
};
Alphabet.prototype.check_core_subset = function(super_alph) {
  var complement_same = true;
  var seen_set = {};
  var sub_i, sub_symbol, super_i, super_symbol;
  for (sub_i = 0; sub_i < this.ncore; sub_i++) {
    sub_symbol = this.symbols[sub_i];
    super_i = super_alph.encode[sub_symbol.symbol]; 
    if (super_i == null) return 0;
    super_symbol = super_alph.symbols[super_i];
    if (seen_set[super_i]) return 0;
    seen_set[super_i] = true;
    // check complement
    if (sub_symbol.complement != null && super_symbol.complement != null) {
      if (super_alph.encode[sub_symbol.complement] != super_alph.encode[super_symbol.complement]) {
        complement_same = false;
      }
    } else if (sub_symbol.complement != null || super_symbol.complement != null) {
      complement_same = false;
    }
  }
  return (complement_same ? 1 : -1);
};
// convert a sequence to its reverse complement
Alphabet.prototype.invcomp_seq = function(seq) {
  "use strict";
  var syms, i, e_sym, comp_e_sym;
  if (!this.has_complement()) throw new Error("Alphabet must be complementable");
  syms = seq.split("");
  for (i = 0; i < syms.length; i++) {
    e_sym = this.encode[syms[i]];
    if (typeof e_sym === "undefined") {
      e_sym = this.ncore; // wildcard
    }
    comp_e_sym = this.complement[e_sym];
    if (typeof comp_e_sym === "undefined") {
      comp_e_sym = e_sym; // not complementable
    }
    syms[i] = this.symbols[comp_e_sym].symbol;
  }
  return syms.reverse().join("");
};
// convert the alphabet to the text version
Alphabet.prototype.as_text = function() {
  "use strict";
  function name_as_text(name) {
    var i, c, out;
    out = "\"";
    for (i = 0; i < name.length; i++) {
      c = name.charAt(i);
      if (c == "\"") {
        out += "\\\"";
      } else if (c == "/") {
        out += "\\/";
      } else if (c == "\\") {
        out += "\\\\";
      } else {
        out += c;
      }
    }
    out += "\"";
    return out;
  }
  function symbol_as_text(sym) {
    var out;
    out = sym.symbol;
    if (typeof sym.name === "string" && sym.name != sym.symbol) {
      out += " " + name_as_text(sym.name);
    }
    if (typeof sym.colour === "string") {
      out += " " + sym.colour;
    }
    return out;
  }
  var out, i, j, c, sym;
  out = "";
  // output core symbols with 2 way complements
  for (i = 0; i < this.ncore; i++) {
    c = this.complement[i];
    if (typeof c === "number" && i < c && this.complement[c] === i) {
      out += symbol_as_text(this.symbols[i]) + " ~ " + symbol_as_text(this.symbols[c]) + "\n";  
    }
  }
  // output core symbols with no complement
  for (i = 0; i < this.ncore; i++) {
    if (typeof this.complement[i] === "undefined") {
      out += symbol_as_text(this.symbols[i]) + "\n";
    }
  }
  // output ambiguous symbols that have comprising characters
  for (i = this.ncore; i < this.symbols.length; i++) {
    if (this.symbols[i].equals.length == 0) break;
    out += symbol_as_text(this.symbols[i]) + " = " + this.symbols[i].equals + "\n";
    if (typeof this.symbols[i].aliases === "string") {
      for (j = 0; j < this.symbols[i].aliases.length; j++) {
        if (this.symbols[i].aliases.charAt(j) == this.symbols[i].symbol) continue;
        out += this.symbols[i].aliases.charAt(j) + " = " + this.symbols[i].equals + "\n";
      }
    }
  }
  // output aliases of core symbols
  for (i = 0; i < this.ncore; i++) {
    if (typeof this.symbols[i].aliases === "string") {
      for (j = 0; j < this.symbols[i].aliases.length; j++) {
        if (this.symbols[i].aliases.charAt(j) == this.symbols[i].symbol) continue;
        out += this.symbols[i].aliases.charAt(j) + " = " + this.symbols[i].symbol + "\n";
      }
    }
  }
  // output gap symbols
  i = this.symbols.length - 1;
  if (this.symbols[i].equals.length == 0) {
    out += symbol_as_text(this.symbols[i]) + " =\n";
    if (typeof this.symbols[i].aliases === "string") {
      for (j = 0; j < this.symbols[i].aliases.length; j++) {
        if (this.symbols[i].aliases.charAt(j) == this.symbols[i].symbol) continue;
        out += this.symbols[i].aliases.charAt(j) + " =\n";
      }
    }
  }
  return out;
};
// output the alphabet as it appears in minimal MEME format
Alphabet.prototype.as_meme = function() {
  "use strict";
  function name_as_text(name) {
    var i, c, out;
    out = "\"";
    for (i = 0; i < name.length; i++) {
      c = name.charAt(i);
      if (c == "\"") {
        out += "\\\"";
      } else if (c == "/") {
        out += "\\/";
      } else if (c == "\\") {
        out += "\\\\";
      } else {
        out += c;
      }
    }
    out += "\"";
    return out;
  }
  if (this.equals(AlphStd.DNA)) {
    return "ALPHABET= ACGT\n";
  } else if (this.equals(AlphStd.PROTEIN)) {
    return "ALPHABET= ACDEFGHIKLMNPQRSTVWY\n";
  } else {
    return "ALPHABET" + 
      (this.name != null ? " " + name_as_text(this.name) : "") + 
      (this.like != null ? " " + this.like + "-LIKE" : "") + "\n" +
      this.as_text() + "END ALPHABET\n";
  }
};

// Returns a table showing all the letters in the alphabet
Alphabet.prototype.as_table = function() {
  "use strict";
  var i, j, row, th, td, aliases, equals, sym;
  var table = document.createElement("table");
  // create the core symbol header
  row = table.insertRow(table.rows.length);
  th = document.createElement("th");
  th.appendChild(document.createTextNode("Symbol(s)"));
  row.appendChild(th);
  th = document.createElement("th");
  th.appendChild(document.createTextNode("Name"));
  row.appendChild(th);
  th = document.createElement("th");
  if (this.has_complement()) {
    th.appendChild(document.createTextNode("Complement"));
  }
  row.appendChild(th);
  // list the core symbols
  for (i = 0; i < this.ncore; i++) {
    row = table.insertRow(table.rows.length);
    td = document.createElement("td");
    if (this.symbols[i].colour != null) {
      td.style.color = '#' + this.symbols[i].colour;
    }
    td.appendChild(document.createTextNode(this.symbols[i].symbol));
    aliases = this.get_aliases(i);
    if (aliases.length > 0) {
      td.appendChild(document.createTextNode(' ' + aliases.split('').join(' ')));
    }
    row.appendChild(td);
    td = document.createElement("td");
    if (this.symbols[i].name != null) {
      td.appendChild(document.createTextNode(this.symbols[i].name));
    }
    row.appendChild(td);
    td = document.createElement("td");
    if (this.symbols[i].complement != null) {
      td.style.color = this.get_colour(this.get_index(this.symbols[i].complement));
      td.appendChild(document.createTextNode(this.symbols[i].complement));
    }
    row.appendChild(td);
  }
  // create the ambiguous symbol header
  row = table.insertRow(table.rows.length);
  th = document.createElement("th");
  th.appendChild(document.createTextNode("Symbol(s)"));
  row.appendChild(th);
  th = document.createElement("th");
  th.appendChild(document.createTextNode("Name"));
  row.appendChild(th);
  th = document.createElement("th");
  th.appendChild(document.createTextNode("Matches"));
  row.appendChild(th);
  // list the ambiguous symbols
  for (i = this.ncore; i < this.symbols.length; i++) {
    row = table.insertRow(table.rows.length);
    td = document.createElement("td");
    if (this.symbols[i].colour != null) {
      td.style.color = '#' + this.symbols[i].colour;
    }
    td.appendChild(document.createTextNode(this.symbols[i].symbol));
    aliases = this.get_aliases(i);
    if (aliases.length > 0) {
      td.appendChild(document.createTextNode(' ' + aliases.split('').join(' ')));
    }
    row.appendChild(td);
    td = document.createElement("td");
    if (this.symbols[i].name != null) {
      td.appendChild(document.createTextNode(this.symbols[i].name));
    }
    row.appendChild(td);
    td = document.createElement("td");
    equals = this.symbols[i].equals.split('');
    for (j = 0; j < equals.length; j++) {
      if (j != 0) td.appendChild(document.createTextNode(' '));
      sym = document.createElement("span");
      sym.style.color = this.get_colour(this.get_index(equals[j]));
      sym.appendChild(document.createTextNode(equals[j]));
      td.appendChild(sym);
    }
    row.appendChild(td);
  }
  return table;
};

// returns a dictionary of the colours for EPS
Alphabet.prototype._as_eps_dict = function() {
  "use strict";
  var i, sym, rgb;
  var out = "/fullColourDict <<\n";
  for (i = 0; i < this.ncore; i++) {
    sym = this.get_symbol(i);
    sym = sym.replace(/\\/g, "\\\\");
    sym = sym.replace(/\(/g, "\\(");
    sym = sym.replace(/\)/g, "\\)");
    rgb = this.get_rgb(i);
    out += " (" + sym + ") [" + rgb.red.toFixed(4) + " " + rgb.green.toFixed(4) + " " + rgb.blue.toFixed(4) + "]\n";
  }
  out += ">> def\n";
  out += "/mutedColourDict <<\n";
  for (i = 0; i < this.ncore; i++) {
    sym = this.get_symbol(i);
    sym = sym.replace(/\\/g, "\\\\");
    sym = sym.replace(/\(/g, "\\(");
    sym = sym.replace(/\)/g, "\\)");
    rgb = Alphabet.lighten_colour(this.get_rgb(i));
    out += " (" + sym + ") [" + rgb.red.toFixed(4) + " " + rgb.green.toFixed(4) + " " + rgb.blue.toFixed(4) + "]\n";
  }
  out += ">> def\n";
  return out;
};

// return the alphabet name or a list of primary symbols
Alphabet.prototype.toString = function() {
  "use strict";
  if (this.name != null) {
    return this.name;
  } else {
    return this.get_symbols();
  }
};

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Helper functions
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Convert a colour specified in RGB colourspace values into LAB colourspace
Alphabet.rgb2lab = function(rgb) {
  "use strict";
  var xyzHelper, labHelper;
  // XYZ helper
  xyzHelper = function(value) {
    if (value > 0.0445) {
      value = (value + 0.055) / 1.055;
      value = Math.pow(value, 2.4);
    } else {
      value /= 12.92;
    }
    value *= 100;
    return value;
  };
  // lab helper
  labHelper = function(value) {
    if (value > 0.008856) {
      value = Math.pow(value, 1.0 / 3.0);
    } else {
      value = (7.787 * value) + (16.0 / 116.0);
    }
    return value;
  };
  // convert into XYZ colourspace
  var c1, c2, c3;
  if (typeof rgb == "number") {
    c1 = xyzHelper(((rgb >> 16) & 0xFF) / 255.0);
    c2 = xyzHelper(((rgb >> 8) & 0xFF) / 255.0);
    c3 = xyzHelper((rgb & 0xFF) / 255.0);
  } else {
    c1 = xyzHelper(rgb.red);
    c2 = xyzHelper(rgb.green);
    c3 = xyzHelper(rgb.blue);
  }
  var x = (c1 * 0.4124) + (c2 * 0.3576) + (c3 * 0.1805);
  var y = (c1 * 0.2126) + (c2 * 0.7152) + (c3 * 0.0722);
  var z = (c1 * 0.0193) + (c2 * 0.1192) + (c3 * 0.9505);
  // convert into Lab colourspace
  c1 = labHelper(x / 95.047);
  c2 = labHelper(y / 100.0);
  c3 = labHelper(z / 108.883);
  var l = (116.0 * c2) - 16;
  var a = 500.0 * (c1 - c2);
  var b = 200.0 * (c2 - c3);
  return {"l": l, "a": a, "b": b};
};

// Convert a colour specified in HSV colourspace into RGB colourspace
Alphabet.hsv2rgb = function(hue, sat, value, output_object) {
  // achromatic (grey)
  var r = value;
  var g = value;
  var b = value;
  if (sat != 0) {
    var h = hue / 60.0;
    var i = Math.floor(h);
    var f = h - i;
    var p = value * (1.0 - sat);
    var q = value * (1.0 - (sat * f));
    var t = value * (1.0 - (sat * (1.0 - f)));
    if (i == 0) {
      r = value;
      g = t;
      b = p;
    } else if (i == 1) {
      r = q;
      g = value;
      b = p;
    } else if (i == 2) {
      r = p;
      g = value;
      b = t;
    } else if (i == 3) {
      r = p;
      g = q;
      b = value;
    } else if (i == 4) {
      r = t;
      g = p;
      b = value;
    } else {
      r = value;
      g = p;
      b = q;
    }
  }
  if (output_object) {
    return {"red": r, "green": g, "blue": b};
  } else {
    return (Math.floor(r * 255) << 15) | (Math.floor(g * 255) << 8) | (Math.floor(b * 255));
  }
};

// Calculate a distance score between two colours in LAB colourspace
Alphabet.lab_dist = function(lab1, lab2) {
  var c1 = Math.sqrt((lab1.l * lab1.l) + (lab1.a * lab1.a));
  var c2 = Math.sqrt((lab2.l * lab2.l) + (lab2.a * lab2.a));
  var dc = c1 - c2;
  var dl = lab1.l - lab2.l;
  var da = lab1.a - lab2.a;
  var db = lab1.b - lab2.b;
  // we don't want NaN due to rounding errors so fudge things a bit...
  var dh = 0;
  var dh_squared = (da * da) + (db * db) - (dc * dc);
  if (dh_squared > 0) {
    dh = Math.sqrt(dh_squared);
  }
  var first = dl;
  var second = dc / (1.0 + (0.045 * c1));
  var third = dh / (1.0 + (0.015 * c1));
  return Math.sqrt((first * first) + (second * second) + (third * third));
};

// convert an RGB value into a HSL value
Alphabet.rgb2hsl = function(rgb) {
  "use strict";
  var min, max, delta, h, s, l, r, g, b;
  if (typeof rgb == "number") {
    r = ((rgb >> 16) & 0xFF) / 255.0;
    g = ((rgb >> 8) & 0xFF) / 255.0;
    b = (rgb & 0xFF) / 255.0;
  } else {
    r = rgb.red;
    g = rgb.green;
    b = rgb.blue;
  }
  min = Math.min(r, g, b);
  max = Math.max(r, g, b);
  delta = max - min;
  l = min + (delta / 2);
  if (max == min) {
    h = 0; // achromatic (grayscale)
    s = 0;
  } else {
    if (l > 0.5) {
      s = delta / (2 - max - min);
    } else {
      s = delta / (max + min);
    }
    if (max == r) {
      h = (g - b) / delta;
      if (g < b) h += 6;
    } else if (max == g) {
      h = ((b - r) / delta) + 2;
    } else {
      h = ((r - g) / delta) + 4;
    }
    h /= 6;
  }
  return {"h": h, "s": s, "l": l};
};

// convert a HSL value into an RGB value
Alphabet.hsl2rgb = function(hsl, output_object) {
  "use strict";
  function _hue(p, q, t) {
    "use strict";
    if (t < 0) t += 1;
    else if (t > 1) t -= 1;
    if (t < (1.0 / 6.0)) {
      return p + ((q - p) * 6.0 * t);
    } else if (t < 0.5) {
      return q;
    } else if (t < (2.0 / 3.0)) {
      return p + ((q - p) * ((2.0 / 3.0) - t) * 6.0);
    } else {
      return p;
    }
  }
  var r, g, b, p, q;
  if (hsl.s == 0) {
    // achromatic (grayscale)
    r = hsl.l;
    g = hsl.l;
    b = hsl.l;
  } else {
    if (hsl.l < 0.5) {
      q = hsl.l * (1 + hsl.s);
    } else {
      q = hsl.l + hsl.s - (hsl.l * hsl.s);
    }
    p = (2 * hsl.l) - q;
    r = _hue(p, q, hsl.h + (1.0 / 3.0));
    g = _hue(p, q, hsl.h);
    b = _hue(p, q, hsl.h - (1.0 / 3.0));
  }
  if (output_object) {
    return {"red": r, "green": g, "blue": b};
  } else {
    return (Math.floor(r * 255) << 15) | (Math.floor(g * 255) << 8) | (Math.floor(b * 255));
  }
};

Alphabet.lighten_colour = function(rgb) {
  "use strict";
  var hsl = Alphabet.rgb2hsl(rgb);
  hsl.l += (1.0 - hsl.l) * 2 / 3;
  return Alphabet.hsl2rgb(hsl, typeof rgb != "number");
};

//======================================================================
// end Alphabet object
//======================================================================

//======================================================================
// start StandardAlphabet object
//======================================================================

// an extension of the alphabet object to support some additional fields 
// only present in standard alphabets.
var StandardAlphabet = function(enum_code, enum_name, alphabet_data) {
  Alphabet.apply(this, [alphabet_data]);
  this.enum_code = enum_code;
  this.enum_name = enum_name;
};
StandardAlphabet.prototype = Alphabet.prototype;
StandardAlphabet.prototype.constructor = StandardAlphabet;

// A unique code for this standard alphabet.
// This code will be a power of 2 to enable creation of bitsets for
// a selection of standard alphabets.
StandardAlphabet.prototype.get_code = function() {
  return this.enum_code;
};

// A unique name for this standard alphabet.
// this name will be all upper case and the same as the property that
// refers to this alphabet in the AlphStd collection.
StandardAlphabet.prototype.get_enum = function() {
  return this.enum_name;
};

//======================================================================
// end StandardAlphabet object
//======================================================================

// A collection of standard alphabets.
var AlphStd = {
  RNA: new StandardAlphabet(1, "RNA", {
    "name": "RNA",
    "like": "RNA",
    "ncore": 4,
    "symbols": [
      {"symbol": "A", "name": "Adenine", "colour": "CC0000"},
      {"symbol": "C", "name": "Cytosine", "colour": "0000CC"},
      {"symbol": "G", "name": "Guanine", "colour": "FFB300"},
      {"symbol": "U", "name": "Uracil", "colour": "008000",
        "aliases": "T"},
      {"symbol": "N", "name": "Any base", "equals": "ACGU", "aliases": "X."},
      {"symbol": "V", "name": "Not U", "equals": "ACG"},
      {"symbol": "H", "name": "Not G", "equals": "ACU"},
      {"symbol": "D", "name": "Not C", "equals": "AGU"},
      {"symbol": "B", "name": "Not A", "equals": "CGU"},
      {"symbol": "M", "name": "Amino", "equals": "AC"},
      {"symbol": "R", "name": "Purine", "equals": "AG"},
      {"symbol": "W", "name": "Weak", "equals": "AU"}, 
      {"symbol": "S", "name": "Strong", "equals": "CG"},
      {"symbol": "Y", "name": "Pyrimidine", "equals": "CU"},
      {"symbol": "K", "name": "Keto", "equals": "GU"}
    ]
  }), 
  DNA: new StandardAlphabet(2, "DNA", {
    "name": "DNA",
    "like": "DNA",
    "ncore": 4,
    "symbols": [
      {"symbol": "A", "name": "Adenine", "colour": "CC0000", "complement": "T"},
      {"symbol": "C", "name": "Cytosine", "colour": "0000CC", "complement": "G"},
      {"symbol": "G", "name": "Guanine", "colour": "FFB300", "complement": "C"},
      {"symbol": "T", "name": "Thymine", "colour": "008000", "complement": "A",
        "aliases": "U"},
      {"symbol": "N", "name": "Any base", "equals": "ACGT", "aliases": "X."},
      {"symbol": "V", "name": "Not T", "equals": "ACG"},
      {"symbol": "H", "name": "Not G", "equals": "ACT"},
      {"symbol": "D", "name": "Not C", "equals": "AGT"},
      {"symbol": "B", "name": "Not A", "equals": "CGT"},
      {"symbol": "M", "name": "Amino", "equals": "AC"},
      {"symbol": "R", "name": "Purine", "equals": "AG"},
      {"symbol": "W", "name": "Weak", "equals": "AT"}, 
      {"symbol": "S", "name": "Strong", "equals": "CG"},
      {"symbol": "Y", "name": "Pyrimidine", "equals": "CT"},
      {"symbol": "K", "name": "Keto", "equals": "GT"}
    ]
  }), 
  PROTEIN: new StandardAlphabet(4, "PROTEIN", {
    "name": "Protein",
    "like": "PROTEIN",
    "ncore": 20,
    "symbols": [
      {"symbol": "A", "name": "Alanine", "colour": "0000CC"},
      {"symbol": "C", "name": "Cysteine", "colour": "0000CC"},
      {"symbol": "D", "name": "Aspartic acid", "colour": "FF00FF"},
      {"symbol": "E", "name": "Glutamic acid", "colour": "FF00FF"},
      {"symbol": "F", "name": "Phenylalanine", "colour": "0000CC"},
      {"symbol": "G", "name": "Glycine", "colour": "FFB300"},
      {"symbol": "H", "name": "Histidine", "colour": "FFCCCC"},
      {"symbol": "I", "name": "Isoleucine", "colour": "0000CC"},
      {"symbol": "K", "name": "Lysine", "colour": "CC0000"},
      {"symbol": "L", "name": "Leucine", "colour": "0000CC"},
      {"symbol": "M", "name": "Methionine", "colour": "0000CC"},
      {"symbol": "N", "name": "Asparagine", "colour": "008000"},
      {"symbol": "P", "name": "Proline", "colour": "FFFF00"},
      {"symbol": "Q", "name": "Glutamine", "colour": "008000"},
      {"symbol": "R", "name": "Arginine", "colour": "CC0000"},
      {"symbol": "S", "name": "Serine", "colour": "008000"},
      {"symbol": "T", "name": "Threonine", "colour": "008000"},
      {"symbol": "V", "name": "Valine", "colour": "0000CC"},
      {"symbol": "W", "name": "Tryptophan", "colour": "0000CC"},
      {"symbol": "Y", "name": "Tyrosine", "colour": "33E6CC"},
      {"symbol": "X", "name": "Any amino acid", "equals": "ACDEFGHIKLMNPQRSTVWY", "aliases": "*."},
      {"symbol": "B", "name": "Asparagine or Aspartic acid", "equals": "DN"}, 
      {"symbol": "Z", "name": "Glutamine or Glutamic acid", "equals": "EQ"}, 
      {"symbol": "J", "name": "Leucine or Isoleucine", "equals": "IL"}
    ]
  })
};

//======================================================================
// start Symbol object
//======================================================================
var Symbol = function(alph_index, scale, alphabet) {
  "use strict";
  //variable prototype
  this.symbol = alphabet.get_symbol(alph_index);
  this.scale = scale;
  this.colour = alphabet.get_colour(alph_index);
};

Symbol.prototype.get_symbol = function() {
  "use strict";
  return this.symbol;
};

Symbol.prototype.get_scale = function() {
  "use strict";
  return this.scale;
};

Symbol.prototype.get_colour = function() {
  "use strict";
  return this.colour;
};

Symbol.prototype.toString = function() {
  "use strict";
  return this.symbol + " " + (Math.round(this.scale*1000)/10) + "%";
};

function compare_symbol(sym1, sym2) {
  "use strict";
  if (sym1.get_scale() < sym2.get_scale()) {
    return -1;
  } else if (sym1.get_scale() > sym2.get_scale()) {
    return 1;
  } else {
    return 0;
  }
}
//======================================================================
// end Symbol object
//======================================================================

//======================================================================
// start Pspm object
//======================================================================
var Pspm = function(matrix, name, ltrim, rtrim, nsites, evalue, pssm, alt, pgm) {
  "use strict";
  var row, col, data, row_sum, delta, evalue_re;
  if (typeof name !== "string") {
    name = "";
  }
  this.name = name;
  //construct
  if (matrix instanceof Pspm) {
    // copy constructor
    this.alph_length = matrix.alph_length;
    this.motif_length = matrix.motif_length;
    this.name = matrix.name;
    this.alt = matrix.alt;
    this.nsites = matrix.nsites;
    this.evalue = matrix.evalue;
    this.ltrim = matrix.ltrim;
    this.rtrim = matrix.rtrim;
    this.pspm = [];
    this.pgm = matrix.pgm;
    for (row = 0; row < matrix.motif_length; row++) {
      this.pspm[row] = [];
      for (col = 0; col < matrix.alph_length; col++) {
        this.pspm[row][col] = matrix.pspm[row][col];
      }
    }
    if (matrix.pssm != null) {
      this.pssm = [];
      for (row = 0; row < matrix.motif_length; row++) {
        this.pspm[row] = [];
        for (col = 0; col < matrix.alph_length; col++) {
          this.pssm[row][col] = matrix.pssm[row][col];
        }
      }
    }
  } else {
    // check parameters
    if (ltrim == null) {
      ltrim = 0;
    } else if (typeof ltrim !== "number" || ltrim % 1 !== 0 || ltrim < 0) {
      throw new Error("ltrim must be a non-negative integer, got: " + ltrim);
    }
    if (rtrim == null) {
      rtrim = 0;
    } else if (typeof rtrim !== "number" || rtrim % 1 !== 0 || rtrim < 0) {
      throw new Error("rtrim must be a non-negative integer, got: " + rtrim);
    }
    if (nsites != null) {
      if (typeof nsites !== "number" || nsites < 0) {
        throw new Error("nsites must be a positive number, got: " + nsites);
      } else if (nsites == 0) {
        nsites = null;
      }
    }
    if (evalue != null) {
      if (typeof evalue === "number") {
        if (evalue < 0) {
          throw new Error("evalue must be a non-negative number, got: " + evalue);
        }
      } else if (typeof evalue === "string") {
        evalue_re = /^((?:[+]?[0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)|inf)$/;
        if (!evalue_re.test(evalue)) {
          throw new Error("evalue must be a non-negative number, got: " + evalue);
        }
      } else {
        throw new Error("evalue must be a non-negative number, got: " + evalue);
      }
    }
    // set properties
    this.name = name;
    this.alt = alt;
    this.nsites = nsites;
    this.evalue = evalue;
    this.ltrim = ltrim;
    this.rtrim = rtrim;
    this.pgm = pgm;
    if (typeof matrix === "string") {
      // string constructor
      data = parse_pspm_string(matrix);
      this.alph_length = data["alph_length"];
      this.motif_length = data["motif_length"];
      this.pspm = data["pspm"];
      if (this.evalue == null) {
        if (data["evalue"] != null) {
          this.evalue = data["evalue"];
        } else {
          this.evalue = 0;
        }
      }
      if (this.nsites == null) {
        if (typeof data["nsites"] === "number") {
          this.nsites = data["nsites"];
        } else {
          this.nsites = 20;
        }
      }
    } else {
      // assume pspm is a nested array
      this.motif_length = matrix.length;
      this.alph_length = (matrix.length > 0 ? matrix[0].length : 0);
      if (this.nsites == null) {
        this.nsites = 20;
      }
      if (this.evalue == null) {
        this.evalue = 0;
      }
      this.pspm = [];
      // copy pspm and check
      for (row = 0; row < this.motif_length; row++) {
        if (this.alph_length != matrix[row].length) {
          throw new Error("COLUMN_MISMATCH");
        }
        this.pspm[row] = [];
        row_sum = 0;
        for (col = 0; col < this.alph_length; col++) {
          this.pspm[row][col] = matrix[row][col];
          row_sum += this.pspm[row][col];
        }
        delta = 0.1;
        if (isNaN(row_sum) || (row_sum > 1 && (row_sum - 1) > delta) || 
            (row_sum < 1 && (1 - row_sum) > delta)) {
          throw new Error("INVALID_SUM");
        }
      }
      // copy pssm
      if (pssm != null) {
        this.pssm = [];
        for (row = 0; row < this.motif_length; row++) {
          this.pssm[row] = [];
          for (col = 0; col < this.alph_length; col++) {
            this.pssm[row][col] = pssm[row][col];
          }
        }
      }
    }
  }
};

Pspm.prototype.copy = function() {
  "use strict";
  return new Pspm(this);
};

Pspm.prototype.reverse = function() {
  "use strict";
  var x, y, temp, temp_trim;
  //reverse
  x = 0;
  y = this.motif_length-1;
  while (x < y) {
    temp = this.pspm[x];
    this.pspm[x] = this.pspm[y];
    this.pspm[y] = temp;
    x++;
    y--;
  }
  // reverse pssm (if defined)
  if (typeof this.pssm !== "undefined") {
    //reverse
    x = 0;
    y = this.motif_length-1;
    while (x < y) {
      temp = this.pssm[x];
      this.pspm[x] = this.pssm[y];
      this.pssm[y] = temp;
      x++;
      y--;
    }
  }
  //swap triming
  temp_trim = this.ltrim;
  this.ltrim = this.rtrim;
  this.rtrim = temp_trim;
  return this; //allow function chaining...
};

Pspm.prototype.reverse_complement = function(alphabet) {
  "use strict";
  var x, y, temp, i, row, c, temp_trim;
  if (this.alph_length != alphabet.get_size_core()) {
    throw new Error("The alphabet size does not match the size of the pspm.");
  }
  if (!alphabet.has_complement()) {
    throw new Error("The specified alphabet can not be complemented.");
  }
  // reverse motif
  this.reverse();
  //complement
  for (x = 0; x < this.motif_length; x++) {
    row = this.pspm[x];
    for (i = 0; i < row.length; i++) {
      c = alphabet.get_complement(i);
      if (c < i) continue;
      temp = row[i];
      row[i] = row[c];
      row[c] = temp;
    }
  }
  // complement pssm (if defined)
  if (typeof this.pssm !== "undefined") {
    //complement
    for (x = 0; x < this.motif_length; x++) {
      row = this.pssm[x];
      for (i = 0; i < row.length; i++) {
        c = alphabet.get_complement(i);
        if (c < i) continue;
        temp = row[i];
        row[i] = row[c];
        row[c] = temp;
      }
    }
  }
  return this; //allow function chaining...
};

Pspm.prototype.get_stack = function(position, alphabet, ssc) {
  "use strict";
  var row, stack_ic, alphabet_ic, stack, i, sym;
  if (this.alph_length != alphabet.get_size_core()) {
    throw new Error("The alphabet size does not match the size of the pspm.");
  }
  row = this.pspm[position];
  stack_ic = this.get_stack_ic(position, alphabet);
  if (ssc) stack_ic -= this.get_error(alphabet);
  alphabet_ic = alphabet.get_ic();
  stack = [];
  for (i = 0; i < this.alph_length; i++) {
    sym = new Symbol(i, row[i]*stack_ic/alphabet_ic, alphabet);
    if (sym.get_scale() <= 0) {
      continue;
    }
    stack.push(sym);
  }
  stack.sort(compare_symbol);
  return stack;
};

Pspm.prototype.get_stack_ic = function(position, alphabet) {
  "use strict";
  var row, H, i;
  if (this.alph_length != alphabet.get_size_core()) {
    throw new Error("The alphabet size does not match the size fo the pspm.");
  }
  row = this.pspm[position];
  H = 0;
  for (i = 0; i < this.alph_length; i++) {
    if (row[i] === 0) {
      continue;
    }
    H -= (row[i] * (Math.log(row[i]) / Math.LN2));
  }
  return alphabet.get_ic() - H;
};

Pspm.prototype.get_error = function(alphabet) {
  "use strict";
  if (this.nsites === 0) {
    return 0;
  }
  return (alphabet.get_size_core()-1) / (2 * Math.LN2 * this.nsites);
};

Pspm.prototype.get_motif_length = function() {
  "use strict";
  return this.motif_length;
};

Pspm.prototype.get_alph_length = function() {
  "use strict";
  return this.alph_length;
};

Pspm.prototype.get_left_trim = function() {
  "use strict";
  return this.ltrim;
};

Pspm.prototype.get_right_trim = function() {
  "use strict";
  return this.rtrim;
};

Pspm.prototype.as_best_match = function(alphabet) {
  "use strict";
  var match, odds, best_odds, best_index;
  var i, j;
  match = "";
  for (i = 0; i < this.motif_length; i++) {
    best_index = 0;
    best_odds = this.pspm[i][0] / alphabet.get_bg_freq(0);
    for (j = 1; j < this.alph_length; j++) {
      odds = this.pspm[i][j] / alphabet.get_bg_freq(j);
      if (odds > best_odds) {
        best_odds = odds;
        best_index = j;
      }
    }
    match += alphabet.get_symbol(best_index);
  }
  return match;
};

Pspm.prototype.as_count_matrix = function() {
  "use strict";
  var count, count_text, text;
  var i, j;
  text = "";
  for (i = 0; i < this.motif_length; i++) {
    if (i !== 0) {
      text += "\n";
    }
    for (j = 0; j < this.alph_length; j++) {
      if (j !== 0) {
        text += " ";
      }
      count = Math.round(this.nsites * this.pspm[i][j]);
      count_text = "" + count;
      // pad up to length of 4
      if (count_text.length < 4) {
        text += (new Array(5 - count_text.length)).join(" ") + count_text;
      } else {
        text += count_text;
      }
    }
  }
  return text; 
};

Pspm.prototype.as_probability_matrix = function() {
  "use strict";
  var text;
  var i, j;
  text = "";
  for (i = 0; i < this.motif_length; i++) {
    if (i !== 0) {
      text += "\n";
    }
    for (j = 0; j < this.alph_length; j++) {
      if (j !== 0) {
        text += " ";
      }
      text += this.pspm[i][j].toFixed(6);
    }
  }
  return text; 
};

Pspm.prototype.as_score_matrix = function(alphabet, pseudo) {
  "use strict";
  var me, score, out, row, col, score_text;
  me = this;
  if (typeof this.pssm === "undefined") {
    if (!(typeof alphabet === "object" && alphabet != null && alphabet instanceof Alphabet)) {
      throw new Error("The alphabet is required to generate the pssm.");
    }
    if (typeof pseudo === "undefined") {
      pseudo = 0.01;
    } else if (typeof pseudo !== "number" || pseudo < 0) {
      throw new Error("Expected positive number for pseudocount");
    }
    score = function(row, col) {
      "use strict";
      var p, bg, p2;
      p = me.pspm[row][col];
      bg = alphabet.get_bg_freq(col);
      p2 = (p * me.nsites + bg * pseudo) / (me.nsites + pseudo);
      return (p2 > 0 ? Math.round((Math.log(p2 / bg) / Math.LN2) * 100) : -10000);
    };
  } else {
    score = function(row, col) {
      "use strict";
      return me.pssm[row][col];
    };
  }
  out = "";
  for (row = 0; row < this.motif_length; row++) {
    for (col = 0; col < this.alph_length; col++) {
      if (col !== 0) {
        out += " ";
      }
      score_text = "" + score(row, col);
      // pad out to 6 characters
      if (score_text.length < 6) {
        out += (new Array(7 - score_text.length)).join(" ") + score_text;
      } else {
        out += score_text;
      }
    }
    out += "\n";
  }
  return out;
}

Pspm.prototype.as_pspm = function() {
  "use strict";
  return "letter-probability matrix: alength= " + this.alph_length + 
      " w= " + this.motif_length + " nsites= " + this.nsites + 
      (this.pgm === "STREME" ? " P= " : " E= ") + 
          (typeof this.evalue === "number" ? 
          this.evalue.toExponential() : this.evalue) + "\n" +
      this.as_probability_matrix();
};

Pspm.prototype.as_pssm = function(alphabet, pseudo) {
  "use strict";
  return "log-odds matrix: alength= " + this.alph_length + 
      " w= " + this.motif_length + 
      " E= " + (typeof this.evalue == "number" ?
          this.evalue.toExponential() : this.evalue) + "\n" +
      this.as_score_matrix(alphabet, pseudo);
};

Pspm.prototype.as_meme = function(options) {
  var with_header, with_pspm, with_pssm, version, alphabet, bg_source, pseudocount, strands;
  var out, alen, i;
  // get the options
  if (typeof options !== "object" || options === null) {
    options = {};
  }
  with_header = (typeof options["with_header"] === "boolean" ? options["with_header"] : false);
  with_pspm = (typeof options["with_pspm"] === "boolean" ? options["with_pspm"] : false);
  with_pssm = (typeof options["with_pssm"] === "boolean" ? options["with_pssm"] : false);
  if (!with_pspm && !with_pssm) with_pspm = true;
  if (with_header) {
    if (typeof options["version"] === "string" && /^\d+(?:\.\d+){0,2}$/.test(options["version"])) {
      version = options["version"];
    } else if (typeof options["version"] === "number") {
      version = options["version"].toFixed(0);
    } else {
      version = "4";
    }
    if (typeof options["strands"] === "number" && options["strands"] === 1) {
      strands = 1;
    } else {
      strands = 2;
    }
    if (typeof options["bg_source"] === "string") {
      bg_source = options["bg_source"];
    } else {
      bg_source = "unknown source";
    }
    if (typeof options["alphabet"] === "object" && options["alphabet"] != null
        && options["alphabet"] instanceof Alphabet) {
      alphabet = options["alphabet"];
    } else {
      throw new Error("The alphabet is required to generate the header.");
    }
  }
  // now create the output
  out = "";
  if (with_header) {
    out = "MEME version " + version + "\n\n";
    out += alphabet.as_meme() + "\n";
    if (alphabet.has_complement()) { // assume DNA has both strands unless otherwise specified
      out += "strands: " + (strands === 1 ? "+" : "+ -") + "\n\n";
    }
    out += "Background letter frequencies (from " + bg_source + "):\n";
    alen = alphabet.get_size_core();
    for (i = 0; i < alen; i++) {
      if (i !== 0) {
        if (i % 9 === 0) { // maximum of nine entries per line
          out += "\n";
        } else {
          out += " ";
        }
      }
      out += alphabet.get_symbol(i) + " " + alphabet.get_bg_freq(i).toFixed(3);
    }
  }
  out += "\n\n";
  out += "MOTIF " + this.name + (this.alt == null ? "" : " " + this.alt);
  if (with_pssm) {
    out += "\n\n";
    out += this.as_pssm(options["alphabet"], options["pseudocount"]);
  }
  if (with_pspm) {
    out += "\n\n";
    out += this.as_pspm();
  }
  return out;
}

Pspm.prototype.toString = function() {
  "use strict";
  var str, i, row;
  str = "";
  for (i = 0; i < this.pspm.length; i++) {
    row = this.pspm[i];
    str += row.join("\t") + "\n";
  }
  return str;
};

function parse_pspm_properties(str) {
  "use strict";
  var parts, i, eqpos, before, after, properties, prop, num, num_re;
  num_re = /^((?:[+]?[0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)|inf)$/;
  parts = trim(str).split(/\s+/);
  // split up words containing =
  for (i = 0; i < parts.length;) {
    eqpos = parts[i].indexOf("=");
    if (eqpos != -1) {
      before = parts[i].substr(0, eqpos);
      after = parts[i].substr(eqpos+1);
      if (before.length > 0 && after.length > 0) {
        parts.splice(i, 1, before, "=", after);
        i += 3;
      } else if (before.length > 0) {
        parts.splice(i, 1, before, "=");
        i += 2;
      } else if (after.length > 0) {
        parts.splice(i, 1, "=", after);
        i += 2;
      } else {
        parts.splice(i, 1, "=");
        i++;
      }
    } else {
      i++;
    }
  }
  properties = {};
  for (i = 0; i < parts.length; i += 3) {
    if (parts.length - i < 3) {
      throw new Error("Expected PSPM property was incomplete. "+
          "Remaing parts are: " + parts.slice(i).join(" "));
    }
    if (parts[i+1] !== "=") {
      throw new Error("Expected '=' in PSPM property between key and " +
          "value but got " + parts[i+1]); 
    }
    prop = parts[i].toLowerCase();
    num = parts[i+2];
    if (!num_re.test(num)) {
      throw new Error("Expected numeric value for PSPM property '" + 
          prop + "' but got '" + num + "'");
    }
    properties[prop] = num;
  }
  return properties;
}

function parse_pspm_string(pspm_string) {
  "use strict";
  var header_re, lines, first_line, line_num, col_num, alph_length, 
      motif_length, nsites, evalue, pspm, i, line, match, props, parts,
      j, prob;
  header_re = /^letter-probability\s+matrix:(.*)$/i;
  lines = pspm_string.split(/\n/);
  first_line = true;
  line_num = 0;
  col_num = 0;
  alph_length;
  motif_length;
  nsites;
  evalue;
  pspm = [];
  for (i = 0; i < lines.length; i++) {
    line = trim(lines[i]);
    if (line.length === 0) { 
      continue;
    }
    // check the first line for a header though allow matrices without it
    if (first_line) {
      first_line = false;
      match = header_re.exec(line);
      if (match !== null) {
        props = parse_pspm_properties(match[1]);
        if (props.hasOwnProperty("alength")) {
          alph_length = parseFloat(props["alength"]);
          if (alph_length != 4 && alph_length != 20) {
            throw new Error("PSPM property alength should be 4 or 20" +
                " but got " + alph_length);
          }
        }
        if (props.hasOwnProperty("w")) {
          motif_length = parseFloat(props["w"]);
          if (motif_length % 1 !== 0 || motif_length < 1) {
            throw new Error("PSPM property w should be an integer larger " +
                "than zero but got " + motif_length);
          }
        }
        if (props.hasOwnProperty("nsites")) {
          nsites = parseFloat(props["nsites"]);
          if (nsites <= 0) {
            throw new Error("PSPM property nsites should be larger than " +
                "zero but got " + nsites);
          }
        }
        if (props.hasOwnProperty("e")) {
          evalue = props["e"];
          if (evalue < 0) {
            throw new Error("PSPM property evalue should be " +
                "non-negative but got " + evalue);
          }
        }
        continue;
      }
    }
    pspm[line_num] = [];
    col_num = 0;
    parts = line.split(/\s+/);
    for (j = 0; j < parts.length; j++) {
      prob = parseFloat(parts[j]);
      if (prob != parts[j] || prob < 0 || prob > 1) {
        throw new Error("Expected probability but got '" + parts[j] + "'"); 
      }
      pspm[line_num][col_num] = prob;
      col_num++;
    }
    line_num++;
  }
  if (typeof motif_length === "number") {
    if (pspm.length != motif_length) {
      throw new Error("Expected PSPM to have a motif length of " + 
          motif_length + " but it was actually " + pspm.length);
    }
  } else {
    motif_length = pspm.length;
  }
  if (typeof alph_length !== "number") {
    alph_length = pspm[0].length;
    if (alph_length != 4 && alph_length != 20) {
      throw new Error("Expected length of first row in the PSPM to be " +
          "either 4 or 20 but got " + alph_length);
    }
  }
  for (i = 0; i < pspm.length; i++) {
    if (pspm[i].length != alph_length) {
      throw new Error("Expected PSPM row " + i + " to have a length of " + 
          alph_length + " but the length was " + pspm[i].length);
    }
  }
  return {"pspm": pspm, "motif_length": motif_length, 
    "alph_length": alph_length, "nsites": nsites, "evalue": evalue};
}
//======================================================================
// end Pspm object
//======================================================================

//======================================================================
// start Logo object
//======================================================================

var Logo = function(alphabet, options) {
  "use strict";
  this.alphabet = alphabet;
  this.fine_text = "";
  this.x_axis = 1;
  this.y_axis = true;
  this.xlate_nsyms = 1;
  this.xlate_start = null;
  this.xlate_end = null;
  this.pspm_list = [];
  this.pspm_column = [];
  this.rows = 0;
  this.columns = 0;
  if (typeof options === "string") {
    // the old method signature had fine_text here so we support that
    this.fine_text = options;
  } else if (typeof options === "object" && options != null) {
    this.fine_text = (typeof options.fine_text === "string" ? options.fine_text : "");
    this.x_axis = (typeof options.x_axis === "boolean" ? (options.x_axis ? 1 : 0) : 1);
    if (options.x_axis_hidden != null && options.x_axis_hidden) this.x_axis = -1;
    this.y_axis = (typeof options.y_axis === "boolean" ? options.y_axis : true);
    this.xlate_nsyms = (typeof options.xlate_nsyms === "number" ? options.xlate_nsyms : this.xlate_nsyms);
    this.xlate_start = (typeof options.xlate_start === "number" ? options.xlate_start : this.xlate_start);
    this.xlate_end = (typeof options.xlate_end === "number" ? options.xlate_end : this.xlate_end);
  }
};

Logo.prototype.add_pspm = function(pspm, column) {
  "use strict";
  var col;
  if (typeof column === "undefined") {
    column = 0;
  } else if (column < 0) {
    throw new Error("Column index out of bounds.");
  }
  this.pspm_list[this.rows] = pspm;
  this.pspm_column[this.rows] = column;
  this.rows++;
  col = column + pspm.get_motif_length();
  if (col > this.columns) {
    this.columns = col;
  }
};

Logo.prototype.get_columns = function() {
  "use strict";
  return this.columns;
};

Logo.prototype.get_xlate_nsyms = function() {
  "use strict";
  return this.xlate_nsyms;
};

Logo.prototype.get_xlate_start = function() {
  "use strict";
  return (this.xlate_start != null ? this.xlate_start : 0);
};

Logo.prototype.get_xlate_end = function() {
  "use strict";
  return (this.xlate_end != null ? this.xlate_end : this.columns * this.xlate_nsyms);
};

Logo.prototype.get_xlate_columns = function() {
  "use strict";
  return this.get_xlate_end() - this.get_xlate_start();
};

Logo.prototype.get_rows = function() {
  "use strict";
  return this.rows;
};

Logo.prototype.get_pspm = function(row_index) {
  "use strict";
  if (row_index < 0 || row_index >= this.rows) {
    throw new Error("INDEX_OUT_OF_BOUNDS");
  }
  return this.pspm_list[row_index];
};

Logo.prototype.get_offset = function(row_index) {
  "use strict";
  if (row_index < 0 || row_index >= this.rows) {
    throw new Error("INDEX_OUT_OF_BOUNDS");
  }
  return this.pspm_column[row_index];
};

Logo.prototype._as_eps_data = function(ssc, errbars) {
  var i, j, pos, stack_pos, pspm, stack, sym, out;
  out = "";
  for (i = 0; i < this.rows; i++) {
    out += "\nStartLine\n";
    // Indent
    for (j = 0; j < this.pspm_column[i]; j++) {
      out += "() startstack\nendstack\n\n";
    }
    pspm = this.pspm_list[i];
    if (pspm.get_left_trim() > 0) {
      out += "MuteColour\nDrawTrimEdge\n" + pspm.get_left_trim() + " DrawTrimBg\n";
    }
    for (pos = 0; pos < pspm.get_motif_length(); pos++) {
      if (pos != 0 && pos == pspm.get_left_trim()) { // enable full colour
        out += "DrawTrimEdge\nRestoreColour\n";
      } else if (pos == (pspm.get_motif_length() - pspm.get_right_trim())) {
        out += "MuteColour\n" + pspm.get_right_trim() + " DrawTrimBg\n";
      }
      out += "(" + (pos + 1) + ") startstack\n";
      stack = pspm.get_stack(pos, this.alphabet, ssc);
      for (stack_pos = 0; stack_pos < stack.length; stack_pos++) {
        sym = stack[stack_pos];
        out += " " + (sym.get_scale() * this.alphabet.get_ic()) + " (" + sym.get_symbol() + ") numchar\n";
      }
      if (errbars) {
        out += " " + pspm.get_error(this.alphabet) + " Ibeam\n";
      }
      out += "endstack\n\n";
    }
    if (pspm.get_right_trim() > 0 || pspm.get_left_trim() == pspm.get_motif_length()) {
      out += "RestoreColour\n";
    }
    out += "EndLine\n";
  }
  return out;
};

Logo.prototype.as_eps = function(options) {
  "use strict";
  if (this.xlate_nsyms != 1) throw new Error("Unsupported setting xlate_nsyms for EPS");
  if (this.xlate_start != null) throw new Error("Unsupported setting xlate_start for EPS");
  if (this.xlate_end != null) throw new Error("Unsupported setting xlate_end for EPS");

  var LOGOHEIGHT = 7.5; // default height of line in cm
  var cm2pts, height, width, now, ssc, errbars;
  if (typeof options === "undefined") {
    options = {};
  }
  cm2pts = 72 / 2.54;
  if (typeof options.logo_height == "number") {
    height = options.logo_height;
  } else {
    height = LOGOHEIGHT * this.rows;
  }
  if (typeof options.logo_width == "number") {
    width = options.logo_width;
  } else {
    width = this.columns + 2;
  }
  now = new Date();
  ssc = (typeof options.ssc == "boolean" ? options.ssc : false);
  errbars = (typeof options.show_error_bar == "boolean" ? options.show_error_bar : ssc);
  var values = {
    "LOGOHEIGHT": height,
    "LOGOWIDTH": width,
    "BOUNDINGHEIGHT": Math.round(height * cm2pts),
    "BOUNDINGWIDTH": Math.round(width * cm2pts),
    "LOGOLINEHEIGHT": (height / this.rows),
    "CHARSPERLINE": this.columns,
    "BARBITS": this.alphabet.get_ic(),
    "LOGOTYPE": (this.alphabet.has_complement() ? "NA" : "AA"),
    "CREATIONDATE": now.getDate() + "." + (now.getMonth() + 1) + "." + now.getFullYear() + " " + now.getHours() + ":" + now.getMinutes() + ":" + now.getSeconds(),
    "ERRORBARFRACTION": (typeof options.error_bar_fraction == "number" ? options.error_bar_fraction : 1.0),
    "TICBITS": (typeof options.ticbits == "number" ? options.ticbits : 1.0),
    "TITLE": (typeof options.title == "string" ? options.title : ""),
    "FINEPRINT": (typeof options.fineprint == "string" ? options.fineprint : this.fine_text),
    "XAXISLABEL": (typeof options.xaxislabel == "string" ? options.xaxislabel : ""),
    "YAXISLABEL": (typeof options.yaxislabel == "string" ? options.yaxislabel : "bits"),
    "SSC": ssc,
    "YAXIS": (typeof options.show_y_axis == "boolean" ? options.show_y_axis : this.y_axis),
    "SHOWENDS": (typeof options.show_ends == "boolean" ? options.show_ends : false),
    "ERRBAR": errbars,
    "OUTLINE": (typeof options.show_outline == "boolean" ? options.show_outline : false),
    "NUMBERING": (typeof options.show_numbering == "boolean" ? options.show_numbering : this.x_axis != 0),
    "SHOWINGBOX": (typeof options.show_box == "boolean" ? options.show_box : false),
    "CREATOR": (typeof options.creator == "string" ? options.creator : "motif_logo.js"),
    "FONTSIZE": (typeof options.label_font_size == "number" ? options.label_font_size : 12),
    "TITLEFONTSIZE": (typeof options.title_font_size == "number" ? options.title_font_size : 12),
    "SMALLFONTSIZE": (typeof options.small_font_size == "number" ? options.small_font_size : 6),
    "TOPMARGIN" : (typeof options.top_margin == "number" ? options.top_margin : 0.9),
    "BOTTOMMARGIN": (typeof options.bottom_margin == "number" ? options.bottom_margin : 0.9),
    "COLORDICT": this.alphabet._as_eps_dict(),
    "DATA": this._as_eps_data(ssc, errbars)
  };
  // now this requires that the script containing the template has been imported!
  return motif_logo_template(values);
};

//======================================================================
// end Logo object
//======================================================================

// calculate the exact size (in pixels) of an object drawn on the
// canvas assuming that the background of the canvas is transparent.
function canvas_bounds(ctx, cwidth, cheight) {
  "use strict";
  var data, r, c, top_line, bottom_line, left_line, right_line, 
      txt_width, txt_height;

  // extract the image data
  data = ctx.getImageData(0, 0, cwidth, cheight).data;

  // set initial values
  top_line = -1; bottom_line = -1; left_line = -1; right_line = -1;
  txt_width = 0; txt_height = 0;

  // Find the top-most line with a non-transparent pixel
  for (r = 0; r < cheight; r++) {
    for (c = 0; c < cwidth; c++) {
      if (data[r * cwidth * 4 + c * 4 + 3]) {
        top_line = r;
        break;
      }
    }
    if (top_line != -1) {
      break;
    }
  }
  
  // Only bother looking if we found at least one set pixel... 
  if (top_line != -1) {

    //find the last line with a non-transparent pixel
    for (r = cheight-1; r >= top_line; r--) {
      for(c = 0; c < cwidth; c++) {
        if(data[r * cwidth * 4 + c * 4 + 3]) {
          bottom_line = r;
          break;
        }
      }
      if (bottom_line != -1) {
        break;
      }
    }
    // calculate height
    txt_height = bottom_line - top_line + 1;

    // Find the left-most line with a non-transparent pixel
    for (c = 0; c < cwidth; c++) {
      for (r = top_line; r <= bottom_line; r++) {
        if (data[r * cwidth * 4 + c * 4 + 3]) {
          left_line = c;
          break;
        }
      }
      if (left_line != -1) {
        break;
      }
    }

    //find the right most line with a non-transparent pixel
    for (c = cwidth-1; c >= left_line; c--) {
      for(r = top_line; r <= bottom_line; r++) {
        if(data[r * cwidth * 4 + c * 4 + 3]) {
          right_line = c;
          break;
        }
      }
      if (right_line != -1) {
        break;
      }
    }
    txt_width = right_line - left_line + 1;
  }

  //return the bounds
  return {bound_top: top_line, bound_bottom: bottom_line, 
    bound_left: left_line, bound_right: right_line, width: txt_width, 
    height: txt_height};
}

//======================================================================
// start RasterizedAlphabet
//======================================================================

// Rasterize Alphabet
// 1) Measure width of text at default font for all symbols in alphabet
// 2) sort in width ascending
// 3) Drop the top and bottom 10% (designed to ignore outliers like 'W' and 'I')
// 4) Calculate the average as the maximum scaling factor (designed to stop I becoming a rectangular blob).
// 5) Assume scale of zero would result in width of zero, interpolate scale required to make perfect width font
// 6) Draw text onto temp canvas at calculated scale
// 7) Find bounds of drawn text
// 8) Paint on to another canvas at the desired height (but only scaling width to fit if larger).
var RasterizedAlphabet = function(alphabet, logo_scale, font, width) {
  "use strict";
  var default_size, safety_pad, canvas, ctx, middle, baseline, widths, sizes,
      i, sym, size, tenpercent, avg_width, scale, 
      target_width, target_height;
  //variable prototypes
  this.alphabet = alphabet;
  this.scale = logo_scale;
  this.sym_cache = {};
  this.stack_num_cache = [];
  this.scale_num_cache = [];
  // size of canvas
  default_size = 60; // size of measuring canvas
  safety_pad = 20; // pixels to pad around so we don't miss the edges
  // create a canvas to do our measuring
  canvas = document.createElement("canvas");
  if (!canvas.getContext) throw new Error("No canvas support");
  canvas.width = default_size + 2 * safety_pad;
  canvas.height = default_size + 2 * safety_pad;
  middle = Math.round(canvas.width / 2);
  baseline = Math.round(canvas.height - safety_pad);
  ctx = canvas.getContext('2d');
  if (!supports_text(ctx)) throw new Error("Canvas does not support text");
  ctx.font = font;
  ctx.textAlign = "center";
  ctx.translate(middle, baseline);
  // list of widths
  widths = [];
  sizes = [];
  //now measure each letter in the alphabet
  for (i = 0; i < alphabet.get_size_core(); ++i) {
    // reset the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = alphabet.get_colour(i);
    // draw the test text
    ctx.fillText(alphabet.get_symbol(i), 0, 0);
    //measure
    size = canvas_bounds(ctx, canvas.width, canvas.height);
    if (size.width === 0) throw new Error("Invisible symbol!");
    widths.push(size.width);
    sizes[i] = size;
  }
  //sort the widths
  widths.sort(function(a,b) {return a - b;});
  //drop 10% of the items off each end
  tenpercent = Math.floor(widths.length / 10);
  for (i = 0; i < tenpercent; ++i) {
    widths.pop();
    widths.shift();
  }
  //calculate average width
  avg_width = 0;
  for (i = 0; i < widths.length; ++i) {
    avg_width += widths[i];
  }
  avg_width /= widths.length;
  // calculate the target width
  target_width = width * this.scale * 2;
  // calculate scales
  for (i = 0; i < alphabet.get_size_core(); ++i) {
    sym = alphabet.get_symbol(i);
    size = sizes[i];
    // calculate scale
    scale = target_width / Math.max(avg_width, size.width);
    // estimate scaled height
    target_height = size.height * scale;
    // create an appropriately sized canvas
    canvas = document.createElement("canvas");
    canvas.width = target_width;
    canvas.height = target_height + safety_pad * 2;
    // calculate the middle
    middle = Math.round(canvas.width / 2);
    // calculate the baseline
    baseline = Math.round(canvas.height - safety_pad);
    // get the context and prepare to draw the rasterized text
    ctx = canvas.getContext('2d');
    ctx.font = font;
    ctx.fillStyle = alphabet.get_colour(i);
    ctx.textAlign = "center";
    ctx.translate(middle, baseline);
    ctx.save();
    ctx.scale(scale, scale);
    // draw the text
    ctx.fillText(sym, 0, 0);
    ctx.restore();
    this.sym_cache[sym] = {"image": canvas, "size": canvas_bounds(ctx, canvas.width, canvas.height)};
  }
};

RasterizedAlphabet.prototype.get_alphabet = function() {
  return this.alphabet;
};

RasterizedAlphabet.prototype.get_scale = function() {
  return this.scale;
};

RasterizedAlphabet.prototype.draw_stack_sym = function(ctx, letter, dx, dy, dWidth, dHeight) {
  "use strict";
  var entry, image, size;
  entry = this.sym_cache[letter];
  image = entry.image;
  size = entry.size;
  ctx.drawImage(image, 0, size.bound_top -1, image.width, size.height+1, dx, dy, dWidth, dHeight);
};

RasterizedAlphabet.prototype.draw_stack_num = function(ctx, font, stack_width, index) {
  var image, image_ctx, text_length;
  if (index >= this.stack_num_cache.length) {
    image = document.createElement("canvas");
    // measure the text
    image_ctx = image.getContext('2d');
    image_ctx.save();
    image_ctx.font = font;
    text_length = image_ctx.measureText("" + (index + 1)).width;
    image_ctx.restore();
    // resize the canvas to fit
    image.width = Math.ceil(stack_width);
    image.height = Math.ceil(text_length);
    // draw the text
    image_ctx = image.getContext('2d');
    image_ctx.translate(Math.round(stack_width / 2), 0);
    image_ctx.font = font;
    image_ctx.textBaseline = "middle";
    image_ctx.textAlign = "right";
    image_ctx.rotate(-(Math.PI / 2));
    image_ctx.fillText("" + (index + 1), 0, 0);
    this.stack_num_cache[index] = image;
  } else {
    image = this.stack_num_cache[index];
  }
  ctx.drawImage(image, 0, 0);
}

RasterizedAlphabet.prototype.draw_scale_num = function(ctx, font, num) {
  var image, image_ctx, text_size, m_length;
  if (num >= this.scale_num_cache.length) {
    image = document.createElement("canvas");
    // measure the text
    image_ctx = image.getContext('2d');
    image_ctx.font = font;
    text_size = image_ctx.measureText("" + num);
    if (text_size.actualBoundingBoxAscent && text_size.actualBoundingBoxDesent) {
      // resize the canvas to fit
      image.width = Math.ceil(text_size.width);
      image.height = Math.ceil(text_size.actualBoundingBoxAscent + text_size.actualBoundingBoxDesent);
      // draw the text
      image_ctx = image.getContext('2d');
      image_ctx.font = font;
      image_ctx.textAlign = "right";
      image_ctx.fillText("" + num, image.width, text_size.actualBoundingBoxAscent);
    } else {
      // measure width of 'm' to approximate height, we double it later anyway
      m_length = image_ctx.measureText("m").width;
      // resize the canvas to fit
      image.width = Math.ceil(text_size.width);
      image.height = Math.ceil(2 * m_length);
      // draw the text
      image_ctx = image.getContext('2d');
      image_ctx.font = font;
      image_ctx.textAlign = "right";
      image_ctx.textBaseline = "middle";
      image_ctx.fillText("" + num, image.width, m_length);
    }
    this.scale_num_cache[num] = image;
  } else {
    image = this.scale_num_cache[num];
  }
  ctx.drawImage(image, -image.width, -Math.round(image.height / 2))
}

//======================================================================
// end RasterizedAlphabet
//======================================================================

//======================================================================
// start LogoMetrics object
//======================================================================

var LogoMetrics = function(ctx, logo_columns, logo_rows, has_names, has_finetext, x_axis, y_axis) {
  "use strict";
  var i, row_height;
  //variable prototypes
  this.pad_top = (has_names ? 5 : 0);
  this.pad_left = (y_axis ? 10 : 0);
  this.pad_right = (has_finetext ? 15 : 0);
  this.pad_bottom = 0;
  this.pad_middle = 20;
  this.name_height = 14;
  this.name_font = "bold " + this.name_height + "px Times, sans-serif";
  this.name_spacer = 0;
  this.y_axis = y_axis;
  this.y_label = "bits";
  this.y_label_height = 12;
  this.y_label_font = "bold " + this.y_label_height + "px Helvetica, sans-serif";
  this.y_label_spacer = 3;
  this.y_num_height = 12;
  this.y_num_width = 0;
  this.y_num_font = "bold " + this.y_num_height + "px Helvetica, sans-serif";
  this.y_tic_width = 5;
  this.stack_pad_left = 0;
  this.stack_font = "bold 25px Helvetica, sans-serif";
  this.stack_height = 90;
  this.stack_width = 26;
  this.stacks_pad_right = 5;
  this.x_axis = x_axis;
  this.x_num_above = 2;
  this.x_num_height = 12;
  this.x_num_width = 0;
  this.x_num_font = "bold " + this.x_num_height + "px Helvetica, sans-serif";
  this.fine_txt_height = 6;
  this.fine_txt_above = 2;
  this.fine_txt_font = "normal " + this.fine_txt_height + "px Helvetica, sans-serif";
  this.letter_metrics = new Array();
  this.summed_width = 0;
  this.summed_height = 0;
  //calculate the width of the y axis numbers
  ctx.font = this.y_num_font;
  for (i = 0; i <= 2; i++) {
    this.y_num_width = Math.max(this.y_num_width, ctx.measureText("" + i).width);
  }
  //calculate the width of the x axis numbers (but they are rotated so it becomes height)
  if (x_axis == 1) {
    ctx.font = this.x_num_font;
    for (i = 1; i <= logo_columns; i++) {
      this.x_num_width = Math.max(this.x_num_width, ctx.measureText("" + i).width);
    }
  } else if (x_axis == 0) {
    this.x_num_height = 4;
    this.x_num_width = 4;
  } else {
    this.x_num_height = 0;
    this.x_num_width = 0;
  }
  
  //calculate how much vertical space we want to draw this
  //first we add the padding at the top and bottom since that's always there
  this.summed_height += this.pad_top + this.pad_bottom;
  //all except the last row have the same amount of space allocated to them
  if (logo_rows > 1) {
    row_height = this.stack_height + this.pad_middle;
    if (has_names) {
      row_height += this.name_height;
      //the label is allowed to overlap into the spacer
      row_height += Math.max(this.y_num_height/2, this.name_spacer); 
      //the label is allowed to overlap the space used by the other label
      row_height += Math.max(this.y_num_height/2, this.x_num_height + this.x_num_above); 
    } else {
      row_height += this.y_num_height/2; 
      //the label is allowed to overlap the space used by the other label
      row_height += Math.max(this.y_num_height/2, this.x_num_height + this.x_num_above); 
    }
    this.summed_height += row_height * (logo_rows - 1);
  }
  //the last row has the name and fine text below it but no padding
  this.summed_height += this.stack_height + (this.y_axis ? this.y_num_height/2 : 0);

  var fine_txt_total = (has_finetext ? this.fine_txt_height + this.fine_txt_above : 0);
  if (has_names) {
    this.summed_height += fine_txt_total + this.name_height;
    this.summed_height += Math.max((this.y_axis ? this.y_num_height/2 : 0), 
        this.x_num_height + this.x_num_above + this.name_spacer);
  } else {
    this.summed_height += Math.max((this.y_axis ? this.y_num_height/2 : 0), 
        this.x_num_height + this.x_num_above + fine_txt_total);
  }

  //calculate how much horizontal space we want to draw this
  //first add the padding at the left and right since that's always there
  this.summed_width += this.pad_left + this.pad_right;
  if (this.y_axis) {
    //add on the space for the y-axis label
    this.summed_width += this.y_label_height + this.y_label_spacer;
    //add on the space for the y-axis
    this.summed_width += this.y_num_width + this.y_tic_width;
  }
  //add on the space for the stacks
  this.summed_width += (this.stack_pad_left + this.stack_width) * logo_columns;
  //add on the padding after the stacks (an offset from the fine text)
  this.summed_width += this.stacks_pad_right;

};

//======================================================================
// end LogoMetrics object
//======================================================================

//found this trick at http://talideon.com/weblog/2005/02/detecting-broken-images-js.cfm
function image_ok(img) {
  "use strict";
  // During the onload event, IE correctly identifies any images that
  // weren't downloaded as not complete. Others should too. Gecko-based
  // browsers act like NS4 in that they report this incorrectly.
  if (!img.complete) {
    return false;
  }
  // However, they do have two very useful properties: naturalWidth and
  // naturalHeight. These give the true size of the image. If it failed
  // to load, either of these should be zero.
  if (typeof img.naturalWidth !== "undefined" && img.naturalWidth === 0) {
    return false;
  }
  // No other way of checking: assume it's ok.
  return true;
}
  
function supports_text(ctx) {
  "use strict";
  if (!ctx.fillText) {
    return false;
  }
  if (!ctx.measureText) {
    return false;
  }
  return true;
}

//draws the scale, returns the width
function draw_scale(ctx, metrics, alphabet_ic, raster) {
  "use strict";
  var tic_height, i;
  tic_height = metrics.stack_height / alphabet_ic;
  ctx.save();
  ctx.translate(metrics.y_label_height, metrics.y_num_height/2);
  //draw the axis label
  ctx.save();
  ctx.font = metrics.y_label_font;
  ctx.translate(0, metrics.stack_height/2);
  ctx.rotate(-(Math.PI / 2));
  ctx.textAlign = "center";
  ctx.fillText("bits", 0, 0);
  ctx.restore();

  ctx.translate(metrics.y_label_spacer + metrics.y_num_width, 0);

  //draw the axis tics
  ctx.save();
  ctx.translate(0, metrics.stack_height);
  for (i = 0; i <= alphabet_ic; i++) {
    //draw the number
    ctx.save();
    ctx.translate(-1, 0);
    raster.draw_scale_num(ctx, metrics.y_num_font, i);
    ctx.restore();
    //draw the tic
    ctx.fillRect(0, -1, metrics.y_tic_width, 2);
    //prepare for next tic
    ctx.translate(0, -tic_height);
  }
  ctx.restore();

  ctx.fillRect(metrics.y_tic_width - 2, 0, 2, metrics.stack_height)

  ctx.restore();
}

function draw_stack_num(ctx, metrics, row_index, raster) {
  "use strict";
  ctx.save();
  ctx.translate(0, Math.round(metrics.stack_height + metrics.x_num_above));
  if (metrics.x_axis == 1) {
    raster.draw_stack_num(ctx, metrics.x_num_font, metrics.stack_width, row_index);
  } else if (metrics.x_axis == 0) {
    // draw dots instead of the numbers (good for small logos)
    ctx.beginPath();
    var radius = Math.round(metrics.x_num_height / 2);
    ctx.arc(Math.round(metrics.stack_width / 2), radius, radius, 0, 2 * Math.PI, false);
    ctx.fill();
  }
  ctx.restore();
}

function draw_stack(ctx, metrics, symbols, raster) {
  "use strict";
  var preferred_pad, sym_min, i, sym, sym_height, pad;
  preferred_pad = 0;
  sym_min = 5;

  ctx.save();//1
  ctx.translate(0, metrics.stack_height);
  for (i = 0; i < symbols.length; i++) {
    sym = symbols[i];
    sym_height = metrics.stack_height * sym.get_scale();
    
    pad = preferred_pad;
    if (sym_height - pad < sym_min) {
      pad = Math.min(pad, Math.max(0, sym_height - sym_min));
    }
    sym_height -= pad;

    //translate to the correct position
    ctx.translate(0, -(pad/2 + sym_height));

    //draw
    raster.draw_stack_sym(ctx, sym.get_symbol(), 0, 0, metrics.stack_width, sym_height);
    //translate past the padding
    ctx.translate(0, -(pad/2));
  }
  ctx.restore();//1
}

function draw_dashed_line(ctx, pattern, start, x1, y1, x2, y2) {
  "use strict";
  var x, y, len, i, dx, dy, tlen, theta, mulx, muly, lx, ly;
  dx = x2 - x1;
  dy = y2 - y1;
  tlen = Math.pow(dx*dx + dy*dy, 0.5);
  theta = Math.atan2(dy,dx);
  mulx = Math.cos(theta);
  muly = Math.sin(theta);
  lx = [];
  ly = [];
  for (i = 0; i < pattern; ++i) {
    lx.push(pattern[i] * mulx);
    ly.push(pattern[i] * muly);
  }
  i = start;
  x = x1;
  y = y1;
  len = 0;
  ctx.beginPath();
  while (len + pattern[i] < tlen) {
    ctx.moveTo(x, y);
    x += lx[i];
    y += ly[i];
    ctx.lineTo(x, y);
    len += pattern[i];
    i = (i + 1) % pattern.length;
    x += lx[i];
    y += ly[i];
    len += pattern[i];
    i = (i + 1) % pattern.length;
  }
  if (len < tlen) {
    ctx.moveTo(x, y);
    x += mulx * (tlen - len);
    y += muly * (tlen - len);
    ctx.lineTo(x, y);
  }
  ctx.stroke();
}

function draw_trim_background(ctx, metrics, left_start, left_end, left_divider, right_start, right_end, right_divider) {
  "use strict";
  var left_size = left_end - left_start;
  var right_size = right_end - right_start;
  var line_x;

  ctx.save();//s8
  ctx.fillStyle = "rgb(240, 240, 240)";
  if (left_size > 0) {
    ctx.fillRect(left_start * metrics.stack_width, 0, left_size * metrics.stack_width, metrics.stack_height);
  }
  if (right_size > 0) {
    ctx.fillRect(right_start * metrics.stack_width, 0, right_size * metrics.stack_width, metrics.stack_height);
  }
  ctx.fillStyle = "rgb(51, 51, 51)";
  if (left_size > 0 && left_divider) {
    line_x = (left_end * metrics.stack_width) - 0.5;
    draw_dashed_line(ctx, [3], 0, line_x, 0, line_x, metrics.stack_height);
  }
  if (right_size > 0 && right_divider) {
    line_x = (right_start * metrics.stack_width) + 0.5;
    draw_dashed_line(ctx, [3], 0, line_x, 0, line_x, metrics.stack_height);
  }
  ctx.restore();//s8
}

function size_logo_on_canvas(logo, canvas, show_names, scale) {
  "use strict";
  var draw_name, draw_finetext, metrics;
  draw_name = (typeof show_names === "boolean" ? show_names : (logo.get_rows() > 1));
  draw_finetext = (logo.fine_text.length > 0);
  if (canvas.width !== 0 && canvas.height !== 0) {
    return;
  }
  metrics = new LogoMetrics(canvas.getContext('2d'), 
      logo.get_xlate_columns(), logo.get_rows(), draw_name, draw_finetext, logo.x_axis, logo.y_axis);
  if (typeof scale == "number") {
    //resize the canvas to fit the scaled logo
    canvas.width = metrics.summed_width * scale;
    canvas.height = metrics.summed_height * scale;
  } else {
    if (canvas.width === 0 && canvas.height === 0) {
      canvas.width = metrics.summed_width;
      canvas.height = metrics.summed_height;
    } else if (canvas.width === 0) {
      canvas.width = metrics.summed_width * (canvas.height / metrics.summed_height);
    } else if (canvas.height === 0) {
      canvas.height = metrics.summed_height * (canvas.width / metrics.summed_width);
    }
  }
}

function draw_logo_on_canvas(logo, canvas, show_names, scale) {
  "use strict";
  var i, draw_name, draw_finetext, ctx, metrics, raster, pspm_i, pspm, 
      offset, col_index, motif_position, ssc;
  ssc = false;
  draw_name = (typeof show_names === "boolean" ? show_names : (logo.get_rows() > 1));
  draw_finetext = (logo.fine_text.length > 0);
  ctx = canvas.getContext('2d');
  //assume that the user wants the canvas scaled equally so calculate what the best width for this image should be
  metrics = new LogoMetrics(ctx, logo.get_xlate_columns(), logo.get_rows(), draw_name, draw_finetext, logo.x_axis, logo.y_axis);
  if (typeof scale == "number") {
    //resize the canvas to fit the scaled logo
    canvas.width = metrics.summed_width * scale;
    canvas.height = metrics.summed_height * scale;
  } else {
    if (canvas.width === 0 && canvas.height === 0) {
      scale = 1;
      canvas.width = metrics.summed_width;
      canvas.height = metrics.summed_height;
    } else if (canvas.width === 0) {
      scale = canvas.height / metrics.summed_height;
      canvas.width = metrics.summed_width * scale;
    } else if (canvas.height === 0) {
      scale = canvas.width / metrics.summed_width;
      canvas.height = metrics.summed_height * scale;
    } else {
      scale = Math.min(canvas.width / metrics.summed_width, canvas.height / metrics.summed_height);
    }
  }
  // cache the raster based on the assumption that we will be drawing a lot
  // of logos the same size and alphabet
  if (typeof draw_logo_on_canvas.raster_cache === "undefined") {
    draw_logo_on_canvas.raster_cache = [];
  }
  for (i = 0; i < draw_logo_on_canvas.raster_cache.length; i++) {
    raster = draw_logo_on_canvas.raster_cache[i];
    if (raster.get_alphabet().equals(logo.alphabet) &&
        Math.abs(raster.get_scale() - scale) < 0.1) break;
    raster = null;
  }
  if (raster == null) {
    raster = new RasterizedAlphabet(logo.alphabet, scale, metrics.stack_font, metrics.stack_width);
    draw_logo_on_canvas.raster_cache.push(raster);
  }
  ctx = canvas.getContext('2d');
  ctx.save();//s1
  ctx.scale(scale, scale);
  ctx.save();//s2
  ctx.save();//s7
  //create margin
  ctx.translate(Math.round(metrics.pad_left), Math.round(metrics.pad_top));
  for (pspm_i = 0; pspm_i < logo.get_rows(); ++pspm_i) {
    pspm = logo.get_pspm(pspm_i);
    offset = logo.get_offset(pspm_i);
    //optionally draw name if this isn't the last row or is the only row 
    if (draw_name && (logo.get_rows() == 1 || pspm_i != (logo.get_rows()-1))) {
      ctx.save();//s4
      ctx.translate(Math.round(metrics.summed_width/2), Math.round(metrics.name_height));
      ctx.font = metrics.name_font;
      ctx.textAlign = "center";
      ctx.fillText(pspm.name, 0, 0);
      ctx.restore();//s4
      ctx.translate(0, Math.round(metrics.name_height + 
          Math.min(0, metrics.name_spacer - metrics.y_num_height/2)));
    }
    //draw scale
    if (logo.y_axis) draw_scale(ctx, metrics, logo.alphabet.get_ic(), raster);
    ctx.save();//s5
    //translate across past the scale
    if (logo.y_axis) {
      ctx.translate(Math.round(metrics.y_label_height + metrics.y_label_spacer + 
        metrics.y_num_width + metrics.y_tic_width), Math.round(metrics.y_num_height / 2));
    }
    //draw the trimming background
    if (pspm.get_left_trim() > 0 || pspm.get_right_trim() > 0) {
      var left_start = offset * logo.get_xlate_nsyms();
      var left_end = (offset + pspm.get_left_trim()) * logo.get_xlate_nsyms();
      var left_divider = true;
      if (left_end < logo.get_xlate_start() || left_start > logo.get_xlate_end()) {
        // no overlap
        left_start = 0;
        left_end = 0;
        left_divider = false;
      } else {
        if (left_start < logo.get_xlate_start()) {
          left_start = logo.get_xlate_start();
        }
        if (left_end > logo.get_xlate_end()) {
          left_end = logo.get_xlate_end();
          left_divider = false;
        }
        left_start -= logo.get_xlate_start();
        left_end -= logo.get_xlate_start();
        if (left_end < left_start) {
          left_start = 0;
          left_end = 0;
          left_divider = false;
        }
      }
      var right_end = (offset + pspm.get_motif_length()) * logo.get_xlate_nsyms();
      //var right_start = right_end - (pspm.get_left_trim() * logo.get_xlate_nsyms());
      var right_start = right_end - (pspm.get_right_trim() * logo.get_xlate_nsyms());
      var right_divider = true;
      if (right_end < logo.get_xlate_start() || right_start > logo.get_xlate_end()) {
        // no overlap
        right_start = 0;
        right_end = 0;
        right_divider = false;
      } else {
        if (right_start < logo.get_xlate_start()) {
          right_start = logo.get_xlate_start();
          right_divider = false;
        }
        if (right_end > logo.get_xlate_end()) {
          right_end = logo.get_xlate_end();
        }
        right_start -= logo.get_xlate_start();
        right_end -= logo.get_xlate_start();
        if (right_end < right_start) {
          right_start = 0;
          right_end = 0;
          right_divider = false;
        }
      }
      draw_trim_background(ctx, metrics, left_start, left_end, left_divider, right_start, right_end, right_divider);
    }
    //draw letters
    var xlate_col;
    for (xlate_col = logo.get_xlate_start(); xlate_col < logo.get_xlate_end(); xlate_col++) {
      ctx.translate(metrics.stack_pad_left,0);
      col_index = Math.floor(xlate_col / logo.get_xlate_nsyms());
      if (xlate_col % logo.get_xlate_nsyms() == 0) {
        if (col_index >= offset && col_index < (offset + pspm.get_motif_length())) {
          motif_position = col_index - offset;
          draw_stack_num(ctx, metrics, motif_position, raster);
          draw_stack(ctx, metrics, pspm.get_stack(motif_position, logo.alphabet, ssc), raster);
        }
      } else {
        if (col_index >= offset && col_index < (offset + pspm.get_motif_length())) {
          ctx.save();// s5.1
          ctx.translate(0, Math.round(metrics.stack_height));
          // TODO draw a dot or dash or something to indicate continuity of the motif
          ctx.restore(); //s5.1
        }
      }
      ctx.translate(Math.round(metrics.stack_width), 0);
    }
    ctx.restore();//s5
    ////optionally draw name if this is the last row but isn't the only row 
    if (draw_name && (logo.get_rows() != 1 && pspm_i == (logo.get_rows()-1))) {
      //translate vertically past the stack and axis's        
      ctx.translate(0, metrics.y_num_height/2 + metrics.stack_height + 
          Math.max(metrics.y_num_height/2, metrics.x_num_above + metrics.x_num_width + metrics.name_spacer));

      ctx.save();//s6
      ctx.translate(metrics.summed_width/2, metrics.name_height);
      ctx.font = metrics.name_font;
      ctx.textAlign = "center";
      ctx.fillText(pspm.name, 0, 0);
      ctx.restore();//s6
      ctx.translate(0, metrics.name_height);
    } else {
      //translate vertically past the stack and axis's        
      ctx.translate(0, metrics.y_num_height/2 + metrics.stack_height + 
          Math.max(metrics.y_num_height/2, metrics.x_num_above + metrics.x_num_width));
    }
    //if not the last row then add middle padding
    if (pspm_i != (logo.get_rows() -1)) {
      ctx.translate(0, metrics.pad_middle);
    }
  }
  ctx.restore();//s7
  if (logo.fine_text.length > 0) {
    ctx.translate(metrics.summed_width - metrics.pad_right, metrics.summed_height - metrics.pad_bottom);
    ctx.font = metrics.fine_txt_font;
    ctx.textAlign = "right";
    ctx.fillText(logo.fine_text, 0,0);
  }
  ctx.restore();//s2
  ctx.restore();//s1
}

function create_canvas(c_width, c_height, c_id, c_title, c_display) {
  "use strict";
  var canvas = document.createElement("canvas");
  //check for canvas support before attempting anything
  if (!canvas.getContext) {
    return null;
  }
  var ctx = canvas.getContext('2d');
  //check for html5 text drawing support
  if (!supports_text(ctx)) {
    return null;
  }
  //size the canvas
  canvas.width = c_width;
  canvas.height = c_height;
  canvas.id = c_id;
  canvas.title = c_title;
  canvas.style.display = c_display;
  return canvas;
}

function logo_1(alphabet, fine_text, pspm) {
  "use strict";
  var logo = new Logo(alphabet, fine_text);
  logo.add_pspm(pspm);
  return logo;
}

function logo_2(alphabet, fine_text, target, query, query_offset) {
  "use strict";
  var logo = new Logo(alphabet, fine_text);
  if (query_offset < 0) {
    logo.add_pspm(target, -query_offset);
    logo.add_pspm(query);
  } else {
    logo.add_pspm(target);
    logo.add_pspm(query, query_offset);
  }      
  return logo;
}

/*
 * Specifies an alternate source for an image.
 * If the image with the image_id specified has
 * not loaded then a generated logo will be used 
 * to replace it.
 *
 * Note that the image must either have dimensions
 * or a scale must be set.
 */
function alternate_logo(logo, image_id, scale) {
  "use strict";
  var image = document.getElementById(image_id);
  if (!image) {
    alert("Can't find specified image id (" +  image_id + ")");
    return;
  }
  //if the image has loaded then there is no reason to use the canvas
  if (image_ok(image)) {
    return;
  }
  //the image has failed to load so replace it with a canvas if we can.
  var canvas = create_canvas(image.width, image.height, image_id, image.title, image.style.display);
  if (canvas === null) {
    return;
  }
  //draw the logo on the canvas
  draw_logo_on_canvas(logo, canvas, null, scale);
  //replace the image with the canvas
  image.parentNode.replaceChild(canvas, image);
}

/*
 * Specifies that the element with the specified id
 * should be replaced with a generated logo.
 */
function replace_logo(logo, replace_id, scale, title_txt, display_style) {
  "use strict";
  var element = document.getElementById(replace_id);
  if (!replace_id) {
    alert("Can't find specified id (" + replace_id + ")");
    return;
  }
  //found the element!
  var canvas = create_canvas(50, 120, replace_id, title_txt, display_style);
  if (canvas === null) {
    return;
  }
  //draw the logo on the canvas
  draw_logo_on_canvas(logo, canvas, null, scale);
  //replace the element with the canvas
  element.parentNode.replaceChild(canvas, element);
}

/*
 * Fast string trimming implementation found at
 * http://blog.stevenlevithan.com/archives/faster-trim-javascript
 *
 * Note that regex is good at removing leading space but
 * bad at removing trailing space as it has to first go through
 * the whole string.
 */
function trim (str) {
  "use strict";
  var ws, i;
  str = str.replace(/^\s\s*/, '');
  ws = /\s/; i = str.length;
  while (ws.test(str.charAt(--i)));
  return str.slice(0, i + 1);
}

//
// Delay drawing a logo
//
var DelayLogoTask = function(logo, canvas) {
  "use strict";
  canvas.width = canvas.width; // clear canvas
  this.logo = logo;
  this.canvas = canvas;
};

DelayLogoTask.prototype.run = function () {
  "use strict";
  this.canvas.width = this.canvas.width; // clear canvas
  draw_logo_on_canvas(this.logo, this.canvas, false);
};

/*
 * Make a canvas with the motif logo drawn on it.
 */
function make_logo(alphabet, pspm, height, rc, offset, className) {
  if (rc) pspm = pspm.copy().reverse_complement(alphabet);
  var logo = new Logo(alphabet);
  logo.add_pspm(pspm, offset);
  var canvas = document.createElement('canvas');
  var sizeit = (height < 0);
  canvas.height = (sizeit ? -height : height); 
  canvas.width = 0;
  canvas.className = className;
  if (sizeit) size_logo_on_canvas(logo, canvas, false);
  add_draw_task(canvas, new DelayLogoTask(logo, canvas));
  return canvas;
}

    </script>
    <script type="text/javascript">
//
// simple-shared-doc.js
//

//
// Function to redirect to appropriate doc file.
//
function get_doc_text(pgm, doc_type, extra, extra2) {
  switch (pgm) {
    case 'shared':
      return(get_shared_doc_text(doc_type, extra, extra2));
    case 'ame':
      return(get_ame_doc_text(doc_type, extra, extra2));
    case 'centrimo':
      return(get_centrimo_doc_text(doc_type, extra, extra2));
    case 'discovery':
      return(get_discovery_doc_text(doc_type, extra, extra2));
    case 'fimo':
      return(get_fimo_doc_text(doc_type, extra, extra2));
    case 'gomo':
      return(get_gomo_doc_text(doc_type, extra, extra2));
    case 'mcast':
      return(get_mcast_doc_text(doc_type, extra, extra2));
    case 'meme-chip':
      return(get_meme_chip_doc_text(doc_type, extra, extra2));
    case 'momo':
      return(get_momo_doc_text(doc_type, extra, extra2));
    case 'sea':
      return(get_sea_doc_text(doc_type, extra, extra2));
    case 'spamo':
      return(get_spamo_doc_text(doc_type, extra, extra2));
    case 'streme':
      return(get_streme_doc_text(doc_type, extra, extra2));
    case 'tgene':
      return(get_tgene_doc_text(doc_type, extra, extra2));
    case 'tomtom':
      return(get_tomtom_doc_text(doc_type, extra, extra2));
    case 'xstreme':
      return(get_xstreme_doc_text(doc_type, extra, extra2));
    default:
      return("<b>Unknown program type: <font color=red>" + pgm + "</font></b>");
  }
} // get_doc_text

//
// Function to replace the innerHTML of element "id" with the HTML indicated by "doc_type".
// Easier to read and update than the more flexible approach in shared-doc.js. 
//
function print_doc(id, pgm, doc_type, extra) {
  document.getElementById(id).insertAdjacentHTML('beforeend', get_doc_text(pgm, doc_type, extra));
} // print_doc

//
// Function to replace the innerHTML of element "id" with an HTML paragraph
// containing the text for 'pgm' and 'doc_type'.
// This function can be used in help pop-ups.
//
function print_doc_para(id, pgm, doc_type, extra, extra2) {
  html = "<p>" + get_doc_text(pgm, doc_type, extra, extra2) + "</p>"; 
  document.getElementById(id).insertAdjacentHTML('beforeend', html);
} // print_doc_para

//
// Function to return the Shared HTML text of a given type.
// This function can be used directly to document the output format (xx-output-format.html)
// and indirectly via print_doc_para for help pop-ups in the actual output HTML,
// to prevent duplication of documentation.
//
function get_shared_doc_text(doc_type, extra, extra2) {
  if (extra == undefined) {extra = ""};
  if (extra2 == undefined) {extra2 = ""};
  switch (doc_type) {
    case 'motif-db':
      return(`
	The name of ` + extra2 + ` a file of motifs ("motif database file") that contains ` + extra + `
      `);
    case 'motif-id':
      return(`
	The name of the ` + extra + ` motif, which is unique ` + extra2 + ` in the motif database file.
      `);
    case 'motif-alt-id':
      return(`
	An alternate name for the ` + extra + ` motif that may be provided ` + extra2 + ` in the motif database file.
      `);
    case 'motif-width':
      return(`
	The width of the motif. No gaps are allowed in motifs supplied to ` + extra + `
        as it only works for motifs of a fixed width.
      `);
    case 'motif-cons':
      return(`
	A consensus sequence computed from the ` + extra + ` motif (as described <a href="#consensus_doc">below</a>).
      `);
    case 'motif-match-score':
     return(`
	` + extra2 + ` The motif match score of a position in a sequence is
	computed by summing the appropriate entry from each column of the
	position-dependent scoring matrix that represents the motif. ` + extra + `
     `);
    case 'motif-match-p-value':
      return(`
	The <i>p</i>-value of a motif match is the probability of a single random
	subsequence of the length of the motif <a href="javascript:help_refine('pop_motif_match_score')">scoring</a>
	at least as well as the observed match.
      `);
    case 'bh-q-value':
      if (extra2 == "") extra2 = "match";
      return(`
	The q-value is the minimum False Discovery Rate (FDR) required to consider this
        ` + extra2 + ` significant.</br>` +
        get_shared_doc_text('bh-q-value-method', extra, extra2) + `
      `);
    case 'bh-q-value-method':
      return(`
        <br>` + extra + ` estimates q-values from all the ` + extra2 + ` <i>p</i>-values 
	using the method proposed by Benjamini & Hochberg (<i>Journal of the Royal Statistical Society B</i>, 57:289-300, 1995).
	See also Storey JD, Tibshirani R. Statistical significance for
	genome-wide studies, <i>Proc. Natl. Acad. Sci. USA</i> (2003) <b>100</b>:9440&ndash;9445.
      `);
    case 'sdb-name':
      return(`
	The name of the (FASTA) sequence database file.
      `);
    case 'sdb-psp':
      return(`
	The name of the position specific priors (PSP) file.
      `);
    case 'sdb-dist':
      return(`
	The name of the binned distribution of priors file.
      `);
    case 'sdb-count':
      return(`
	The number of sequences in the database.
      `);
    case 'sdb-letters':
      return(`
	The number of letters in the sequence database.
      `);
    case 'lastmod':
      return(`
	The date of the last modification to the ` + extra + ` database.
      `);
    case 'sequence-id':
      return(`
        The identifier of the sequence (from the FASTA sequence header line)` + extra + `
      `);
    case 'sequence-name':
      return(`
	` + extra + `name of the sequence extracted from the sequence identifier (in the FASTA sequence header line).<br>
	When you use the <code>--parse-genomic--coord</code> option, the sequence name ends at the
	first colon ':' (if any) present in the sequence\'s FASTA identifier.  Typically this is the
	chromosome or contig name.  With the <code>--parse-genomic--coord</code> option,
	the start and stop positions are in 0-based coordinates relative to the sequence start given 
	in the FASTA sequence identifier (just after the sequence name).</td> </tr>
      `);
    case 'sequence-desc':
      return(`
        The description appearing after the identifier of the sequence in the FASTA header line.
      `);
    case 'sequence-name':
    case 'alph-name':
      return(`
	The name of the alphabet symbol.
      `);
    case 'alph-bg':
      return(`
	The frequency of the alphabet symbol as defined by the background model.
      `);
    case 'match-start-seq':
      return(`
	The start position of the ` + extra + `; 1-based sequence coordinates.
      `);
    case 'match-stop-seq':
      return(`
	The end position of the ` + extra + `; 1-based sequence coordinates.
      `);
    case 'match-start-genomic':
      return(`
	The start position of the ` + extra + `; genomic coordinates.
      `);
    case 'match-stop-genomic':
      return(`
	The end position of the ` + extra + `; genomic coordinates.
      `);
    case 'parse-genomic-coord':
      return(`
	` + extra + ` was run with the <code>--parse-genomic-coord</code> option
	and has split the sequence identifier into sequence name, sequence start and sequence end 
	in genomic coordinates.
      `);
    case 'motif-consensus':
      return(`
        <p id="consensus_doc">
           A <b>consensus sequence</b> is constructed from each column in a
           motif's frequency matrix using the <b>"50% rule"</b>
           as follows:
        </p>
        <ol>
          <li>The letter frequencies in the column are sorted in decreasing order.</li>
          <li>Letters with frequency less 50% of the maximum are discarded.</li>
          <li>The letter used in this position in the consensus sequence is determined
          by the first rule below that applies:</li>
          <ul>
            <li>If there is only one letter left, or if the remaining letters exactly match
            an ambiguous symbol in the alphabet, the <b>letter</b> or <b>ambiguous symbol</b>,
            respectively, is used.</li>
            <li>Otherwise, if the remaining set contains at least 50% of the core
            symbols in the alphabet, the alphabet's <b>wildcard</b>
            (e.g., "N" for DNA or RNA, and "X" for protein) is used.</li>
            <li>Otherwise, the letter with the <b>maximum frequency</b> is used.</li>
          </ul>
        </ol>
      `);
    default:
      return("Error--Unrecognized shared doc_type: " + doc_type);
  }
} // get_shared_doc_text

    </script>
    <script type="text/javascript">
//
// sea_doc.js
//

//
// Function to return the HTML text of a given type.
// This function can be used directly to document the output format (xx-output-format.html)
// and indirectly via print_doc_para for help pop-ups in the actual output HTML,
// to prevent duplication of documentation.
//
function get_sea_doc_text(doc_type, extra) {
  if (extra == undefined) {extra = ""};
  switch (doc_type) {
    // SEA output fields
    case 'sea-rank':
      return(`
	The rank of the significance (<i>E</i>-value) of the motif in the sorted results.
      `);
    case 'sea-tp':
      return(`
        The number of <b>primary</b> sequences matching the motif / the
        number of primary sequences (the percentage of primary sequences
        matching the motif).
        <br>
        A sequence is said to match the motif if some position
        within it has match score greater than or equal to
        the optimal threshold (Score Threshold).
      `);
    case 'sea-tp%':
      return(`
	The percentage of primary sequences matching the motif with 
	scores greater than or equal to the optimal match score threshold.
      `);
    case 'sea-fp':
      return(`
	The number of <b>control</b> sequences matching the motif / the
        number of control sequences (the percentage of control sequences
        matching the motif).
        <br>
        A sequence is said to match the motif if some position
        within it has match score greater than or equal to
        the optimal threshold (Score Threshold).
      `);
    case 'sea-fp%':
      return(`
	The percentage of control sequences matching the motif with
	scores greater than or equal to the optimal match score threshold.
      `);
    case 'sea-enr_ratio':
      return(`
        The relative enrichment ratio of the motif in the primary vs. control sequences, defined as
        <br>&nbsp;&nbsp;&nbsp;&nbsp;Ratio = ((TP+1)/(NPOS+1)) / ((FP+1)/(NNEG+1)), 
        <br>where NPOS is the number of primary sequences in the input, and NNEG is the
        number of control sequences in the input.
      `);
    case 'sea-score_thr':
      return(`
	The match score threshold giving the optimal <i>p</i>-value.
        This is the score threshold used by SEA to determine the values of "TP" and "FP".
        SEA uses the hold-out sequence set to determine the score threshold unless there
	are too few sequences in the input.
      `);
    case 'sea-pvalue':
      return(`
        The optimal enrichment <i>p</i>-value of the motif according to the statistical test.
        Not adjusted for the number of motifs. 
        <br><br>
	If there are too few sequences in the input to create a hold-out sequence set,
	motifs with the same values of TP and FP can have different <i>p</i>-values.
	This is because a variable correction has been applied to adjust for testing 
	multiple score thresholds.
      `);
    case 'sea-log_pvalue':
      return(`
	The logarithm of PVALUE.
      `);
    case 'sea-evalue':
      return(`
        The expected number of random motifs that would be as enriched in the
        primary sequences as this one.  The <i>E</i>-value is the <i>p</i>-value
        multiplied by the number of motifs in the motif file(s).
      `);
    case 'sea-log_evalue':
      return(`
	The logarithm of EVALUE.
      `);
    case 'sea-qvalue':
      return(
        get_doc_text('shared', 'bh-q-value', 'SEA', 'motif') + `
        <br><br><b>Note: </b>Motif q-values smaller than the smallest positive double precision
        number (about 2.2e-308) have been replaced by the motif <i>E</i>-value.
      `);
    case 'sea-log_qvalue':
      return(`
	The logarithm of QVALUE.
      `);
    case 'sea-tsv-description':
      return(`
        <p>
          SEA outputs a tab-separated values (TSV) file ('sea.tsv') that
          contains one line for each motif found to be significantly enriched,
          sorted in order of decreasing statistical significance.
          The first line in the file contains the (tab-separated) names of the fields.
          Your command line is given at the end of the TSV file in a comment
          line starting with the character '#'.
          The names and meanings of each of the fields are described in the table below.
        </p>
        <table class="dark" style="width:100%" border=1>
          <tr><th>field</th><th>name</th><th>contents</th><tr>
          <tr><td>1</td><td>RANK</td><td> ` + get_doc_text('sea', 'sea-rank') + `</td></tr>
          <tr><td>2</td><td>DB</td><td> ` + get_doc_text('shared', 'motif-db', 'the motif.') + `</td></tr>
          <tr><td>3</td><td>ID</td><td> ` + get_doc_text('shared', 'motif-id') + `</td></tr>
          <tr><td>4</td><td>ALT_ID</td><td> ` + get_doc_text('shared', 'motif-alt-id') + `</td></tr>
          <tr><td>5</td><td>CONSENSUS</td><td> ` + get_doc_text('shared', 'motif-cons') + `</td></tr>
          <tr><td>6</td><td>TP</td><td> ` + get_doc_text('sea', 'sea-tp') + `</td><tr>
          <tr><td>7</td><td>TP%</td><td> ` + get_doc_text('sea', 'sea-tp%') + `</td><tr>
          <tr><td>8</td><td>FP</td><td> ` + get_doc_text('sea', 'sea-fp') + `</td><tr>
          <tr><td>9</td><td>FP%</td><td> ` + get_doc_text('sea', 'sea-fp%') + `</td><tr>
          <tr><td>10</td><td>ENR_RATIO</td><td> ` + get_doc_text('sea', 'sea-enr_ratio') + `</td><tr>
          <tr><td>11</td><td>SCORE_THR</td><td> ` + get_doc_text('sea', 'sea-score_thr') + `</td><tr>
          <tr><td>12</td><td>PVALUE</td><td> ` + get_doc_text('sea', 'sea-pvalue') + `</td></tr>
          <tr><td>13</td><td>LOG_PVALUE</td><td> ` + get_doc_text('sea', 'sea-log_pvalue') + `</td></tr>
          <tr><td>16</td><td>EVALUE</td> <td> ` + get_doc_text('sea', 'sea-evalue') + `</td></tr>
          <tr><td>17</td><td>LOG_EVALUE</td><td> ` + get_doc_text('sea', 'sea-log_evalue') + `</td></tr>
          <tr><td>18</td><td>QVALUE</td> <td> ` + get_doc_text('sea', 'sea-qvalue') + `</td></tr>
          <tr><td>18</td><td>LOG_QVALUE</td> <td> ` + get_doc_text('sea', 'sea-log_qvalue', 'SEA') + `</td></tr>
        </table>
      `);
    case 'sea-sequences-tsv':
      return(`
        <p>SEA outputs a tab-separated values (TSV) file ('sequences.tsv') containing one line for
        each sequence with a site whose score passes the motif's score threshold for each enriched motif 
        reported by SEA.
        The lines are grouped by motif, and groups are separated by a line
        starting with the character "#".
        The first line in the file contains the (tab-separated) names of the fields.
        The names and meanings of each of the fields are described in the table below.
        </p>
        <table class="dark" style="width:100%" border=1>
          <tr> <th>field</th> <th>name</th> <th>contents</th> </tr>
          <tr> <td>1</td> <td>motif_DB</td> <td>` + get_doc_text('shared', 'motif-db', 'the motif.') + `</td> </tr>
          <tr> <td>2</td> <td>motif_ID</td> <td>` + get_doc_text('shared', 'motif-id') + `</td> </tr>
          <tr> <td>3</td> <td>motif_ALT_ID</td> <td>` + get_doc_text('shared', 'motif-alt-id') + `</td> </tr>
          <tr> <td>4</td> <td>seq_ID</td> <td>The ID of the sequence.</td> </tr>
          <tr> <td>5</td> <td>seq_Score</td> <td>` + get_doc_text('shared', 'motif-match-score', '', 'The seq_Score of a sequence is its maximum motif match score over all sequence positions.') + `</td> </tr>
          <tr> <td>6</td> <td>seq_Class</td> <td>Whether the sequence is a true positive, 'tp', or a false positive, 'fp'.</td> </tr>
          <tr> <td>7</td> <td>is_holdout?</td> <td>Whether the sequence was in the holdout set, '1', or not, '0'.</td> </tr>
        </table>
      `);
    default:
      return("Error--Unrecognized sea_doc_type: " + doc_type);
  }
} // get_sea_doc_text

    </script>
    <script type="text/javascript">
//
// discovery_doc.js
// Documentation common to motif discovery tools.
//

//
// Function to return the HTML text of a given type.
// This function can be used directly to document the output format (xx-output-format.html)
// and indirectly via print_doc_para for help pop-ups in the actual output HTML,
// to prevent duplication of documentation.
//
function get_discovery_doc_text(doc_type, extra, extra2) {
  if (extra == undefined) {extra = ""};
  if (extra2 == undefined) {extra2 = ""};

  switch (doc_type) {
    case 'motif_logo':
      return(`
	The sequence logo of the motif.
	  The rules for construction logos are given in
	  the <i>Description</i> section of the documentation for the MEME Suite utility
          <a href="` + extra + `/doc/ceqlogo.html#description">ceqlogo</a>.
      `);
    case 'motif_rc_logo':
      return(`
	The sequence logo of the reverse complement motif.
	  The rules for construction logos are given in
	  the <i>Description</i> section of the documentation for the MEME Suite utility
          <a href="` + extra + `/doc/ceqlogo.html#description">ceqlogo</a>.
      `);
    case 'more':
      return(`
	Click on the blue symbol below to reveal detailed information about the motif.
      `);
    case 'submit_dl':
      return(`
	Click on the blue symbol below to reveal options allowing you
	  to submit this motif to another MEME Suite motif analysis program, to download this
	  motif in various text formats, or to download a sequence "logo" of
	  this motif PNG or EPS format.</p>
	  <h5>Supported Programs</h5>
	  <dl>
	    <dt>Tomtom</dt>
	    <dd>Tomtom is a tool for searching for similar known motifs.
	      [<a href="` + extra + `/doc/tomtom.html?man_type=web">manual</a>]</dd>
	    <dt>MAST</dt>
	    <dd>MAST is a tool for searching biological sequence databases for
	      sequences that contain one or more of a group of known motifs.
	      [<a href="` + extra + `/doc/mast.html?man_type=web">manual</a>]</dd>
	    <dt>FIMO</dt>
	    <dd>FIMO is a tool for searching biological sequence databases for
	      sequences that contain one or more known motifs.
	      [<a href="` + extra + `/doc/fimo.html?man_type=web">manual</a>]</dd>
	    <dt>GOMo</dt>
	    <dd>GOMo is a tool for identifying possible roles (Gene Ontology
	      terms) for DNA binding motifs.
	      [<a href="` + extra + `/doc/gomo.html?man_type=web">manual</a>]</dd>
	    <dt>SpaMo</dt>
	    <dd>SpaMo is a tool for inferring possible transcription factor
	      complexes by finding motifs with enriched spacings.
	      [<a href="` + extra + `/doc/spamo.html?man_type=web">manual</a>]</dd>
	  </dl>
      `);
    case 'site_distr':
      return(`
        This plot shows the positional distribution of the best match to the motif in the ` +
        extra + ` sequences. 
        Only matches with scores at least the ` +
        extra2 + ` score threshold are considered.
        The plot is smoothed with a triangular function whose width is 5% of the maximum ` +
	extra + ` sequence length.
        The position of the dotted vertical line indicates whether the sequences were
	aligned on their left ends, centers, or right ends, respectively.  
      `);
    case 'site_hist':
      return(`
        This histogram shows the distribution of the <b>number</b> of matches to the motif in the ` +
        extra + ` sequences with at least one match.
        Only matches with scores at least the ` +
        extra2 + ` score threshold are considered.
      `);
    default:
      return("Error--Unrecognized discovery doc_type: " + doc_type);
  }
} // get_discovery_doc_text

    </script>
    <script type="text/javascript">
      // 
      // return true if any part of the passed element is visible in the viewport
      //
      function element_in_viewport(elem) {
        var rect;
        try {
          rect = elem.getBoundingClientRect();
        } catch (e) {
          return false;
        }
        return (
            rect.top < (window.innerHeight || document.body.clientHeight) &&
            rect.bottom > 0 &&
            rect.left < (window.innerWidth || document.body.clientWidth) &&
            rect.right > 0
            );
      }

      //
      // Functions to delay a drawing task until it is required or it would not lag the display to do so
      //

      // a list of items still to be drawn
      var drawable_list = [];
      // the delay between drawing objects that are not currently visible
      var draw_delay = 1;
      // the delay after a user interaction
      var user_delay = 300;
      // the delay after a user has stopped scrolling and is viewing the stuff drawn on the current page
      var stop_delay = 300;
      // the timer handle; allows resetting of the timer after user interactions
      var draw_timer = null;

      //
      // Drawable
      //
      // elem - a page element which defines the position on the page that drawing is to be done
      // task - an object with the method run which takes care of painting the object
      //
      var Drawable = function(elem, task) {
        this.elem = elem;
        this.task = task;
      }

      //
      // Drawable.is_visible
      //
      // Determines if the element is visible in the viewport
      //
      Drawable.prototype.is_visible = function() {
        return element_in_viewport(this.elem);
      }

      //
      // Drawable.run
      //
      // Run the task held by the drawable
      Drawable.prototype.run = function() {
        if (this.task) this.task.run();
        this.task = null;
      }

      //
      // Drawable.run
      //
      // Run the task iff visible
      // returns true if the task ran or has already run
      Drawable.prototype.run_visible = function() {
        if (this.task) {
          if (element_in_viewport(this.elem)) {
            this.task.run();
            this.task = null;
            return true;
          }
          return false;
        } else {
          return true;
        }
      }

      //
      // draw_on_screen
      //
      // Checks each drawable object and draws those on screen.
      //
      function draw_on_screen() {
        var found = false;
        for (var i = 0; i < drawable_list.length; i++) {
          if (drawable_list[i].run_visible()) {
            drawable_list.splice(i--, 1);
            found = true;
          }
        }
        return found;
      }

      //
      // process_draw_tasks
      //
      // Called on a delay to process the next available
      // draw task.
      //
      function process_draw_tasks() {
        var delay = draw_delay;
        draw_timer = null;
        if (drawable_list.length == 0) return; //no more tasks
        if (draw_on_screen()) {
          delay = stop_delay; //give the user a chance to scroll
        } else {
          //get next task
          var drawable = drawable_list.shift();
          drawable.task.run();
        }
        //allow UI updates between tasks
        draw_timer = window.setTimeout("process_draw_tasks()", delay);
      }

      //
      // delayed_process_draw_tasks
      //
      // Call process_draw_tasks after a short delay.
      // The delay serves to group multiple redundant events.       
      // Should be set as event handler for onscroll and onresize.
      //
      function delayed_process_draw_tasks() {
        //reset the timer
        if (drawable_list.length > 0) { 
          if (draw_timer != null) clearTimeout(draw_timer);
          draw_timer = window.setTimeout("process_draw_tasks()", user_delay);
        }
      }

      //
      // add_draw_task
      //
      // Add a drawing task to be called immediately if it is
      // visible, or to be called on a delay to reduce stuttering
      // effect on the web browser.
      function add_draw_task(elem, task) {
        drawable = new Drawable(elem, task);
        if (drawable.is_visible()) {
          task.run();
        } else {
          drawable_list.push(drawable);
          //reset timer
          if (draw_timer != null) clearTimeout(draw_timer);
          draw_timer = window.setTimeout("process_draw_tasks()", user_delay);
        }
      }


    </script>
    <script type="text/javascript">
var LEGEND_LINE = 16;
var LEGEND_FONT = "Helvetica";
var LEGEND_PAD = 5;

var Dasher = function(ctx, start_x, start_y, pattern) {
  if (typeof pattern === "undefined") pattern = [];
  this.ctx = ctx;
  this.x = start_x;
  this.y = start_y;
  this.pattern = pattern;
  this.index = 0;     // where in the pattern are we up to?
  this.fragment = 0;  // how much of the current pattern have we drawn
  this.on = true;     // pen on paper?
  ctx.moveTo(start_x, start_y);
};

Dasher.prototype.dashTo = function(x, y) {
  var dx = x - this.x;
  var dy = y - this.y;
  var d = Math.pow(dx * dx + dy * dy, 0.5);
  if (this.pattern.length == 0) {
    // when no pattern is specified this just draws lines
    this.ctx.lineTo(x, y);
  } else {
    // calculate distance to complete dash
    var dc = this.pattern[this.index] - this.fragment;
    while (dc <= d) {
      // calculate the fraction of the line needed
      var f = dc / d;
      this.x += dx * f;
      this.y += dy * f;
      if (this.on) {
        this.ctx.lineTo(this.x, this.y);
      } else {
        this.ctx.moveTo(this.x, this.y);
      }
      // move to the next dash
      this.fragment = 0;
      // skip empty dashes, just toggling on state
      do {
        this.index = (this.index + 1) % this.pattern.length;
        this.on = !this.on;
      } while (this.pattern[this.index] <= 0);
      // update variables
      dc = this.pattern[this.index];
      dx = x - this.x;
      dy = y - this.y;
      d = Math.pow(dx * dx + dy * dy, 0.5);
    }
    this.fragment += d;
    this.x = x;
    this.y = y;
    if (this.on) {
      this.ctx.lineTo(this.x, this.y);
    } else {
      this.ctx.moveTo(this.x, this.y);
    }
  }
}

var CentrimoResult = function(name, sig, colour, motif_length, 
    total_sites, site_counts, neg_total_sites, neg_site_counts) {
  "use strict";
  if (typeof name === "undefined") {
    name = "";
  }
  if (typeof sig === "undefined") {
    sig = "";
  }
  if (typeof colour == "undefined") {
    colour = "#000000";
  }
  this.name = name;
  this.sig = sig;
  this.colour = colour;
  this.motif_length = motif_length;
  this.total_sites = total_sites;
  this.site_counts = site_counts;
  this.has_neg = (typeof neg_total_sites === "number" && 
      typeof neg_site_counts === "object" && neg_site_counts instanceof Array);
  this.neg_total_sites = neg_total_sites;
  this.neg_site_counts = neg_site_counts;
};

CentrimoResult.prototype.get_site_count = function (index, mirror, neg) {
  count = neg ? this.neg_site_counts[index] : this.site_counts[index];
  if (mirror) {
    i_mirror = this.site_counts.length - 1 - index;
    return (count + (neg ? this.neg_site_counts[i_mirror] : this.site_counts[i_mirror]));
  } else {
    return count;
  }
};

/*
 * CentrimoRSet
 * Construct a centrimo result set.
 */
var CentrimoRSet = function(sequence_length) {
  "use strict";
  this.sequence_length = sequence_length;
  this.results = [];
};

/*
 * seq_len
 * Get the sequence length of the result set.
 */
CentrimoRSet.prototype.seq_len = function() {
  "use strict";
  return this.sequence_length;
};

/*
 * add
 * Add a centrimo result to the set
 */
CentrimoRSet.prototype.add = function(name, sig, colour, motif_length, 
    total_sites, site_counts, neg_total_sites, neg_site_counts) {
  "use strict";
  this.results.push(new CentrimoResult(name, sig, colour, motif_length, 
    total_sites, site_counts, neg_total_sites, neg_site_counts));
};

/*
 * count
 * Return the count of centrimo results.
 */
CentrimoRSet.prototype.count = function() {
  "use strict";
  return this.results.length;
};

/*
 *  get
 *  Get an entry in the result set.
 */
CentrimoRSet.prototype.get = function(index) {
  "use strict";
  return this.results[index];
};

/*
 * CentrimoLine
 */
var CentrimoLine = function(name, sig, colour, dash, thickness, show_on_legend, xlist, ylist) {
  "use strict";
  if (xlist.length != ylist.length) {
    throw new Error("The list of x and y points must be the same length.");
  }
  this.xlist = xlist;
  this.ylist = ylist;
  this.name = name;
  this.sig = sig;
  this.colour = colour;
  this.dash = dash;
  this.thickness = thickness;
  this.show_on_legend = show_on_legend;
  this.max_prob = -1;
};

/*
 * trim
 *
 * Removes points from the ends so the lines are the same length.
 */
CentrimoLine.prototype.trim = function(left, right) {
  "use strict";
  var lefti, righti, gradient, gap, left_y, right_y;
  if (this.xlist.length == 0) return;
  if (typeof left !== "number"|| isNaN(left)) {
    throw new Error("left trim is not a number");
  }
  if (typeof right !== "number" || isNaN(right)) {
    throw new Error("right trim is not a number");
  }
  for (lefti = 0; lefti < this.xlist.length; lefti++) {
    if (this.xlist[lefti] >= left) {
      break;
    }
  }
  if (lefti === 0 && this.xlist[0] !== left) {
    throw new Error("Attempt to undertrim line on the left.");
  }
  for (righti = this.xlist.length - 1; righti >= 0; righti--) {
    if (this.xlist[righti] <= right) {
      break;
    }
  }
  if (righti === (this.xlist.length - 1) && this.xlist[righti] !== right) {
    throw new Error("Attempt to undertrim line on the right.");
  }
  if (lefti == this.xlist.length || righti == -1) {
    // all points outside of drawable region
    this.xlist = [];
    this.ylist = [];
    return;
  }
  if (this.xlist[lefti] != left) {
    // create a new point that is exactly at left by interpolating
    gradient = (this.ylist[lefti] - this.ylist[lefti-1]) / 
      (this.xlist[lefti] - this.xlist[lefti-1]);
    gap = left - this.xlist[lefti-1];
    left_y = this.ylist[lefti-1] + gradient * gap;
    this.xlist.splice(0, lefti, left);
    this.ylist.splice(0, lefti, left_y);
    righti = righti - lefti + 1;
  } else {
    this.xlist.splice(0, lefti);
    this.ylist.splice(0, lefti);
    righti -= lefti;
  }
  if (this.xlist[righti] != right) {
    // create a new point that is exactly at right by interpolating
    gradient = (this.ylist[righti + 1] - this.ylist[righti]) /
      (this.xlist[righti + 1] - this.xlist[righti]);
    gap = right - this.xlist[righti];
    right_y = this.ylist[righti] + gradient * gap;
    // truncate the lists
    this.xlist.length = righti + 1;
    this.ylist.length = righti + 1;
    // push the new item on the end of the lists
    this.xlist.push(right);
    this.ylist.push(right_y);
  } else {
    // truncate the lists
    this.xlist.length = righti + 1;
    this.ylist.length = righti + 1;
  }
  this.max_prob = -1;
};

CentrimoLine.prototype.max = function() {
  "use strict";
  var y_max, i;
  if (this.max_prob != -1) {
    return this.max_prob;
  }
  y_max = 0;
  for (i = 0; i < this.xlist.length; i++) {
    if (this.ylist[i] > y_max) {
      y_max = this.ylist[i];
    }
  }
  this.max_prop = y_max;
  return this.max_prop;
};

/*
 * CentrimoScale
 *
 * Calculates the increments on the y axis
 */
var CentrimoScale = function(max_prob) {
  "use strict";
  var decimals, inc, rounder, max, inc_plus;
  if (max_prob === 0) {
    this.max = 0.01;
    this.inc = 0.002;
    this.digits = 3;
    return;
  }
  // find the minimum number of decimals needed to display the largest
  // digit of the maximum probability
  decimals = Math.ceil(-(Math.log(max_prob) / Math.log(10)));
  // calculate an increment which is (at minimum) 10 times smaller the the max
  inc = Math.pow(10, -(decimals+1));
  // round-up the maximum probabilty to its largest digit
  rounder = Math.pow(10, decimals);
  max = Math.ceil(max_prob * rounder) / rounder;
  // adjust the increment so it's between 5 and 12 times the maximum
  // probability
  if (inc * 5 < max && inc * 12 > max) {
    inc *= 1;
  } else if (inc * 10 < max && inc * 24 > max) {
    inc *= 2;
  } else if (inc * 25 < max && inc * 60 > max) {
    inc *= 5;
  } else if (inc * 50 < max && inc * 120 > max) {
    inc *= 10;
  }
  max += inc;
  inc_plus = (1.125 * inc);
  while (max - inc_plus > max_prob) {
    max -= inc;
  }
  max = Math.min(max, 1.0);
  this.max = max;
  this.inc = inc;
  this.digits = decimals+1;
};

var CentrimoLegendMetrics = function(lw, lh, id_w, pv_w, sq_w) {
  "use strict";
  this.width = lw;
  this.height = lh;
  this.id_width = id_w;
  this.pv_width = pv_w;
  this.sq_width = sq_w;
};

var CentrimoGraphMetrics = function(legend_metrics, top_edge, bottom_edge,
    left_mark, left_val, right_mark, right_val) {
  if (typeof legend_metrics !== "object" || legend_metrics === null) {
    this.legend_width = 10;
    this.legend_height = 10;
  } else {
    this.legend_width = legend_metrics.width;
    this.legend_height = legend_metrics.height;
  }
  this.top_edge = top_edge;
  this.bottom_edge = bottom_edge;
  this.left_mark = left_mark;
  this.left_val = left_val;
  this.right_mark = right_mark;
  this.right_val = right_val;
};

/*
 * CentrimoGraph
 * Takes a results set and a window weight array and produces a graph. 
 * The weights in the window_weights should be non-negative and sum to 1.
 */
var CentrimoGraph = function(rset, window_weights, fine_text, start, end, mirror, align, motif_width) {
  "use strict";
  var trim_left, trim_right, i, j, k, result, x, y, xpos, ypos, positions;
  var y_neg, ypos_neg, line_thickness;

  // Set the position of the vertical line.
  this.align = align ? align : "center";

  // set the width of motif
  this.motif_width = motif_width ? motif_width : 0;

  // set the length of the sequences.
  this.seq_len = rset.seq_len();

  // Set the size of the smooting window.
  this.window_width = window_weights.length;

  line_thickness = (window_weights.length < 10 ? 1 : 3);
  if (typeof fine_text !== "string") {
    fine_text = "";
  }
  if (typeof mirror !== "boolean") mirror = false;
  this.mirror = mirror;
  if (mirror) {
    if (typeof start === "number") {
      start = Math.max(0, start);
    } else {
      start = 0;
    }
  }
  this.fine_text = fine_text;
  this.lines = [];
  for (i = 0; i < rset.count(); i++) {
    result = rset.get(i);
    x = [];
    y = [];
    if (result.has_neg) {
      y_neg = [];
    }
    xpos = (result.motif_length - rset.seq_len() + (window_weights.length - 1)) / 2;
    if (typeof trim_left === "undefined") {
      trim_left = xpos;
    } else if (trim_left < xpos) {
      trim_left = xpos;
    }
    positions = result.site_counts.length - window_weights.length + 1;
    for (j = 0; j < positions; j++, xpos += 1) {
      ypos = 0;
      // avoid division by zero when no sites are found
      if (result.total_sites > 0) {
        for (k = 0; k < window_weights.length; k++) {
          ypos += window_weights[k] * result.get_site_count(j + k, mirror, 0);
        }
        ypos /= result.total_sites;
      }
      x.push(xpos);
      y.push(ypos);
      // handle the negative dataset
      if (result.has_neg) {
        ypos_neg = 0;
        if (result.neg_total_sites > 0) {
          for (k = 0; k < window_weights.length; k++) {
            ypos_neg += window_weights[k] * result.get_site_count(j + k, mirror, 1);
          }
          ypos_neg /= result.neg_total_sites;
        }
        y_neg.push(ypos_neg);
      }
    }
    // subtract 1 from xpos because for loop will increment it one more than needed.
    xpos -= 1;
    this.lines.push(new CentrimoLine(result.name, result.sig, result.colour, [], line_thickness, true, x, y));
    if (result.has_neg) {
      this.lines.push(new CentrimoLine(result.name, result.sig, result.colour, [6,4], 2, false, x.slice(0), y_neg));
    }
    if (positions > 0) {
      if (typeof trim_right === "undefined") {
        trim_right = xpos;
      } else if (trim_right > xpos) {
        trim_right = xpos;
      }
    }
  }
  if (typeof start !== "undefined" && start != null) {
    if (start > trim_left) {
      trim_left = start;
    }
    this.start = start;
  } else {
    this.start = -Math.ceil(rset.seq_len() / 2);
  }
  if (typeof end !== "undefined" && end != null) {
    if (end < trim_right) {
      trim_right = end;
    }
    this.end = end;
  } else {
    this.end = Math.floor(rset.seq_len() / 2);
  }
  this.max_prob = 0;
  for (i = 0; i < this.lines.length; i++) {
    this.lines[i].trim(trim_left, trim_right);
    this.max_prob = Math.max(this.max_prob, this.lines[i].max());
  }
  this.scale = new CentrimoScale(this.max_prob);
};

/*
 * draw_graph
 *
 * Draws a motif probability graph
 */
CentrimoGraph.prototype.draw_graph = function (ctx, w, h, draw_legend, legend_x, legend_y) {
  "use strict";
  var gap, l_margin, t_margin, b_margin, r_margin, legend_metrics, 
      legend_width, legend_height;
  gap = 10;
  l_margin = gap + 30 + 10 * (2 + this.scale.digits);
  t_margin = 20;
  b_margin = 60;
  r_margin = 30;
  legend_metrics = this.measure_legend(ctx);
  // setting global
  legend_width = legend_metrics.width;
  legend_height = legend_metrics.height;
  // constrain legend to within graph area
  legend_x = Math.round(legend_x);
  legend_y = Math.round(legend_y);
  if (legend_x < (l_margin + gap)) {
    legend_x = l_margin + gap;
  } else if ((legend_x + legend_metrics.width) > (w - r_margin - gap)) {
    legend_x = w - r_margin - legend_metrics.width - gap;
  }
  if (legend_y < (t_margin + gap)) {
    legend_y = t_margin + gap;
  } else if ((legend_y + legend_metrics.height) > (h - b_margin - gap)) {
    legend_y = h - b_margin - legend_metrics.height - gap;
  }

  // draw graph
  ctx.save();
  // draw border
  ctx.beginPath();
  ctx.moveTo(l_margin - 0.5, t_margin +0.5);
  ctx.lineTo(l_margin - 0.5, h - (b_margin - 0.5));
  ctx.lineTo(w - r_margin - 0.5, h - (b_margin - 0.5));
  ctx.lineTo(w - r_margin - 0.5, t_margin +0.5);
  ctx.closePath();
  ctx.stroke();
  // draw fineprint
  ctx.save();
  ctx.font = "9px Helvetica";
  ctx.textAlign = "right";
  ctx.textBaseline = "bottom";
  ctx.fillText(this.fine_text, w - 1, h - 2);
  ctx.restore();
  // draw y axis
  ctx.save();
  ctx.translate(l_margin, t_margin);
  this.draw_y_axis(ctx, 0, h - (t_margin + b_margin));
  ctx.restore();
  // draw y labels
  ctx.save();
  ctx.translate(gap, t_margin);
  this.draw_y_axis_label(ctx, l_margin, h - (t_margin + b_margin));
  ctx.restore();
  // draw x axis
  ctx.save();
  ctx.translate(l_margin, h - b_margin);
  this.draw_x_axis(ctx, w - (l_margin + r_margin), b_margin);
  ctx.restore();
  // draw top axis
  ctx.save();
  ctx.translate(l_margin, t_margin);
  this.draw_top_axis(ctx, w - (l_margin + r_margin), 0);
  ctx.restore();
  // draw x axis labels
  ctx.save();
  ctx.translate(l_margin, h - b_margin);
  this.draw_x_axis_label(ctx, w - (l_margin + r_margin), b_margin - gap);
  ctx.restore();
  // draw lines
  ctx.save();
  ctx.translate(l_margin, t_margin);
  this.draw_lines(ctx, w - (l_margin + r_margin), h - (t_margin + b_margin), 8);
  ctx.restore();
  // draw legend
  if (draw_legend) { 
    ctx.save();
    ctx.translate(legend_x, legend_y);
    this.draw_legend(ctx, legend_metrics);
    ctx.restore();
  }
  ctx.restore();
  return new CentrimoGraphMetrics(legend_metrics, t_margin, h - b_margin,
      l_margin, this.start, w - r_margin, this.end);
};

/*
 * draw_x_axis
 *
 */
CentrimoGraph.prototype.draw_x_axis = function(ctx, w, h) {
  "use strict";
  var scale_x, length, tic_inc, tic_min, tic_max, i, x;
  // pixels per unit
  scale_x = w / (this.end - this.start);
  // calculate a good tic increment
  length = this.end - this.start;
  if (length > 50) {
    // multiple of 10
    tic_inc = Math.max(1, Math.round(length / 100)) * 10;
  } else if (length > 25) {
    tic_inc = 5;
  } else if (length > 10) {
    tic_inc = 2;
  } else {
    tic_inc = 1;
  }
  // work out the min and max values within the start and end
  tic_min = Math.round(this.start / tic_inc) * tic_inc;
  if (tic_min < this.start) {
    tic_min += tic_inc;
  }
  tic_max = Math.round(this.end / tic_inc) * tic_inc;
  if (tic_max > this.end) {
    tic_max -= tic_inc;
  }
  // draw the tics
  ctx.save();
  ctx.font = "19px Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  for (i = tic_min; i <= tic_max; i+= tic_inc) {
    x = Math.round((i - this.start) * scale_x) + 0.5;
    ctx.fillText(""+i, x, 5);
    if (i == this.start || i == this.end) continue;
    ctx.beginPath();
    ctx.moveTo(x, -5);
    ctx.lineTo(x, 3);
    ctx.stroke();
  }
  
  ctx.restore();
};

/*
 * draw_top_axis
 *
 */
CentrimoGraph.prototype.draw_top_axis = function(ctx, w, h) {
  "use strict";
  var scale_x, length, tic_inc, tic_min, tic_max, i, x;
  // pixels per unit
  scale_x = w / (this.end - this.start);
  // calculate a good tic increment
  length = this.end - this.start;
  if (length > 50) {
    // multiple of 10
    tic_inc = Math.max(1, Math.round(length / 100)) * 10;
  } else if (length > 25) {
    tic_inc = 5;
  } else {
    tic_inc = 1;
  }
  // work out the min and max values within the start and end
  tic_min = Math.round(this.start / tic_inc) * tic_inc;
  if (tic_min < this.start) {
    tic_min += tic_inc;
  }
  tic_max = Math.round(this.end / tic_inc) * tic_inc;
  if (tic_max > this.end) {
    tic_max -= tic_inc;
  }
  // draw the tics
  ctx.save();
  ctx.font = "19px Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  for (i = tic_min; i <= tic_max; i+= tic_inc) {
    if (i == this.start || i == this.end) continue;
    x = Math.round((i - this.start) * scale_x) + 0.5;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, 8);
    ctx.stroke();
  }
  ctx.restore();
};

/*
 * draw_x_axis_label
 */
CentrimoGraph.prototype.draw_x_axis_label = function(ctx, w, h) {
  "use strict";
  ctx.save();
  ctx.font = "19px Helvetica";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText((this.mirror ? 
        "Distance of Best Site from Sequence Center" : 
        "Position of Best Site in Sequence"), w/2, h);
  ctx.restore();
};

/*
 * draw_y_axis
 *
 * TODO some work needs to be done to allow moving the zero
 */
CentrimoGraph.prototype.draw_y_axis = function(ctx, w, h) {
  "use strict";
  var y_scale, p, y;
  ctx.save();
  ctx.font = "19px Helvetica";
  ctx.textBaseline = "middle";
  ctx.textAlign = "right";

  y_scale = h / this.scale.max;
  for (p = 0; p < this.scale.max; p += this.scale.inc) {
    y = Math.round(h - p * y_scale) + 0.5;
    this.draw_y_tic(ctx, this.scale.digits, y, p);
  }
  this.draw_y_tic(ctx, this.scale.digits, 0.5, this.scale.max);

  ctx.restore();
};

/*
 * draw_y_tic
 */
CentrimoGraph.prototype.draw_y_tic = function(ctx, digits, y, p) {
  "use strict";
  ctx.beginPath();
  ctx.moveTo(5, y);
  ctx.lineTo(-3, y);
  ctx.stroke();
  ctx.fillText(p.toFixed(digits), -5, y);
};

/*
 * draw_y_axis_label
 */
CentrimoGraph.prototype.draw_y_axis_label = function(ctx, w, h) {
  "use strict";
  ctx.save();
  ctx.translate(0, h/2);
  ctx.rotate(-Math.PI / 2);
  ctx.font = "19px Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  ctx.fillText("Probability", 0, 0);
  ctx.restore();
};

/*
 * draw_lines
 */
CentrimoGraph.prototype.draw_lines = function(ctx, w, h, tic_size) {
  "use strict";
  var scale_y, scale_x, i, line, x_points, y_points, j, x, y, dasher;
  if (typeof tic_size === "undefined") {
    tic_size = 0;
  }
  scale_y = h / this.scale.max;
  scale_x = w / (this.end - this.start);

  // draw the horizontal line and write range 
  if (this.motif_width) {
    ctx.save();
    ctx.strokeStyle = '#DDD';
    var txt_height, t1, t2, w1, w2, xlate, xlate1, xlate2;
    ctx.font = "13px san-serif";
    txt_height = parseInt(ctx.font);
    if (this.align == "left") {
      t1 = 0;
      t2 = this.seq_len;
    } else if (this.align == "center") {
      t2 = this.seq_len/2;
      t1 = -t2;
    } else {
      t1 = -this.seq_len;
      t2 = 0;
    }
    xlate = (this.motif_width/2.0 + this.window_width/2.0) * scale_x;
    w1 = ctx.measureText(t1).width;
    xlate1 = xlate > w1 ? xlate : w1;
    w2 = ctx.measureText(t2).width;
    xlate2 = xlate > w2 ? xlate : w2;
    ctx.textAlign = "left";
    ctx.fillText(t1, 0, h);
    ctx.textAlign = "right";
    ctx.fillText(t1, 0, h);
    ctx.fillText(t2, w, h);
    ctx.beginPath();
    ctx.moveTo(0, h-txt_height);
    ctx.lineTo(w, h-txt_height);
    ctx.stroke();
    ctx.restore();
    // Adjust h to allow for X axis labels.
    h -= txt_height;
    scale_y = h / this.scale.max;
  }
  // draw the vertical line
  if (0 > this.start && 0 < this.end) {
    ctx.save();
    if (this.align == "left") {
      //ctx.translate((this.motif_width/2.0 + this.window_width/2.0) * scale_x, 0);
      ctx.translate(0, 0);
    } else if (this.align == "center") {
      ctx.translate((-this.start) * scale_x, 0);
    } else if (this.align == "right") {
      //ctx.translate(w - (this.motif_width/2.0 + this.window_width/2.0) * scale_x - 1, 0);
      ctx.translate(w - 1, 0);
    }
    ctx.strokeStyle = '#DDD';
    ctx.beginPath();
    ctx.moveTo(0.5, tic_size);
    ctx.lineTo(0.5, h - tic_size);
    ctx.stroke();
    ctx.restore();
  }
  // draw the lines
  ctx.save();
  ctx.lineJoin = "bevel";
  ctx.miterLimit = 0;
  for (i = 0; i < this.lines.length; i++) {
    line = this.lines[i];
    ctx.lineWidth = line.thickness;
    x_points = line.xlist;
    y_points = line.ylist;
    if (x_points.length > 1) {
      ctx.strokeStyle = line.colour;
      ctx.beginPath();
      for (j = 0; j < x_points.length; j++) {
        if (isNaN(x_points[j])) {
          throw new Error("X NaN!");
        }
        if (isNaN(y_points[j])) {
          throw new Error("Y NaN!");
        }
        x = (x_points[j] - this.start) * scale_x;
        y = h - y_points[j] * scale_y;
        if (j === 0) {
          dasher = new Dasher(ctx, x, y, line.dash);
        } else {
          dasher.dashTo(x, y);
        }
      }
      ctx.stroke();
    } else if (x_points.length == 1) {
      if (isNaN(x_points[0])) {
        throw new Error("X NaN!");
      }
      if (isNaN(y_points[0])) {
        throw new Error("Y NaN!");
      }
      x = (x_points[0] - this.start) * scale_x;
      y = h - y_points[0] * scale_y;
      ctx.fillStyle = line.colour;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, 2*Math.PI, false);
      ctx.fill();
    }
  }
  ctx.restore();
};

/*
 * measure_legend
 */
CentrimoGraph.prototype.measure_legend = function(ctx) {
  "use strict";
  var lw, lh, sq_w, id_w, pv_w, lines, i, line, len;
  // initilise the line height to the size of the padding
  lh = 2 * LEGEND_PAD;
  // calculate the column widths
  sq_w = LEGEND_LINE - 2;
  id_w = 0;
  pv_w = 0;
  ctx.save();
  ctx.font = "" + LEGEND_LINE + "px " + LEGEND_FONT; 
  for (i = 0; i < this.lines.length; i++) {
    line = this.lines[i];
    if (!line.show_on_legend) {
      continue;
    }
    lh += LEGEND_LINE * 1.2;
    len = ctx.measureText(line.name).width;
    if (id_w < len) {
      id_w = len;
    }
    len = ctx.measureText(line.sig).width;
    if (pv_w < len) {
      pv_w = len;
    }
  }
  lh = Math.round(lh);
  ctx.restore();
  // legend width is a function of the column widths
  lw = id_w + pv_w + sq_w + 4 * LEGEND_PAD;

  return new CentrimoLegendMetrics(lw, lh, id_w, pv_w, sq_w);
};

/*
 * draw_legend
 */
CentrimoGraph.prototype.draw_legend = function(ctx, metrics) {
  "use strict";
  var ln_h, pad, w, h, id_w, pv_w, sq_w, id_x, pv_x, sq_x, i, line;
  if (this.lines.length === 0) {
    return;
  }
  ln_h = LEGEND_LINE;
  pad = LEGEND_PAD;
  w = metrics.width;
  h = metrics.height;
  id_w = metrics.id_width;
  pv_w = metrics.pv_width;
  sq_w = metrics.sq_width;
  id_x = 0;
  pv_x = id_x + id_w + pad;
  sq_x = pv_x + pv_w + pad;

  ctx.save();
  ctx.font = "" + ln_h + "px " + LEGEND_FONT;
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
  // draw it
  ctx.save();
  ctx.fillStyle = 'white';
  ctx.fillRect(0.5, 0.5, w-1, h-1);
  ctx.strokeStyle = 'black';
  ctx.strokeRect(0.5, 0.5, w-1, h-1);
  ctx.restore();
  ctx.translate(pad, pad);
  ctx.fillStyle = "black";
  for (i = 0; i < this.lines.length; i++) {
    line = this.lines[i];
    if (!line.show_on_legend) {
      continue;
    }
    ctx.translate(0, ln_h);
    ctx.save();
    ctx.fillStyle = line.colour;
    ctx.fillRect(sq_x, -sq_w + 0.1 * ln_h, sq_w, sq_w);
    ctx.restore();
    ctx.fillText(line.name, id_x, 0);
    ctx.fillText(line.sig, pv_x, 0);
    ctx.translate(0, 0.2 * ln_h);
  }
  ctx.restore();
};

/*
 * triangular_weights
 * Returns an array of length n containing normalized weights.
 *
 */
function triangular_weights(n) {
  "use strict";
  var weights, half, half_i, sum, i, unscaled_weight;
  weights = [];
  half = n/2;
  half_i = Math.floor(half);
  sum = 0;
  for (i = 0; i < half_i; i++) {
    unscaled_weight = (i + 0.5) / half;
    weights[i] = unscaled_weight;
    weights[n - i -1] = unscaled_weight;
    sum += 2 * unscaled_weight;
  }
  if (n % 2 == 1) {
    weights[half_i] = 1;
    sum += 1;
  }
  // normalize
  for (i = 0; i < n; i++) {
    weights[i] /= sum;
  }
  return weights;
}

/*
 * uniform_weights
 * Returns an array of length n containing normalized weights.
 *
 */
function uniform_weights(n) {
  "use strict";
  var weights, weight, i;
  weights = [];
  weight = 1.0 / n;
  for (i = 0; i < n; i++) {
    weights[i] = weight;
  }
  return weights;
}

    </script>
    <script type="text/javascript">
var SiteHistogramGraphMetrics = function(top_edge, bottom_edge,
    left_mark, left_val, right_mark, right_val) {
  this.top_edge = top_edge;
  this.bottom_edge = bottom_edge;
  this.left_mark = left_mark;
  this.left_val = left_val;
  this.right_mark = right_mark;
  this.right_val = right_val;
};

/*
 * SiteHistogramGraph
 */
var SiteHistogramGraph = function(counts) {
  "use strict";
  this.counts = [];
  this.start = 0;
  this.end = counts.length;
  this.ymax = 100;
  this.yinc = 20;
  this.ydigits = 0

  // Normalize the counts.
  var i, total=0;
  for (i=0; i<counts.length; i++) total += counts[i];
  for (i=0; i<counts.length; i++) this.counts[i] =  counts[i] *= 100/total;
} // SiteHistogramGraph

/*
 * draw_graph
 *
 * Draws a site count histogram.
 */
SiteHistogramGraph.prototype.draw_graph = function (ctx, w, h, x_label, y_label, color) {
  "use strict";
  var gap = 10;
  var l_margin = gap + 15 + 10 * (2 + this.ydigits);
  var t_margin = 10;
  var b_margin = 40;
  var r_margin = 30;

  // draw graph
  ctx.save();
  // draw border
  ctx.beginPath();
  ctx.moveTo(l_margin - 0.5, t_margin +0.5);
  ctx.lineTo(l_margin - 0.5, h - (b_margin - 0.5));
  ctx.lineTo(w - r_margin - 0.5, h - (b_margin - 0.5));
  ctx.lineTo(w - r_margin - 0.5, t_margin +0.5);
  ctx.closePath();
  ctx.stroke();
  // draw y axis
  ctx.save();
  ctx.translate(l_margin, t_margin);
  this.draw_y_axis(ctx, 0, h - (t_margin + b_margin));
  ctx.restore();
  // draw y labels
  ctx.save();
  ctx.translate(gap, t_margin);
  this.draw_y_axis_label(ctx, l_margin, h - (t_margin + b_margin), y_label);
  ctx.restore();
  // draw x axis
  ctx.save();
  ctx.translate(l_margin, h - b_margin);
  this.draw_x_axis(ctx, w - (l_margin + r_margin), b_margin);
  ctx.restore();
  // draw top axis
  ctx.save();
  ctx.translate(l_margin, t_margin);
  this.draw_top_axis(ctx, w - (l_margin + r_margin), 0);
  ctx.restore();
  // draw x axis labels
  ctx.save();
  ctx.translate(l_margin, h - b_margin);
  this.draw_x_axis_label(ctx, w - (l_margin + r_margin), b_margin - gap, x_label);
  ctx.restore();
  // draw bars
  ctx.save();
  ctx.translate(l_margin, t_margin);
  this.draw_bars(ctx, w - (l_margin + r_margin), h - (t_margin + b_margin), color);
  ctx.restore();
  return new SiteHistogramGraphMetrics(t_margin, h - b_margin,
    l_margin, this.start, w - r_margin, this.end);
} // SiteHistogramGraph.prototype.draw_graph

/*
 * draw_x_axis
 *
 */
SiteHistogramGraph.prototype.draw_x_axis = function(ctx, w, h) {
  "use strict";
  var scale_x, length, tic_inc, tic_min, tic_max, i, x;
  // pixels per unit
  scale_x = w / (this.end - this.start);
  // calculate a good tic increment
  length = this.end - this.start;
  if (length > 50) {
    // multiple of 10
    tic_inc = Math.max(1, Math.round(length / 100)) * 10;
  } else if (length > 25) {
    tic_inc = 5;
  } else if (length > 10) {
    tic_inc = 2;
  } else {
    tic_inc = 1;
  }
  // work out the min and max values within the start and end
  tic_min = Math.round(this.start / tic_inc) * tic_inc;
  if (tic_min < this.start) {
    tic_min += tic_inc;
  }
  tic_max = Math.round(this.end / tic_inc) * tic_inc;
  if (tic_max > this.end) {
    tic_max -= tic_inc;
  }
  // draw the tics
  ctx.save();
  ctx.font = (length > 10) ? "7pt Helvetica" : "9pt Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  for (i = tic_min; i <= tic_max; i+= tic_inc) {
    x = Math.round((i - this.start) * scale_x) + 0.5;
    ctx.fillText(""+i, x, 5);
    if (i == this.start || i == this.end) continue;
    ctx.beginPath();
    ctx.moveTo(x, -5);
    ctx.lineTo(x, 3);
    ctx.stroke();
  }
  ctx.restore();
};

/*
 * draw_top_axis
 *
 */
SiteHistogramGraph.prototype.draw_top_axis = function(ctx, w, h) {
  "use strict";
  var scale_x, length, tic_inc, tic_min, tic_max, i, x;
  // pixels per unit
  scale_x = w / (this.end - this.start);
  // calculate a good tic increment
  length = this.end - this.start;
  if (length > 50) {
    // multiple of 10
    tic_inc = Math.max(1, Math.round(length / 100)) * 10;
  } else if (length > 25) {
    tic_inc = 5;
  } else {
    tic_inc = 1;
  }
  // work out the min and max values within the start and end
  tic_min = Math.round(this.start / tic_inc) * tic_inc;
  if (tic_min < this.start) {
    tic_min += tic_inc;
  }
  tic_max = Math.round(this.end / tic_inc) * tic_inc;
  if (tic_max > this.end) {
    tic_max -= tic_inc;
  }
  // draw the tics
  ctx.save();
  ctx.font = "9pt Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  for (i = tic_min; i <= tic_max; i+= tic_inc) {
    if (i == this.start || i == this.end) continue;
    x = Math.round((i - this.start) * scale_x) + 0.5;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, 8);
    ctx.stroke();
  }
  ctx.restore();
};

/*
 * draw_x_axis_label
 */
SiteHistogramGraph.prototype.draw_x_axis_label = function(ctx, w, h, label) {
  "use strict";
  ctx.save();
  ctx.font = "9pt Helvetica";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText(label, w/2, h);
  ctx.restore();
};

/*
 * draw_y_axis
 *
 */
SiteHistogramGraph.prototype.draw_y_axis = function(ctx, w, h) {
  "use strict";
  var y_scale, p, y;
  ctx.save();
  ctx.font = "9pt Helvetica";
  ctx.textBaseline = "middle";
  ctx.textAlign = "right";

  y_scale = h / this.ymax;
  for (p = 0; p < this.ymax; p += this.yinc) {
    y = Math.round(h - p * y_scale) + 0.5;
    this.draw_y_tic(ctx, this.ydigits, y, p);
  }
  this.draw_y_tic(ctx, this.ydigits, 0.5, this.ymax);

  ctx.restore();
};

/*
 * draw_y_tic
 */
SiteHistogramGraph.prototype.draw_y_tic = function(ctx, digits, y, p) {
  "use strict";
  ctx.beginPath();
  ctx.moveTo(5, y);
  ctx.lineTo(-3, y);
  ctx.stroke();
  ctx.fillText(p.toFixed(digits), -5, y);
};

/*
 * draw_y_axis_label
 */
SiteHistogramGraph.prototype.draw_y_axis_label = function(ctx, w, h, label) {
  "use strict";
  ctx.save();
  ctx.translate(0, h/2);
  ctx.rotate(-Math.PI / 2);
  ctx.font = "9pt Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  ctx.fillText(label, 0, 0);
  ctx.restore();
};

/*
 * draw_bar
 */
function draw_bar(ctx, upperLeftCornerX, upperLeftCornerY, width, height, color){
    ctx.save();
    ctx.fillStyle=color;
    ctx.fillRect(upperLeftCornerX,upperLeftCornerY,width,height);
    ctx.restore();
}

/*
 * draw_bars
 */
SiteHistogramGraph.prototype.draw_bars = function(ctx, w, h, color) {
  "use strict";
  var i;
  var scale_y = h / this.ymax;
  var scale_x = w / (this.end - this.start);
  var numberOfBars = this.counts.length;
  var spacing = 5;
  var barSize = w/numberOfBars;
  var maxValue = 100;
  for (i=0; i<numberOfBars; i++) {
    var val = this.counts[i];
    var barHeight = Math.round( h * val/maxValue) ;
    draw_bar(
      ctx,
      (i - 0.5) * barSize + spacing/2,
      h - barHeight,
      barSize - spacing,
      barHeight,
      color
    );
  }
  ctx.restore();
};

    </script>
    <script type="text/javascript">
//
// citation.js
//
function get_citation_text(doc_type, extra) {
  var html;

  switch (doc_type) {
    case 'AMA':
      return(get_citation_text("GOMo", extra));
    case 'AME':
      return(extra + `
        <span class="citation">
          Robert C. McLeay and Timothy L. Bailey,
          &quot;Motif Enrichment Analysis: a unified framework and an evaluation on ChIP data&quot;,
          <i>BMC Bioinformatics</i>, <b>11</b>:165, 2010.
          <a href="http://www.biomedcentral.com/1471-2105/11/165">[full text]</a>
        </span>
      `);
    case 'CentriMo':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey and Philip Machanick,
          &quot;Inferring direct DNA binding from ChIP-seq&quot;,
          <i>Nucleic Acids Research</i>, <b>40</b>:e128, 2012.
          <a href="http://nar.oxfordjournals.org/content/40/17/e128">[Full Text]</a>
        </span>
      `);
    case 'DREME':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey,
          &quot;DREME: Motif discovery in transcription factor ChIP-seq data&quot;,
          <i>Bioinformatics</i>, <b>27</b>(12):1653-1659, 2011.
          <a href="http://bioinformatics.oxfordjournals.org/content/27/12/1653">[full text]</a>
        </span>
      `);
    case 'FIMO':
      return(extra + `
        <span class="citation">
          Charles E. Grant, Timothy L. Bailey and William Stafford Noble,
          &quot;FIMO: Scanning for occurrences of a given motif&quot;,
          <i>Bioinformatics</i> <b>27</b>(7):1017-1018, 2011.
          <a href="http://bioinformatics.oxfordjournals.org/content/27/7/1017">[full text]</a>
        </span>
      `);
    case 'GLAM2':
    case 'GLAM2SCAN':
      return(extra + `
        <span class="citation">
          Martin C. Frith, Neil F. W. Saunders, Bostjan Kobe and Timothy L. Bailey,
          &quot;Discovering sequence motifs with arbitrary insertions and deletions&quot;,
          <i>PLoS Computational Biology</i>, <b>4</b>(5):e1000071, 2008.
          <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1000071">[full text]</a>
        </span>
      `);
    case 'GOMo':
      return(extra + `
        <span class="citation">
          Fabian A. Buske, Mikael Bod&eacute;n, Denis C. Bauer and Timothy L. Bailey,
          &quot;Assigning roles to DNA regulatory motifs using comparative genomics&quot;,
          <i>Bioinformatics</i>, <b>26</b>(7), 860-866, 2010.
          <a href="http://bioinformatics.oxfordjournals.org/cgi/content/full/26/7/860">[full text]</a>
        </span>
      `);
    case 'MAST':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey and Michael Gribskov,
          &quot;Combining evidence using p-values: application to sequence homology searches&quot;,
          <i>Bioinformatics</i>, <b>14</b>(1):48-54, 1998.
          <a href="http://bioinformatics.oxfordjournals.org/content/14/1/48">[full text]</a>
        </span>
      `);
    case 'MCAST':
      return(extra + `
        <span class="citation">
          Timothy Bailey and William Stafford Noble,
          &quot;Searching for statistically significant regulatory modules&quot;,
          <i>Bioinformatics (Proceedings of the European Conference on Computational Biology)</i>,
          <b>19</b>(Suppl. 2):ii16-ii25, 2003.
          <a href="http://bioinformatics.oxfordjournals.org/cgi/content/abstract/19/suppl_2/ii16">[full text]</a>
        </span>
      `);
    case 'Meta-MEME':
      return(extra + `
        <span class="citation">
	  William N. Grundy, Timothy L. Bailey, Charles P. Elkan and Michael E. Baker.
	  &quot;Meta-MEME: Motif-based Hidden Markov Models of Protein Families&quot;
	  <i>Computer Applications in the Biological Sciences (CABIOS)</i>,
	  <b>13</b>(4):397-406, 1997.
	  <a href="http://bioinformatics.oxfordjournals.org/content/13/4/397">[full text]</a>
        </span>
      `);
    case 'MEME':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey and Charles Elkan,
          &quot;Fitting a mixture model by expectation maximization to
          discover motifs in biopolymers&quot;,
          <em>Proceedings of the Second International Conference on Intelligent Systems
          for Molecular Biology</em>, pp. 28-36, AAAI Press, Menlo Park, California, 1994.
          <a href="http://www.aaai.org/Papers/ISMB/1994/ISMB94-004.pdf">[full text]</a>
        </span>
      `);
    case 'MEME-ChIP':
      return(extra + `
        <span class="citation">
          Philip Machanick and Timothy L. Bailey,
          &quot;MEME-ChIP: motif analysis of large DNA datasets&quot;,
          <i>Bioinformatics</i> <b>27</b>(12):1696-1697, 2011.
        <a href="http://bioinformatics.oxfordjournals.org/content/27/12/1696.full">[full text]</a>
        </span>
      `);
    case 'MEME_SUITE':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey, James Johnson, Charles E. Grant, William S. Noble,
          &quot;The MEME Suite&quot;,
          <i>Nucleic Acids Research</i>, <b>43</b>(W1):W39-W49, 2015.
          <a href="https://academic.oup.com/nar/article/43/W1/W39/2467905">[full text]</a>
        </span>
      `);
    case 'MoMo':
      return(extra + `
        <span class="citation">
          Alice Cheng, Charles Grant, Timothy L. Bailey and William Noble,
          &quot;MoMo: Discovery of statistically significant post-translational modification motifs&quot;, 
          <i>Bioinformatics</i>, <b>35</b>(16):2774-2782, 2018.
          <a href="https://doi.org/10.1093/bioinformatics/bty1058">[full text]</a>
        </span>
      `);
    case 'PSPs':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey, Mikael Bod&eacute;n, Tom Whitington and Philip Machanick,
          &quot;The value of position-specific priors in motif discovery using MEME&quot;,
          <i>BMC Bioinformatics</i>, <b>11</b>(1):179, 2010.
          <a href="http://www.biomedcentral.com/1471-2105/11/179">[full text]</a>
        </span>
      `);
    case 'SEA':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey and Charles E. Grant, &quot;SEA: Simple Enrichment Analysis of motifs&quot;,
          <i>BioRxiv</i>, 2021.
        </span>
      `);
    case 'SpaMo':
      return(extra + `
        <span class="citation">
          Tom Whitington, Martin C. Frith, James Johnson and Timothy L. Bailey
          &quot;Inferring transcription factor complexes from ChIP-seq data&quot;,
          <i>Nucleic Acids Res.</i> <b>39</b>(15):e98, 2011.
          <a href="http://nar.oxfordjournals.org/content/39/15/e98">[full text]</a>
        </span>
      `);
    case 'STREME':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey,
          &quot;STREME: accurate and versatile sequence motif discovery&quot;,
          <i>Bioinformatics</i>, Mar. 24, 2021.
          <a href="https://academic.oup.com/bioinformatics/advance-article-abstract/doi/10.1093/bioinformatics/btab203/6184861" >[full text]</a>
        </span>
      `);
    case 'Tomtom':
      return(extra + `
        <span class="citation">
          Shobhit Gupta, JA Stamatoyannopolous, Timothy Bailey and William Stafford Noble,
          &quot;Quantifying similarity between motifs&quot;,
          <i>Genome Biology</i>, <b>8</b>(2):R24, 2007.
          <a href="http://genomebiology.com/2007/8/2/R24">[full text]</a>
        </span>
      `);
    case 'T-Gene':
      return(extra + `
        <span class="citation">
          Timothy O'Connor, Charles E. Grant, Mikael Bod&eacute;n, Timothy L. Bailey,
          &quot;T-Gene: Improved target gene prediction&quot;,
            <i>Bioinformatics</i>, <b>36</b>(12):3902-3904, 2020.
          <a href="https://academic.oup.com/bioinformatics/article/36/12/3902/5815978?guestAccessKey=aa625a49-a2aa-4d7a-858e-8bc82867a534">[Full Text]</a>
        </span>
      `);
    case 'XSTREME':
      return(extra + `
        <span class="citation">
          Charles E. Grant and Timothy L. Bailey, &quot;XSTREME: comprehensive motif analysis of biological sequence datasets&quot;,
          <i>BioRxiv</i>, 2021.
        </span>
      `);
    default:
      return("Unknown program: " + doc_type);
  }
} // get_citation_text

//
// Function to replace the innerHTML of element "id" with an HTML paragraph
// containing the text for 'program', which is known to function get_citation_text.
// If "id" is either "citation" or "reference" some extra text is printed.
//
function print_citation(id, program) {
  var extra;
  switch (id) {
    case 'citation':
      extra = "If you use " + program + " in your research, please cite the following paper:<br>";
      break;
    case 'reference':
      extra = "<h5>Reference</h5>";
      break;
    default:
      extra = "";
      break;
  };
  var html = get_citation_text(program, extra);
  document.getElementById(id).insertAdjacentHTML('beforeend', html);
} // print_citation

// 
// Function to convert a citation for a program to a C #define statement.
//
function print_citation_define(lang, pgm) {
  var citation = get_citation_text(pgm, '');
  citation = citation.replace(/<[^>]*>/g, '');
  citation = citation.replace(/\[.*\]/g, '');
  citation = citation.replace(/\n\s*/g, '\\n');
  citation = citation.replace(/&quot;/g, '\\"');
  citation = citation.replace(/&eacute;/g, 'e');
  citation = citation.replace(/^\\n/, '');
  pgm = pgm.replace(/-/, '');
  citation = "If you use this program in your research, please cite:\\n\\n" + citation;
  if (lang == "C") {
    citation = "#define " + pgm + '_CITE "' + citation + '"';
  } else if (lang == "perl") {
    citation = '"' + pgm + '" => "' + citation + '",';
  }
  return(citation);
} // print_citation_define

//
// Main program (for use with nodejs "node" javascript engine)
// to create citation.js.h and citation.pm from citation.js.
// The command line:
//   node citation.js C > citation.js.h
// will output the C #define statements for each of the
// programs listed below, defining macros <program>_CITE.
// The command line:
//   node citation.js perl > citation.js.pm
// will output perl hash <program> => text
//
//
if (typeof process !== 'undefined') {
  var lang = process.argv[2];
  var programs = ['AMA', 'AME', 'CentriMo', 'DREME', 'FIMO', 'GLAM2', 
    'GLAM2SCAN', 'GOMo', 'MAST', 'MCAST', 'Meta-MEME', 'MEME',
    'MEME-ChIP', 'MEME_SUITE', 'MoMo', 'PSPs', 'SEA', 'SpaMo',
    'STREME', 'Tomtom', 'T-Gene', 'XSTREME'];

  if (lang == "C") {
    console.log("// Do not edit this file.  It is created from etc/citation.js.");
    console.log("#ifndef citation_js_h\n#define citation_js_h\n");
    for (var i=0; i<programs.length; i++) {
      console.log(print_citation_define(lang, programs[i]));
    }
    console.log("\n#endif");
  } else if (lang == "perl") {
    console.log("# Do not edit this file.  It is created from etc/citation.js.");
    console.log("package Citation;");
    console.log("sub cite {\n  my ($pgm) = @_;\n  return $citation{$pgm};\n}");
    console.log("%citation = (");
    for (var i=0; i<programs.length; i++) {
      console.log(print_citation_define(lang, programs[i]));
    }
    console.log(");");
  }
}

    </script>
    <script type="text/javascript">
function make_alpha_bg_table(alph, freqs) {
  function colour_symbol(index) {
    var span = document.createElement("span");
    span.appendChild(document.createTextNode(alph.get_symbol(index)));
    span.style.color = alph.get_colour(index);
    span.className = "alpha_symbol";
    return span;
  }
  var table, thead, tbody, row, th, span, i;
  // create table
  table = document.createElement("table");
  table.className = "alpha_bg_table";
  // create header
  thead = document.createElement("thead");
  table.appendChild(thead);
  row = thead.insertRow(thead.rows.length);
  if (alph.has_complement()) {
    add_text_header_cell(row, "Name", "pop_alph_name");
    if (freqs != null) add_text_header_cell(row, "Freq.", "pop_alph_freq");
    if (alph.has_bg()) add_text_header_cell(row, "Bg.", "pop_alph_bg");
    add_text_header_cell(row, "");
    add_text_header_cell(row, "");
    add_text_header_cell(row, "");
    if (alph.has_bg()) add_text_header_cell(row, "Bg.", "pop_alph_bg");
    if (freqs != null) add_text_header_cell(row, "Freq.", "pop_alph_freq");
    add_text_header_cell(row, "Name", "pop_alph_name");
  } else {
    add_text_header_cell(row, "");
    add_text_header_cell(row, "Name", "pop_alph_name");
    if (freqs != null) add_text_header_cell(row, "Freq.", "pop_alph_freq");
    if (alph.has_bg()) add_text_header_cell(row, "Bg.", "pop_alph_bg");
  }
  // add alphabet entries
  tbody = document.createElement("tbody");
  table.appendChild(tbody);
  if (alph.has_complement()) {
    for (i = 0; i < alph.get_size_core(); i++) {
      var c = alph.get_complement(i);
      if (i > c) continue;
      row = tbody.insertRow(tbody.rows.length);
      add_text_cell(row, alph.get_name(i));
      if (freqs != null) add_text_cell(row, "" + freqs[i]);
      if (alph.has_bg()) add_text_cell(row, "" + alph.get_bg_freq(i));
      add_cell(row, colour_symbol(i)); 
      add_text_cell(row, "~");
      add_cell(row, colour_symbol(c)); 
      if (alph.has_bg()) add_text_cell(row, "" + alph.get_bg_freq(c));
      if (freqs != null) add_text_cell(row, "" + freqs[c]);
      add_text_cell(row, alph.get_name(c));
    }
  } else {
    for (i = 0; i < alph.get_size_core(); i++) {
      row = tbody.insertRow(tbody.rows.length);
      add_cell(row, colour_symbol(i)); 
      add_text_cell(row, alph.get_name(i));
      if (freqs != null) add_text_cell(row, "" + freqs[i]);
      if (alph.has_bg()) add_text_cell(row, "" + alph.get_bg_freq(i));
    }
  }
  return table;
}


    </script>
    <script type="text/javascript">
pre_load_setup();
var sea_alphabet = new Alphabet(data.alphabet, data.background['frequencies']);

/*
 * name_from_source
 *
 * Makes a file name more human friendly to read.
 */
function name_from_source(source) {
  if (source == "-") {
    return "-"
  }
  // assume source is a file name
  var file = source.replace(/^.*\/([^\/]+)$/,"$1");
  var noext = file.replace(/\.[^\.]+$/, "");
  return noext.replace(/_/g, " ");
}

/*
 * pre_load_setup
 *
 *  Sets up initial variables which may be
 *  required for the HTML document creation.
 */
function pre_load_setup() {
  var seq_db = data['sequence_db'];
  if (!seq_db['name']) seq_db['name'] = name_from_source(seq_db['source']);
  // get the names of the motif databases
  var dbs = data['motif_dbs'];
  var motif_count = 0;
  for (var i = 0; i < dbs.length; i++) {
    var db = dbs[i];
    if (!db['name']) db['name'] = name_from_source(db['source']);
    motif_count += db['count'];
  }
  dbs['count'] = motif_count;
}

/*
 * page_loaded
 *
 * Called when the page has loaded for the first time.
 */
function page_loaded() {
  post_load_setup();
}

/*
 * page_loaded
 *
 * Called when a cached page is reshown.
 */
function page_shown(e) {
  if (e.persisted) post_load_setup();
}

/*
 * post_load_setup
 *
 * Setup state that is dependant on everything having been loaded already.
 */
function post_load_setup() {
  update_scroll_pad();
}

/*
 * add_cell
 *
 * Add a cell to the table row.
 */
function add_cell(row, node, cls) {
  var cell = row.insertCell(row.cells.length);
  if (node) cell.appendChild(node);
  if (cls) cell.className = cls;
}

/*
 * add_text_cell
 *
 * Add a text cell to the table row.
 */
function add_text_cell(row, text, cls) {
  var node = null;
  if (text) node = document.createTextNode(text);
  add_cell(row, node, cls);
}

function toExp(num, prec) {
  if (typeof(num) === "number") return num.toExponential(prec);
  return "";
}

DelayLogoTask.prototype.run = function () {
  draw_logo_on_canvas(this.logo, this.canvas, false);
};

var DelayCentrimoPlotTask = function(graph, canvas) {
  this.graph = graph;
  this.canvas = canvas;
};

DelayCentrimoPlotTask.prototype.run = function () {
  this.graph.draw_lines(this.canvas.getContext("2d"),
      this.canvas.width, this.canvas.height);
};

function make_distribution(motif) {
  var canvas = document.createElement("canvas");
  canvas.title = "Distribution of best motif sites in sequences.";
  canvas.width = 200;
  canvas.height = 90;
  var color = "blue";
  var seq_len = data["sequence_db"]["maxlen"];
  //var smooth = Math.ceil(seq_len*0.05);
  var rset = new CentrimoRSet(seq_len);
  if (motif["site_distr"]) {
    rset.add("", "", color, motif["len"], motif["total_sites"], motif["site_distr"]);
    var graph = new CentrimoGraph(rset, triangular_weights(20), null, null, null, null, data["options"]["align"], motif["len"]);
    add_draw_task(canvas, new DelayCentrimoPlotTask(graph, canvas));
  }
  return canvas;
} // make_distribution

function make_histogram(motif) {
  var canvas = document.createElement("canvas");
  var ctx = canvas.getContext('2d');
  canvas.width = 200;
  canvas.height = 115;
  var x_label = "Matches per Sequence";
  var y_label = "% Sequences";
  var color = "blue";
  var graph = new SiteHistogramGraph(motif["site_hist"]);
  graph.draw_graph(ctx, canvas.width, canvas.height, x_label, y_label, color);
  return canvas;
} // make_histogram

/*
 * make_results_table
 *
 * Add the results to the results table.
 */
function make_results_table() {
  var i;
  var distr = (data['motifs'].length > 0 && data['motifs'][0]['site_distr']);
  var table = $("results");
  var tbody = document.createElement("tbody");
  var motif_dbs = data['motif_dbs'];
  var motifs = data['motifs'];
  for (var i = 0; i < motifs.length; i++) {
    var motif = motifs[i];
    var row = tbody.insertRow(tbody.rows.length);
    row.id = "db_" + motif['db'] + "_motif_" + motif['id'];
    row['motif'] = motif;
    var canvas = document.createElement('canvas');
    var pspm = new Pspm(motif['pwm'], motif['id'], 0, 0, motif['motif_nsites'], motif['motif_evalue']);
    var logo = logo_1(sea_alphabet, '', pspm);
    draw_logo_on_canvas(logo, canvas, false, 0.5);
    var pos = data['sequence_db']['count'] - data['sequence_db']['holdout'];
    var neg = data['control_db']['count'] - data['control_db']['holdout'];
    var tp = motif['tp'];
    var fp = motif['fp'];
    add_cell(row, canvas, 'col_logo');
    add_text_cell(row, motif_dbs[motif['db']]['name'], 'col_db');
    add_cell(row, make_link(motif['id'], motif['url']), 'col_id');
    add_text_cell(row, motif['alt'], 'col_name');
    add_text_cell(row, motif['pvalue'], 'col_pvalue');
    add_text_cell(row, motif['evalue'], 'col_evalue');
    add_text_cell(row, motif['qvalue'], 'col_qvalue');
    add_text_cell(row, tp.toFixed(0) + ' / ' + pos + ' (' + (100*tp/pos).toFixed(1) + "%)", 'col_tp');
    add_text_cell(row, fp.toFixed(0) + ' / ' + neg + ' (' + (100*fp/neg).toFixed(1) + "%)", 'col_fp');
    add_text_cell(row, motif['enr_ratio'].toFixed(2), 'col_ratio');
    add_text_cell(row, (motif['score_thresh']).toFixed(2), 'score_thresh');
    add_cell(row, make_distribution(motif), "col_distribution");
    add_cell(row, make_histogram(motif), "col_histogram");
  }
  table.appendChild(tbody);
}

    </script>
    <script type="text/javascript">
//
// description_section.js
//

//
// Create a description element taking into account newlines (line breaks) 
// and multiple newlines (paragraph breaks) in the source text.
//
function make_description(container, description) {
  "use strict";
  var header, box, paragraphs, p, lines, i, j;
  container.innerHTML = "";
  if (description) {
    header = document.createElement("h2");
    header.className = "mainh pad2";
    header.id = "description";
    header.appendChild(document.createTextNode("Description"));
    container.appendChild(header);
    box = document.createElement("div");
    box.className = "box";
    container.appendChild(box);
    var text = description.replace(/\\n/g, "\n");
    paragraphs = text.split(/\n\n+/);
    for (i = 0; i < paragraphs.length; i++) {
      p = document.createElement("p");
      lines = paragraphs[i].split("\n");
      for (j = 0; j < lines.length; j++) {
        if (j != 0) p.appendChild(document.createElement('br'));
        p.appendChild(document.createTextNode(lines[j]));
      }
      box.appendChild(p);
    }
  }
}

    </script>
    <style type="text/css">
table.inputs, table.alpha_bg_table {
  margin-top: 20px;
  border-collapse:collapse;
}
table.inputs * td, table.inputs * th, table.alpha_bg_table * td, table.alpha_bg_table * th {
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 1px;
  padding-bottom: 1px;
}
table.results {
  border-collapse:collapse;
}
table.results * td, table.results * th {
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 1px;
  padding-bottom: 1px;
}

table.results * td.logo {
  height: 20px;
}

table.no_tp_fp .col_fp,
table.no_tp_fp .col_tp,
table.no_p_thresh .col_p_thresh,
table.no_tp_thresh .col_tp_thresh,
table.no_pos .col_pos,
table.no_neg .col_neg,
table.linreg .col_spearmans_rho,
table.spearman .col_pearsons_rho,
table.spearman .col_mean_square_error, 
table.spearman .col_m, 
table.spearman .col_b,
table.other .col_pearsons_rho,
table.other .col_spearmans_rho,
table.other .col_mean_square_error, 
table.other .col_m, 
table.other .col_b {
  display: none;
}

/* program settings */
span.strand_none, span.strand_given, span.strand_both {
  display: none;
}
td.none span.strand_none, td.given span.strand_given, td.both span.strand_both {
  display: inline;
}

div.pop_content {
  position:absolute;
  z-index:1;
  width:300px;
  padding: 5px;
  background: #E4ECEC;
  font-size: 12px;
  font-family: Arial;
  border-style: double;
  border-width: 3px;
  border-color: #AA2244;
  display:none;
}

/* For hiding results columns */
th.hide_col, td.hide_col {
  display: none;
}

    </style>
    <style type="text/css">
/* The following is the content of meme.css */
body { background-color:white; font-size: 12px; font-family: Verdana, Arial, Helvetica, sans-serif;}

div.help {
  display: inline-block;
  margin: 0px;
  padding: 0px;
  width: 12px;
  height: 13px;
  cursor: pointer;
  background-image: url(data:image/gif;base64,R0lGODlhDAANAIABANR0AP///yH5BAEAAAEALAAAAAAMAA0AAAIdhI8Xy22MIFgv1DttrrJ7mlGNNo4c+aFg6SQuUAAAOw==);
}

div.help:hover {
  background-image: url(data:image/gif;base64,R0lGODlhDAANAKEAANR0AP///9R0ANR0ACH+EUNyZWF0ZWQgd2l0aCBHSU1QACH5BAEAAAIALAAAAAAMAA0AAAIdDGynCe3PgoxONntvwqz2/z2K2ImjR0KhmSIZUgAAOw==);
}

p.spaced { line-height: 1.8em;}

span.citation { font-family: "Book Antiqua", "Palatino Linotype", serif; color: #004a4d;}

p.pad { padding-left: 30px; padding-top: 5px; padding-bottom: 10px;}

td.jump { font-size: 13px; color: #ffffff; background-color: #00666a;
  font-family: Georgia, "Times New Roman", Times, serif;}

a.jump { margin: 15px 0 0; font-style: normal; font-variant: small-caps;
  font-weight: bolder; font-family: Georgia, "Times New Roman", Times, serif;}

h2.mainh {font-size: 1.5em; font-style: normal; margin: 15px 0 0;
  font-variant: small-caps; font-family: Georgia, "Times New Roman", Times, serif;}

h2.line {border-bottom: 1px solid #CCCCCC; font-size: 1.5em; font-style: normal;
  margin: 15px 0 0; padding-bottom: 3px; font-variant: small-caps;
  font-family: Georgia, "Times New Roman", Times, serif;}

h4 {border-bottom: 1px solid #CCCCCC; font-size: 1.2em; font-style: normal;
  margin: 10px 0 0; padding-bottom: 3px; font-family: Georgia, "Times New Roman", Times, serif;}

h5 {margin: 0px}

a.help { font-size: 9px; font-style: normal; text-transform: uppercase;
  font-family: Georgia, "Times New Roman", Times, serif;}

div.pad { padding-left: 30px; padding-top: 5px; padding-bottom: 10px;}

div.pad1 { margin: 10px 5px;}

div.pad2 { margin: 25px 5px 5px;}
h2.pad2 { padding: 25px 5px 5px;}

div.pad3 { padding: 5px 0px 10px 30px;}

div.box { border: 2px solid #CCCCCC; padding:10px; overflow: hidden;}

div.bar { border-left: 7px solid #00666a; padding:5px; margin-top:25px; }

div.subsection {margin:25px 0px;}

img {border:0px none;}

th.majorth {text-align:left;}
th.minorth {font-weight:normal; text-align:left; width:8em; padding: 3px 0px;}
th.actionth {font-weight:normal; text-align:left;}

.explain h5 {font-size:1em; margin-left: 1em;}

div.doc {margin-left: 2em; margin-bottom: 3em;}

th.trainingset {
  border-bottom: thin dashed black; 
  font-weight:normal; 
  padding:0px 10px;
}
div.pop_content {
  position:absolute;
  z-index:50;
  width:300px;
  padding: 5px;
  background: #E4ECEC;
  font-size: 12px;
  font-family: Arial;
  border-style: double;
  border-width: 3px;
  border-color: #AA2244;
  display:none;
}
div.pop_content_wide {
  position:absolute;
  z-index:1;
  width:700px;
  padding: 5px;
  background: #E4ECEC;
  font-size: 12px;
  font-family: Arial;
  border-style: double;
  border-width: 3px;
  border-color: #AA2244;
  display:none;
}

div.pop_content > *:first-child {
  margin-top: 0px;
}

div.pop_content h1, div.pop_content h2, div.pop_content h3, div.pop_content h4, 
div.pop_content h5, div.pop_content h6, div.pop_content p {
  margin: 0px;
}

div.pop_content p + h1, div.pop_content p + h2, div.pop_content p + h3, 
div.pop_content p + h4, div.pop_content p + h5, div.pop_content p + h6 {
  margin-top: 5px;
}

div.pop_content p + p {
  margin-top: 5px;
}

div.pop_content > *:last-child {
  margin-bottom: 0px;
}

div.pop_content div.pop_close {
  /* old definition */
  float:right;
  bottom: 0;
}

div.pop_content span.pop_close, div.pop_content span.pop_back {
  display: inline-block;
  border: 2px outset #661429;
  background-color: #CCC;
  padding-left: 1px;
  padding-right: 1px;
  padding-top: 0px;
  padding-bottom: 0px;
  cursor: pointer;
  color: #AA2244; /*#661429;*/
  font-weight: bold;
}

div.pop_content span.pop_close:active, div.pop_content span.pop_back:active {
  border-style: inset;
}

div.pop_content span.pop_close {
  float:right;
  /*border: 2px outset #AA002B;*/
  /*color: #AA2244;*/
}

div.pop_content:not(.nested) .nested_only {
  display: none;
}

div.pop_back_sec {
  margin-bottom: 5px;
}

div.pop_close_sec {
  margin-top: 5px;
}

table.hide_advanced tr.advanced {
  display: none;
}
span.show_more {
  display: none;
}
table.hide_advanced span.show_more {
  display: inline;
}
table.hide_advanced span.show_less {
  display: none;
}


/*****************************************************************************
 * Program logo styling
 ****************************************************************************/
div.prog_logo {
  border-bottom: 0.25em solid #0f5f60;
  height: 4.5em;
  width: 25em;
  display:inline-block;
}
div.prog_logo img {
  float:left;
  width: 4em;
  border-style: none;
  margin-right: 0.2em;
}
div.prog_logo h1, div.prog_logo h1:hover, div.prog_logo h1:active, div.prog_logo h1:visited {
  margin:0;
  padding:0;
  font-family: Arial, Helvetica,  sans-serif;
  font-size: 3.2em;
  line-height: 1em;
  vertical-align: top;
  display: block;
  color: #026666;
  letter-spacing: -0.06em;
  text-shadow: 0.04em 0.06em 0.05em #666;
}
div.prog_logo h2, div.prog_logo h2:hover, div.prog_logo h2:active, div.prog_logo h2:visited {
  display: block;
  margin:0;
  padding:0;
  font-family: Helvetica, sans-serif;
  font-size: 0.9em;
  line-height: 1em;
  letter-spacing: -0.06em;
  color: black;
}
div.prog_logo h3, div.prog_logo h3:hover, div.prog_logo h3:active, div.prog_logo h3:visited {
  display: block;
  margin:0;
  padding:0;
  font-family: Helvetica, sans-serif;
  font-size: 0.9em;
  line-height: 1.5em;
  letter-spacing: -0.06em;
  color: black;
}

div.big.prog_logo {
  font-size: 18px;
}

/* These are for centered columns in tables */
td.ctr {
  text-align: center;
}

/* These are for the navigation bars at the top of outputs. */
table.navigation {
  margin-top: 0px;
  border-collapse:collapse;
}
table.navigation * td
{
  padding-left: 0px;
  padding-right: 10px;
  padding-top: 0px;
  padding-bottom: 0px;
}

    </style>
  </head>
  <body onload="page_loaded()" onpageshow="page_shown(event)" onresize="update_scroll_pad()">
    <!-- Help popups -->
    <div class="pop_content" id="pop_alph_name">
      <script>print_doc_para('pop_alph_name', 'shared', 'alph-name', 'The ');</script>
      <div class="pop_close">[<a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_alph_bg">
      <script>print_doc_para('pop_alph_bg', 'shared', 'alph-bg', 'The ');</script>
      <div class="pop_close">[<a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content_wide" id="pop_results">
      <script>print_doc("pop_results", "sea", "sea-tsv-description");</script>
      <script>print_doc("pop_results", "shared", "motif-consensus");</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content_wide" id="pop_sequences">
      <script>print_doc("pop_sequences", "sea", "sea-sequences-tsv");</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_db">
      <script>print_doc_para("pop_db", 'shared', "motif-db", "motif.");</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_id">
      <script>print_doc_para("pop_id", 'shared', "motif-id");</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_name">
      <script>print_doc_para("pop_name", 'shared', "motif-alt-id");</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_pvalue">
      <script>print_doc_para('pop_pvalue', 'sea', 'sea-pvalue');
      </script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_evalue">
      <script>print_doc_para('pop_evalue', 'sea', 'sea-evalue');</script> 
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_qvalue">
      <script>print_doc_para("pop_qvalue", 'shared', "bh-q-value", "SEA", "motif");</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_tp">
      <script>print_doc_para('pop_tp', 'sea', 'sea-tp');</script> 
      </p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_fp">
      <script>print_doc_para('pop_fp', 'sea', 'sea-fp');</script> 
      </p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_ratio">
      <script>print_doc_para("pop_ratio", 'sea', "sea-enr_ratio");</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_score_thresh">
	<script>print_doc_para("pop_score_thresh", 'sea', "sea-score_thr");</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_site_distr">
      <script>print_doc_para("pop_site_distr", "discovery", "site_distr", "primary");</script>
      <div style="float:right; bottom:0px;">[
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_site_hist">
      <script>print_doc_para("pop_site_hist", "discovery", "site_hist", "primary");</script>
      <div style="float:right; bottom:0px;">[
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <!-- Page start -->
      <div class="prog_logo big">
        <img src="data:image/png;base64,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" alt="SEA Logo">
        <h1>SEA</h1>
        <h2>Simple Enrichment Analysis</h2>
      </div>
      <p>
        For further information on how to interpret these results please access
        <a href="https://meme-suite.org/meme/doc/sea-output-format.html">https://meme-suite.org/meme/doc/sea-output-format.html</a>.<br>
	To get a copy of the MEME software please access 
        <a href="https://meme-suite.org">https://meme-suite.org</a>. 
      </p>
      <p id="citation">
        <script>print_citation("citation", "SEA");</script>
      </p>
    <!-- navigation -->
    <div class="pad2">
      <a class="jump" href="#data_sec">Enriched Motifs</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="#input_sec">Input Files</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="#info_sec">Program information</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="sea.tsv">Results in TSV Format</a>&nbsp;<span id="results_help"></span>
      <div id="sequences_file">
	&nbsp;&nbsp;|&nbsp;&nbsp;
	<a class="jump" href="sequences.tsv">Matching Sequences</a>&nbsp;<span id="sequences_help"></span>
      </div>
      <script>
        make_help_button($("results_help"), "pop_results");
        make_help_button($("sequences_help"), "pop_sequences");
        sequences_file.style.display = (data.options.noseqs == "false") ? "inline" : "none";
      </script>
    </div>
    <!-- alert the user when their browser is not up to the task -->
    <noscript><h1 style="color:red">Javascript is required to view these results!</h1></noscript>
    <script>
      if (!window.HTMLCanvasElement)
        document.write("<h1 style=\"color:red\">Your browser does not support canvas!</h1>\n");
    </script>
    <!-- description -->
    <!-- write out the job description -->
    <span id="ins_desc"></span>
    <script>make_description($("ins_desc"), data.description);</script>
    <!-- enriched motfis -->
    <h2 class="mainh pad2" id="data_sec">Enriched Motifs</h2>
    <div class="box">
      <!-- messages -->
      <p>
      <script>
	document.write('<b>Found ' + 
          (data['motifs'].length ? data['motifs'].length : 'no') + 
          (data['options']['thresh_type'] == "pvalue" ? 
	      ' motifs with <i>p</i>-values &le; ' :
            (data['options']['thresh_type'] == "qvalue" ? 
	      ' motifs with q-values &le; ' :
	      ' motifs with <i>E</i>-values &le; '
          )) + data['options']['thresh'] + '.</b>');
      </script>
      </p>

      <table class="results" id="results">
        <thead>
          <tr id="header_row">
            <th class="col_logo">Logo</th>
            <th class="col_db">Database&nbsp;<div class="help" 
                onclick="help_popup(this, 'pop_db')"></div></th>
            <th class="col_id">ID&nbsp;<div class="help" 
                onclick="help_popup(this, 'pop_id')"></div></th>
            <th class="col_name">Alt ID&nbsp;<div class="help" 
                onclick="help_popup(this, 'pop_name')"></div></th>
            <th class="col_pvalue"><i>P</i>-value&nbsp;<div 
                class="help" onclick="help_popup(this, 'pop_pvalue')"></div></th>
            <th class="col_evalue"><i>E</i>-value&nbsp;<div class="help" 
                onclick="help_popup(this, 'pop_evalue')"></div></th>
            <th class="col_qvalue">Q-value&nbsp;<div class="help" 
                onclick="help_popup(this, 'pop_qvalue')"></div></th>
            <th class="col_tp">TP&nbsp;<div class="help" 
                onclick="help_popup(this, 'pop_tp')"></div></th>
            <th class="col_fp">FP&nbsp;<div class="help" 
                onclick="help_popup(this, 'pop_fp')"></div></th>
            <th class="col_ratio">Enrichment<br>Ratio&nbsp;<div class="help" 
                onclick="help_popup(this, 'pop_ratio')"></div></th>
            <th class="col_score_thresh">Score<br>Threshold&nbsp;<div class="help" 
                onclick="help_popup(this, 'pop_score_thresh')"></div></th>
          </tr>
        </thead>
      </table>
      <script>
        if (data['motifs'].length > 0) { 
          if (data['motifs'][0]['site_distr']) {
            add_text_header_cell($("header_row"), "Positional Distribution", "pop_site_distr", "col_distribution");
            add_text_header_cell($("header_row"), "Matches per Sequence", "pop_site_hist", "col_histogram");
          }
          make_results_table(); 
        }
      </script>
    </div>

    <h2 id="input_sec" class="mainh pad2">Input Files</h2>
    <div class="box">
      <h4>Alphabet</h4>
      <span id="bg_source"></span>
      <span id="bg_order"></span>
      <span id="alpha_bg"></span>
      <script>
      {
        $("bg_source").appendChild(make_background_source("Background source", data.background['source']));
        $("bg_order").innerHTML = "&nbsp;&nbsp;&nbsp;&nbsp;<b>Order:</b> " + data.options['order'] +
          (data.options['order']>0 ? " (only order-0 shown)" : "");
        $("alpha_bg").appendChild(make_alpha_bg_table(sea_alphabet));
      }
      </script>
      <h4>Sequences</h4>
        <!-- This script prints the whole table so things will be "balanced". -->
	<script>
          {
            var db = data['sequence_db'];
            document.write("<table class=\"inputs\">\n");
            if (data['control_db']) {
              document.write("<tr><th>Primary Sequences</th><th>Number</th><th>Control Sequences</th><th>Number</th></tr>");
            } else {
              document.write("<tr><th>Primary Sequences</th><th>Number</th></tr>");
            }
            document.write("<tr><td>" + db['source'] + "</td>");
            document.write("<td>" + db['count'] + "</td>");
            if (data['control_db']) {
              var db = data['control_db'];
              if (db['from']) {
                document.write("<td>primary sequences shuffled conserving " + (data['options']['order']+1) + "-mer frequencies</td>");
              } else {
		document.write("<td>" + db['source'] + "</td>");
              }
              document.write("<td>" + db['count'] + "</td>");
            }
            document.write("</tr></table>");
          }
	</script>
      <h4>Motifs</h4>
      <table class="inputs">
        <tr><th>Database</th><th>Source</th><th>Motif Count</th></tr>
        <script>
        {
          var motif_dbs = data['motif_dbs'];
          for (var i = 0; i < motif_dbs.length; i++) {
            var db = motif_dbs[i];
            document.write("<tr>");
            document.write("<td>"  + db['name'] + "</td>");
            document.write("<td>" + db['source'] + "</td>");
            document.write("<td>" + db['count'] + "</td>");
            document.write("</tr>");
          }
        }
        </script>
      </table>
      <h4>Other Settings</h4>
      <table id="tbl_settings" class="inputs hide_advanced">
        <tr>
          <th>Strand Handling</th>
          <td id="opt_strand">
            <span class="strand_none">This alphabet only has one strand.</span>
            <span class="strand_given">Only the given strand is processed.</span>
            <span class="strand_both">Both the given and reverse complement strands are processed.</span>
          </td>
        </tr>
        <tr><th>Objective Function</th><td id="opt_objfun"></td></tr>
        <tr><th>Statistical Test</th><td id="opt_test"></td></tr>
        <tr id="shuffling"><th>Sequence Shuffling</th><td id="opt_shuffling"></td></tr>
        <tr><th>Hold-out Set</th><td id="opt_is_holdout"></td></tr>
        <tr><th>Pseudocount</th><td id="opt_pseudo"></td></tr>
        <tr><th>Significance threshold</th><td id="opt_thresh"></td></tr>
        <tr><th>Random Number Seed</th><td id="opt_seed"></td></tr>
      </table>
    </div>
    <script>
      {
        // Don't display shuffling line if not relevant.
        if (data.sequence_db.source === data.sequence) {
          var element=document.getElementById("shuffling");
          element.style.display="none";
        }
        $("opt_strand").className = (sea_alphabet.has_complement() ? (data.options.strands == "both" ? "both" : "given") : "none");
        $("opt_objfun").innerHTML = data.options.objfun;
        $("opt_test").innerHTML = data.options.test;
        $("opt_shuffling").innerHTML = data.options.objfun == "Central Distance" ? "None." : "Control sequences are primary sequences shuffled preserving " + (data.options.order+1) + "-mer frequencies.";
        $("opt_pseudo").innerHTML = data.options.pseudocount + " times the background frequencies";
        $("opt_thresh").innerHTML = "Motifs must have an enrichment " + (data.options.qvalue ? " q-value of " : " E-value of ") + data.options.thresh + " or smaller.";
        $("opt_thresh").innerHTML = "Motifs must have an enrichment " +
          (data.options.thresh_type == "pvalue" ? 
	    "<i>p</i>-value" : (data.options.thresh_type == "qvalue" ?  "q-value" : "<i>E</i>-value")) +
          " of " + data.options.thresh + " or smaller.";
        $("opt_seed").innerHTML = data.options.seed;
        $("opt_is_holdout").innerHTML = data.options.is_holdout ? 100*data.options.hofract + "% of the input sequences were randomly assigned to the hold-out set to improve <i>p</i>-value accuracy." : "There were not enough input sequences to create a hold-out set so the <i>p</i>-values will be less accurate.";
      }
    </script>

    <!-- list information on this program -->
    <div id="info_sec" class="bar">
      <div class="subsection">
        <h5 id="version">SEA version</h5>
        <span id="ins_version"></span>
        (Release date: <span id="ins_release"></span>)<br>
      </div>
      <script>
        $("ins_version").innerHTML = data["version"];
        $("ins_release").innerHTML = data["release"];
      </script>
      <div class="subsection" id="reference">
        <script>print_citation("reference", "SEA");</script>
      </div>
      <div class="subsection">
	<h5 id="command">Command line summary</h5>
	<textarea id="cmd" rows="5" style="width:100%;" readonly="readonly">
	</textarea>
	<script>$("cmd").value = data["cmd"].join(" ");</script>
      </div>
    </div>
    <div id="scrollpad"></div>
  </body>
</html>
