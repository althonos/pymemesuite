<!doctype html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>CentriMo Results</title>
    <script type="text/javascript">
      //@JSON_VAR data
      var data = {
        "version": "5.4.0",
        "revision": "a811b14dc8b6882270e1887d7db8e534fdd55b99",
        "release": "Tue Mar 9 17:38:20 2021 -0800",
        "program": "CentriMo",
        "cmd": [
          "centrimo", "--oc", "results/centrimo4", "--verbosity", "1", "--cd",
          "--xalph", "common/dna_with_covalent.alph", "--noseq", "--inc",
          "MA00*", "--inc", "MA04*", "--exc", "MA007*", "--inc", "T*",
          "common/dna_with_covalent.fa", "common/Jaspar-subset.meme",
          "common/Jaspar-subset2.meme", "common/dna_with_covalent.meme"
        ],
        "options": {
          "cd": true,
          "neg_sequences": false,
          "xalph": "common/dna_with_covalent.alph",
          "bfile": "--sequences--",
          "motif_pseudo": 0.1,
          "seqlen": 0,
          "use_lo_fraction": false,
          "use_pvalues": false,
          "score": 5,
          "optimize_score": true,
          "minbin": 0,
          "maxbin": 0,
          "norc": false,
          "sep": false,
          "flip": false,
          "local": false,
          "ethresh": 10,
          "noseq": true,
          "mcc": false
        },
        "seqlen": 500,
        "tested": 9,
        "alphabet": {
          "name": "DNA with covalent modifications",
          "like": "dna",
          "ncore": 12,
          "symbols": [
            {
              "symbol": "A",
              "name": "Adenine",
              "colour": "8510A8",
              "complement": "T"
            }, {
              "symbol": "C",
              "name": "Cytosine",
              "colour": "A50026",
              "complement": "G"
            }, {
              "symbol": "G",
              "name": "Guanine",
              "colour": "313695",
              "complement": "C"
            }, {
              "symbol": "T",
              "name": "Thymine",
              "colour": "A89610",
              "complement": "A"
            }, {
              "symbol": "c",
              "name": "5-Carboxylcytosine",
              "colour": "FEE090",
              "complement": "4"
            }, {
              "symbol": "f",
              "name": "5-Formylcytosine",
              "colour": "FDAE61",
              "complement": "3"
            }, {
              "symbol": "h",
              "name": "5-Hydroxymethylcytosine",
              "colour": "F46D43",
              "complement": "2"
            }, {
              "symbol": "m",
              "name": "5-Methylcytosine",
              "colour": "D73027",
              "complement": "1"
            }, {
              "symbol": "1",
              "name": "Guanine:5-Methylcytosine",
              "colour": "4575B4",
              "complement": "m"
            }, {
              "symbol": "2",
              "name": "Guanine:5-Hydroxymethylcytosine",
              "colour": "74ADD1",
              "complement": "h"
            }, {
              "symbol": "3",
              "name": "Guanine:5-Formylcytosine",
              "colour": "ABD9E9",
              "complement": "f"
            }, {
              "symbol": "4",
              "name": "Guanine:5-Carboxylcytosine",
              "colour": "E0F3F8",
              "complement": "c"
            }, {
              "symbol": "?",
              "equals": "ACGTcfhm1234"
            }, {
              "symbol": "z",
              "equals": "Ccfhm"
            }, {
              "symbol": "9",
              "equals": "G1234"
            }, {
              "symbol": "N",
              "equals": "ACGT"
            }, {
              "symbol": "V",
              "equals": "ACG"
            }, {
              "symbol": "H",
              "equals": "ACT"
            }, {
              "symbol": "D",
              "equals": "AGT"
            }, {
              "symbol": "B",
              "equals": "CGT"
            }, {
              "symbol": "y",
              "equals": "Ccf"
            }, {
              "symbol": "8",
              "equals": "G34"
            }, {
              "symbol": "M",
              "equals": "AC"
            }, {
              "symbol": "R",
              "equals": "AG"
            }, {
              "symbol": "W",
              "equals": "AT"
            }, {
              "symbol": "S",
              "equals": "CG"
            }, {
              "symbol": "Y",
              "equals": "CT"
            }, {
              "symbol": "K",
              "equals": "GT"
            }, {
              "symbol": "x",
              "equals": "hm"
            }, {
              "symbol": "7",
              "equals": "12"
            }
          ]
        },
        "background": [
          0.240024, 0.244186, 0.244186, 0.240024, 1.03258e-06, 1.03258e-06,
          0.00022252, 0.0155661, 0.0155661, 0.00022252, 1.03258e-06,
          1.03258e-06
        ],
        "sequence_db": {
          "source": "common/dna_with_covalent.fa",
          "count": 2499,
          "skipped": 0
        },
        "motif_dbs": [
          {
            "source": "common/Jaspar-subset.meme",
            "count": 4
          }, {
            "source": "common/Jaspar-subset2.meme",
            "count": 2
          }, {
            "source": "common/dna_with_covalent.meme",
            "count": 3
          }
        ],
        "motifs": [
          {
            "db": 0,
            "id": "MA0039.2",
            "alt": "Klf4",
            "consensus": "DGGGYGKGGC",
            "len": 10,
            "motif_evalue": "0.0e+000",
            "motif_nsites": 4340,
            "n_tested": 284,
            "score_threshold": 12.1091,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0039.2&rm=present&collection=CORE",
            "pwm": [
              [
                0.338559, 0.0186862, 0.235701, 0.407053, 3.53118e-11,
                3.53118e-11, 5.13856e-09, 3.58667e-07, 3.58667e-07,
                5.13856e-09, 3.53118e-11, 3.53118e-11
              ], [
                0.0202811, 0.00207958, 0.976251, 0.0013875, 3.53118e-11,
                3.53118e-11, 5.13856e-09, 3.58667e-07, 3.58667e-07,
                5.13856e-09, 3.53118e-11, 3.53118e-11
              ], [
                0.00322845, 0.00299855, 0.990774, 0.00299846, 3.53118e-11,
                3.53118e-11, 5.13856e-09, 3.58667e-07, 3.58667e-07,
                5.13856e-09, 3.53118e-11, 3.53118e-11
              ], [
                0.00322645, 0.00828743, 0.984799, 0.00368644, 3.53118e-11,
                3.53118e-11, 5.13856e-09, 3.58667e-07, 3.58667e-07,
                5.13856e-09, 3.53118e-11, 3.53118e-11
              ], [
                0.0636971, 0.441936, 0.00253457, 0.491831, 3.53118e-11,
                3.53118e-11, 5.13856e-09, 3.58667e-07, 3.58667e-07,
                5.13856e-09, 3.53118e-11, 3.53118e-11
              ], [
                0.00506941, 0.00345855, 0.983639, 0.00783235, 3.53118e-11,
                3.53118e-11, 5.13856e-09, 3.58667e-07, 3.58667e-07,
                5.13856e-09, 3.53118e-11, 3.53118e-11
              ], [
                0.00967631, 0.0184252, 0.501721, 0.470177, 3.53118e-11,
                3.53118e-11, 5.13856e-09, 3.58667e-07, 3.58667e-07,
                5.13856e-09, 3.53118e-11, 3.53118e-11
              ], [
                0.0608761, 0.0106114, 0.899685, 0.0288269, 3.53118e-11,
                3.53118e-11, 5.13856e-09, 3.58667e-07, 3.58667e-07,
                5.13856e-09, 3.53118e-11, 3.53118e-11
              ], [
                0.0284049, 0.0300209, 0.874841, 0.066732, 3.53118e-11,
                3.53118e-11, 5.13856e-09, 3.58667e-07, 3.58667e-07,
                5.13856e-09, 3.53118e-11, 3.53118e-11
              ], [
                0.0587462, 0.660952, 0.0647591, 0.215542, 3.53118e-11,
                3.53118e-11, 5.13856e-09, 3.58667e-07, 3.58667e-07,
                5.13856e-09, 3.53118e-11, 3.53118e-11
              ]
            ],
            "total_sites": 210,
            "sites": [
              0, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1,
              1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2,
              0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 3, 1.5, 0, 0,
              0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1,
              2, 0, 0, 0, 0, 0, 2, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0,
              1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 1, 3, 0, 0, 1, 1, 1,
              0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0,
              0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0,
              0, 0, 2, 0, 0, 0, 0, 1, 0, 1, 1, 1, 2, 2, 2, 1, 1, 0, 0, 0, 0,
              0, 1, 2, 0, 0, 0, 1, 1, 0, 1, 0, 2, 0, 1, 0, 1, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0.5, 1, 0, 1, 1, 1, 1,
              1, 0, 0, 2, 0, 0, 0, 2, 0, 0, 0, 2, 1, 0, 0, 0, 0, 1, 0, 1, 1,
              0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1.5, 1, 1, 0, 0, 0, 0, 1, 0,
              1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0,
              0, 2, 0, 1, 1, 0, 1, 0, 0, 0, 2, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,
              0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 3, 1, 0, 1,
              0, 0, 3, 1, 1, 1, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2,
              0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1, 2, 0, 1, 0, 0, 1,
              1, 2, 0, 0, 2, 0, 0, 1, 0, 0, 0, 1, 1, 0, 2, 1, 0, 0, 0, 0, 0,
              0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
              0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 2.5, 0, 0, 0, 0, 0, 1, 0, 0, 0,
              0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 2, 0, 1, 1, 1, 0, 0, 1, 1, 3,
              1, 0, 0, 0, 0, 0, 3, 0, 2, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 1
            ],
            "seqs": [],
            "peaks": [
              {
                "center": 0,
                "spread": 225,
                "sites": 210,
                "log_adj_pvalue": -0.00122054
              }
            ]
          }, {
            "db": 0,
            "id": "MA0091.1",
            "alt": "TAL1::TCF3",
            "consensus": "NSAMCATCTGKT",
            "len": 12,
            "motif_evalue": "0.0e+000",
            "motif_nsites": 44,
            "n_tested": 491,
            "score_threshold": 13.6778,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0091.1&rm=present&collection=CORE",
            "pwm": [
              [
                0.295329, 0.318014, 0.181959, 0.204625, 3.47521e-09,
                3.47521e-09, 5.05711e-07, 3.52982e-05, 3.52982e-05,
                5.05711e-07, 3.47521e-09, 3.47521e-09
              ], [
                0.204626, 0.227312, 0.454068, 0.113923, 3.47521e-09,
                3.47521e-09, 5.05711e-07, 3.52982e-05, 3.52982e-05,
                5.05711e-07, 3.47521e-09, 3.47521e-09
              ], [
                0.884897, 0.000553707, 0.068581, 0.0458962, 3.47521e-09,
                3.47521e-09, 5.05711e-07, 3.52982e-05, 3.52982e-05,
                5.05711e-07, 3.47521e-09, 3.47521e-09
              ], [
                0.454059, 0.544772, 0.000553707, 0.000544269, 3.47521e-09,
                3.47521e-09, 5.05711e-07, 3.52982e-05, 3.52982e-05,
                5.05711e-07, 3.47521e-09, 3.47521e-09
              ], [
                0.000544269, 0.975611, 0.0232292, 0.000544269, 3.47521e-09,
                3.47521e-09, 5.05711e-07, 3.52982e-05, 3.52982e-05,
                5.05711e-07, 3.47521e-09, 3.47521e-09
              ], [
                0.998277, 0.000553707, 0.000553707, 0.000544269, 3.47521e-09,
                3.47521e-09, 5.05711e-07, 3.52982e-05, 3.52982e-05,
                5.05711e-07, 3.47521e-09, 3.47521e-09
              ], [
                0.000544269, 0.0232292, 0.249987, 0.726168, 3.47521e-09,
                3.47521e-09, 5.05711e-07, 3.52982e-05, 3.52982e-05,
                5.05711e-07, 3.47521e-09, 3.47521e-09
              ], [
                0.272653, 0.726178, 0.000553707, 0.000544269, 3.47521e-09,
                3.47521e-09, 5.05711e-07, 3.52982e-05, 3.52982e-05,
                5.05711e-07, 3.47521e-09, 3.47521e-09
              ], [
                0.000544269, 0.000553707, 0.000553707, 0.998277, 3.47521e-09,
                3.47521e-09, 5.05711e-07, 3.52982e-05, 3.52982e-05,
                5.05711e-07, 3.47521e-09, 3.47521e-09
              ], [
                0.000544269, 0.000553707, 0.975611, 0.0232197, 3.47521e-09,
                3.47521e-09, 5.05711e-07, 3.52982e-05, 3.52982e-05,
                5.05711e-07, 3.47521e-09, 3.47521e-09
              ], [
                0.000544269, 0.0685811, 0.454068, 0.476735, 3.47521e-09,
                3.47521e-09, 5.05711e-07, 3.52982e-05, 3.52982e-05,
                5.05711e-07, 3.47521e-09, 3.47521e-09
              ], [
                0.0912471, 0.0912566, 0.0459056, 0.771519, 3.47521e-09,
                3.47521e-09, 5.05711e-07, 3.52982e-05, 3.52982e-05,
                5.05711e-07, 3.47521e-09, 3.47521e-09
              ]
            ],
            "total_sites": 57,
            "sites": [
              0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
              0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 1,
              0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0,
              0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
              0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0,
              0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
              0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0
            ],
            "seqs": [],
            "peaks": [
              {
                "center": 0,
                "spread": 239,
                "sites": 57,
                "log_adj_pvalue": 0
              }
            ]
          }, {
            "db": 0,
            "id": "MA0035.2",
            "alt": "Gata1",
            "consensus": "DSAGATAAGVV",
            "len": 11,
            "motif_evalue": "0.0e+000",
            "motif_nsites": 4000,
            "n_tested": 411,
            "score_threshold": 14.7818,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0035.2&rm=present&collection=CORE",
            "pwm": [
              [
                0.355747, 0.140003, 0.310498, 0.193751, 3.83132e-11,
                3.83132e-11, 5.57533e-09, 3.89152e-07, 3.89152e-07,
                5.57533e-09, 3.83132e-11, 3.83132e-11
              ], [
                0.177002, 0.408246, 0.308748, 0.106003, 3.83132e-11,
                3.83132e-11, 5.57533e-09, 3.89152e-07, 3.89152e-07,
                5.57533e-09, 3.83132e-11, 3.83132e-11
              ], [
                0.695489, 0.00775591, 0.00250604, 0.294249, 3.83132e-11,
                3.83132e-11, 5.57533e-09, 3.89152e-07, 3.89152e-07,
                5.57533e-09, 3.83132e-11, 3.83132e-11
              ], [
                6.00042e-06, 6.10446e-06, 0.999981, 6.00042e-06, 3.83132e-11,
                3.83132e-11, 5.57533e-09, 3.89152e-07, 3.89152e-07,
                5.57533e-09, 3.83132e-11, 3.83132e-11
              ], [
                0.999981, 6.10446e-06, 6.10446e-06, 6.00042e-06, 3.83132e-11,
                3.83132e-11, 5.57533e-09, 3.89152e-07, 3.89152e-07,
                5.57533e-09, 3.83132e-11, 3.83132e-11
              ], [
                0.00675583, 0.00725592, 0.0272554, 0.958732, 3.83132e-11,
                3.83132e-11, 5.57533e-09, 3.89152e-07, 3.89152e-07,
                5.57533e-09, 3.83132e-11, 3.83132e-11
              ], [
                0.971732, 6.10446e-06, 0.00150607, 0.0267553, 3.83132e-11,
                3.83132e-11, 5.57533e-09, 3.89152e-07, 3.89152e-07,
                5.57533e-09, 3.83132e-11, 3.83132e-11
              ], [
                0.887484, 0.00100608, 0.0957537, 0.0157556, 3.83132e-11,
                3.83132e-11, 5.57533e-09, 3.89152e-07, 3.89152e-07,
                5.57533e-09, 3.83132e-11, 3.83132e-11
              ], [
                0.199751, 0.170252, 0.573992, 0.0560046, 3.83132e-11,
                3.83132e-11, 5.57533e-09, 3.89152e-07, 3.89152e-07,
                5.57533e-09, 3.83132e-11, 3.83132e-11
              ], [
                0.357997, 0.22425, 0.339998, 0.0777541, 3.83132e-11,
                3.83132e-11, 5.57533e-09, 3.89152e-07, 3.89152e-07,
                5.57533e-09, 3.83132e-11, 3.83132e-11
              ], [
                0.371747, 0.207251, 0.274749, 0.146252, 3.83132e-11,
                3.83132e-11, 5.57533e-09, 3.89152e-07, 3.89152e-07,
                5.57533e-09, 3.83132e-11, 3.83132e-11
              ]
            ],
            "total_sites": 6,
            "sites": [
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0
            ],
            "seqs": [],
            "peaks": [
              {
                "center": 0,
                "spread": 267,
                "sites": 6,
                "log_adj_pvalue": 0
              }
            ]
          }, {
            "db": 0,
            "id": "MA0443.1",
            "alt": "btd",
            "consensus": "RRGGGGCGKR",
            "len": 10,
            "motif_evalue": "0.0e+000",
            "motif_nsites": 30,
            "n_tested": 174,
            "score_threshold": 11.7778,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0443.1&rm=present&collection=CORE",
            "pwm": [
              [
                0.465914, 0.100479, 0.233369, 0.200133, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.333023, 0.000811245, 0.665263, 0.000797418, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.133687, 0.000811245, 0.598818, 0.266578, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.0672429, 0.000811245, 0.931043, 0.000797418, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.000797418, 0.000811245, 0.997489, 0.000797418, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.000797418, 0.000811245, 0.997489, 0.000797418, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.0672429, 0.931043, 0.000811245, 0.000797418, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.000797418, 0.000811245, 0.997489, 0.000797418, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.000797418, 0.000811245, 0.665263, 0.333023, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.499137, 0.0340335, 0.333037, 0.133688, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ]
            ],
            "total_sites": 49,
            "sites": [
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
              0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 1, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 2, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
              0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
              0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0
            ],
            "seqs": [],
            "peaks": [
              {
                "center": 0,
                "spread": 213,
                "sites": 49,
                "log_adj_pvalue": -2.77644e-05
              }
            ]
          }, {
            "db": 1,
            "id": "MA0039.1",
            "alt": "Klf4",
            "consensus": "WARRGRAAGG",
            "len": 10,
            "motif_evalue": "0.0e+000",
            "motif_nsites": 49,
            "n_tested": 441,
            "score_threshold": 13.2527,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0039.1&rm=present&collection=CORE",
            "pwm": [
              [
                0.367088, 0.183796, 0.0412302, 0.407821, 3.12132e-09,
                3.12132e-09, 4.54213e-07, 3.17036e-05, 3.17036e-05,
                4.54213e-07, 3.12132e-09, 3.12132e-09
              ], [
                0.672587, 0.000497321, 0.265263, 0.0615882, 3.12132e-09,
                3.12132e-09, 4.54213e-07, 3.17036e-05, 3.17036e-05,
                4.54213e-07, 3.12132e-09, 3.12132e-09
              ], [
                0.611488, 0.0615967, 0.305996, 0.0208553, 3.12132e-09,
                3.12132e-09, 4.54213e-07, 3.17036e-05, 3.17036e-05,
                4.54213e-07, 3.12132e-09, 3.12132e-09
              ], [
                0.468921, 0.0208638, 0.387463, 0.122688, 3.12132e-09,
                3.12132e-09, 4.54213e-07, 3.17036e-05, 3.17036e-05,
                4.54213e-07, 3.12132e-09, 3.12132e-09
              ], [
                0.265255, 0.122697, 0.591129, 0.0208553, 3.12132e-09,
                3.12132e-09, 4.54213e-07, 3.17036e-05, 3.17036e-05,
                4.54213e-07, 3.12132e-09, 3.12132e-09
              ], [
                0.407821, 0.0819641, 0.468929, 0.0412217, 3.12132e-09,
                3.12132e-09, 4.54213e-07, 3.17036e-05, 3.17036e-05,
                4.54213e-07, 3.12132e-09, 3.12132e-09
              ], [
                0.733686, 0.081964, 0.10233, 0.0819555, 3.12132e-09,
                3.12132e-09, 4.54213e-07, 3.17036e-05, 3.17036e-05,
                4.54213e-07, 3.12132e-09, 3.12132e-09
              ], [
                0.65222, 0.0412302, 0.265263, 0.0412218, 3.12132e-09,
                3.12132e-09, 4.54213e-07, 3.17036e-05, 3.17036e-05,
                4.54213e-07, 3.12132e-09, 3.12132e-09
              ], [
                0.265255, 0.0208638, 0.672595, 0.0412218, 3.12132e-09,
                3.12132e-09, 4.54213e-07, 3.17036e-05, 3.17036e-05,
                4.54213e-07, 3.12132e-09, 3.12132e-09
              ], [
                0.0412217, 0.0208638, 0.937361, 0.000488845, 3.12132e-09,
                3.12132e-09, 4.54213e-07, 3.17036e-05, 3.17036e-05,
                4.54213e-07, 3.12132e-09, 3.12132e-09
              ]
            ],
            "total_sites": 2,
            "sites": [
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0
            ],
            "seqs": [],
            "peaks": [
              {
                "center": 0,
                "spread": 290,
                "sites": 2,
                "log_adj_pvalue": 0
              }
            ]
          }, {
            "db": 1,
            "id": "MA0443.1",
            "alt": "btd",
            "consensus": "RRGGGGCGKR",
            "len": 10,
            "motif_evalue": "0.0e+000",
            "motif_nsites": 30,
            "n_tested": 174,
            "score_threshold": 11.7778,
            "url": "http://jaspar.genereg.net/cgi-bin/jaspar_db.pl?ID=MA0443.1&rm=present&collection=CORE",
            "pwm": [
              [
                0.465914, 0.100479, 0.233369, 0.200133, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.333023, 0.000811245, 0.665263, 0.000797418, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.133687, 0.000811245, 0.598818, 0.266578, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.0672429, 0.000811245, 0.931043, 0.000797418, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.000797418, 0.000811245, 0.997489, 0.000797418, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.000797418, 0.000811245, 0.997489, 0.000797418, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.0672429, 0.931043, 0.000811245, 0.000797418, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.000797418, 0.000811245, 0.997489, 0.000797418, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.000797418, 0.000811245, 0.665263, 0.333023, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ], [
                0.499137, 0.0340335, 0.333037, 0.133688, 5.09158e-09,
                5.09158e-09, 7.40926e-07, 5.17159e-05, 5.17159e-05,
                7.40926e-07, 5.09158e-09, 5.09158e-09
              ]
            ],
            "total_sites": 49,
            "sites": [
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
              0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 1, 1, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 2, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0,
              0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 2, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0,
              0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
              0, 0, 0, 0, 0, 0, 0, 0
            ],
            "seqs": [],
            "peaks": [
              {
                "center": 0,
                "spread": 213,
                "sites": 49,
                "log_adj_pvalue": -2.77644e-05
              }
            ]
          }, {
            "db": 2,
            "id": "TGCmGC",
            "alt": "GC1GCA",
            "consensus": "TGCmGC",
            "len": 6,
            "motif_evalue": "0.0e+000",
            "motif_nsites": 20,
            "n_tested": 3,
            "score_threshold": 6.46479,
            "pwm": [
              [
                0.00119414, 0.00121485, 0.00121485, 0.996219, 7.62471e-09,
                7.62471e-09, 1.10955e-06, 7.74452e-05, 7.74452e-05,
                1.10955e-06, 7.62471e-09, 7.62471e-09
              ], [
                0.00119414, 0.00121485, 0.99624, 0.00119414, 7.62471e-09,
                7.62471e-09, 1.10955e-06, 7.74452e-05, 7.74452e-05,
                1.10955e-06, 7.62471e-09, 7.62471e-09
              ], [
                0.00119414, 0.99624, 0.00121485, 0.00119414, 7.62471e-09,
                7.62471e-09, 1.10955e-06, 7.74452e-05, 7.74452e-05,
                1.10955e-06, 7.62471e-09, 7.62471e-09
              ], [
                0.00119414, 0.00121485, 0.00121485, 0.00119414, 7.62471e-09,
                7.62471e-09, 1.10955e-06, 0.995102, 7.74452e-05, 1.10955e-06,
                7.62471e-09, 7.62471e-09
              ], [
                0.00119414, 0.00121485, 0.99624, 0.00119414, 7.62471e-09,
                7.62471e-09, 1.10955e-06, 7.74452e-05, 7.74452e-05,
                1.10955e-06, 7.62471e-09, 7.62471e-09
              ], [
                0.00119414, 0.99624, 0.00121485, 0.00119414, 7.62471e-09,
                7.62471e-09, 1.10955e-06, 7.74452e-05, 7.74452e-05,
                1.10955e-06, 7.62471e-09, 7.62471e-09
              ]
            ],
            "total_sites": 375,
            "sites": [
              0.5, 1, 1, 0, 2, 0, 1, 0, 1, 0.5, 0, 0, 1, 0.666667, 0.5, 0, 1,
              0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1.5, 0, 0,
              1.5, 1, 3, 1, 1, 2, 0, 0, 0, 0, 0, 0, 1, 0.5, 0, 0.5, 0, 0, 0,
              0, 0.5, 1, 0, 0, 0, 1, 1, 1, 0.5, 1, 0, 0, 0, 0, 0, 0, 0, 0,
              0.5, 0.333333, 0, 1, 2, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 2, 1, 1,
              3, 0, 0, 0, 0, 1, 1, 0, 0, 2, 0, 0, 0, 0, 0, 0, 0.5, 0, 0.5, 0,
              0, 0, 0, 0, 0, 0, 1, 0, 1.5, 2.5, 1, 1, 2, 1, 0.5, 2, 0, 0, 1.5,
              0, 1, 1, 1, 1, 1, 1, 0, 2, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 1,
              0, 1, 1, 0, 1.5, 1, 0, 0, 0.5, 1, 0, 0, 1, 0, 2, 0, 2.5, 2, 0,
              1, 1, 0, 0.5, 2, 1, 1, 1.5, 0, 1, 0, 1, 4, 0, 3.5, 3, 1, 1.5, 0,
              0, 0, 0, 1.33333, 1.5, 2, 0, 0, 0, 0, 0, 0, 3, 0, 2, 2.33333, 2,
              0, 0, 2, 2, 0.5, 0, 0, 2, 1, 2, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0,
              3.25, 0, 1.5, 1.5, 3.5, 2, 2, 2, 0, 1, 1.5, 1, 2.5, 0, 3, 0.5,
              1.33333, 2, 2.5, 1.75, 0, 3, 2, 2, 0, 0, 2, 1.5, 0, 1, 4.33333,
              0, 1.5, 1, 1, 0, 3, 0, 1, 1, 2.33333, 1, 3, 0, 0, 2, 0, 2, 3.75,
              0, 4, 1, 0, 2, 1.5, 1, 0, 1.5, 1.08333, 0.5, 3, 1.33333, 1, 0,
              3.5, 2, 2, 1, 0, 2.5, 2, 1, 1, 0, 0, 1, 0.333333, 1.5, 2.5, 1,
              2, 0, 1, 0, 1, 2, 1, 2.5, 0, 2, 1, 0, 2.5, 1, 1.5, 1, 1.5, 2, 1,
              0, 0, 2, 0, 0, 0, 0, 0, 0.5, 1, 1, 1, 0.5, 1, 0, 0, 1, 2, 1,
              0.5, 0.5, 0, 2, 0, 0, 1, 3, 2, 1, 1, 0, 1, 1.5, 1, 1, 0,
              1.33333, 0.5, 0, 1, 0, 1, 2, 0, 1.5, 0, 0, 1, 2, 1, 0, 0.5, 2,
              0, 0, 0, 1.5, 1.5, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0,
              1.5, 0, 1, 2, 1, 2.5, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1,
              0, 0, 0, 0, 0, 0.5, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0,
              1, 0, 0, 2, 0, 0, 0, 2, 0, 2, 0, 0, 0, 2, 2, 0, 0, 1, 1, 1, 0,
              0, 1, 0, 0, 1, 1.5, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0,
              0.5, 1, 0, 1, 0, 0, 1, 3, 0, 0, 0, 1, 0.5
            ],
            "seqs": [],
            "peaks": [
              {
                "center": 0,
                "spread": 196,
                "sites": 375,
                "log_adj_pvalue": -25.5493
              }
            ]
          }, {
            "db": 2,
            "id": "TGCm1C",
            "alt": "Gm1GCA",
            "consensus": "TGCm1C",
            "len": 6,
            "motif_evalue": "0.0e+000",
            "motif_nsites": 20,
            "n_tested": 4,
            "score_threshold": 6.49296,
            "pwm": [
              [
                0.00119414, 0.00121485, 0.00121485, 0.996219, 7.62471e-09,
                7.62471e-09, 1.10955e-06, 7.74452e-05, 7.74452e-05,
                1.10955e-06, 7.62471e-09, 7.62471e-09
              ], [
                0.00119414, 0.00121485, 0.99624, 0.00119414, 7.62471e-09,
                7.62471e-09, 1.10955e-06, 7.74452e-05, 7.74452e-05,
                1.10955e-06, 7.62471e-09, 7.62471e-09
              ], [
                0.00119414, 0.99624, 0.00121485, 0.00119414, 7.62471e-09,
                7.62471e-09, 1.10955e-06, 7.74452e-05, 7.74452e-05,
                1.10955e-06, 7.62471e-09, 7.62471e-09
              ], [
                0.00119414, 0.00121485, 0.00121485, 0.00119414, 7.62471e-09,
                7.62471e-09, 1.10955e-06, 0.995102, 7.74452e-05, 1.10955e-06,
                7.62471e-09, 7.62471e-09
              ], [
                0.00119414, 0.00121485, 0.00121485, 0.00119414, 7.62471e-09,
                7.62471e-09, 1.10955e-06, 7.74452e-05, 0.995102, 1.10955e-06,
                7.62471e-09, 7.62471e-09
              ], [
                0.00119414, 0.99624, 0.00121485, 0.00119414, 7.62471e-09,
                7.62471e-09, 1.10955e-06, 7.74452e-05, 7.74452e-05,
                1.10955e-06, 7.62471e-09, 7.62471e-09
              ]
            ],
            "total_sites": 999,
            "sites": [
              1.33333, 0.5, 0.583333, 0, 0.5, 1.5, 1.33333, 2.5, 1, 0.5, 3,
              1.2, 4.7, 2.5, 1, 0.333333, 1.33333, 0, 0.5, 1.83333, 2.5, 1.5,
              2, 2.33333, 0.5, 3.33333, 0.333333, 2.33333, 0.5, 0, 2.33333,
              0.833333, 1.5, 1.5, 2.86667, 0, 0, 1, 0.583333, 3.25, 1.75, 1.5,
              3, 0, 2.66667, 1.83333, 0.833333, 1, 1, 0.5, 2.16667, 1, 1,
              0.333333, 0.5, 0, 1, 1.83333, 2.83333, 2.5, 0.5, 0.5, 1, 3.2,
              3.5, 0.666667, 1.5, 0, 2.33333, 1.5, 2.58333, 1, 4, 0, 0, 1.2,
              1, 1, 1, 3, 0.333333, 1, 0.333333, 1.5, 0.833333, 2, 1, 0, 1.5,
              1.25, 3, 1.5, 2.33333, 3.33333, 1, 1.5, 2, 1.5, 1.33333, 2,
              0.333333, 2.83333, 3.33333, 4, 2.2, 0.75, 0, 1.5, 1.33333, 1,
              0.666667, 1.5, 0, 0.25, 0.833333, 0, 1, 0.25, 2.33333, 0, 0,
              2.83333, 2, 3.5, 1.5, 4.33333, 1.2, 2, 2, 1.25, 0, 2, 2.83333,
              2, 1.66667, 1.83333, 3, 2.83333, 1.33333, 0, 4.5, 2.95, 4,
              1.16667, 2, 2, 5.33333, 1.5, 0.2, 3, 1.14286, 1, 1.33333, 0,
              1.7, 2.5, 2.33333, 1, 4, 1, 2, 1, 1.33333, 2.5, 4.25, 2.33333,
              2.2, 3.58333, 0.333333, 4.33333, 2, 1.5, 1.33333, 2.75, 1.16667,
              1.5, 1.5, 5.41667, 5, 2.25, 1.95, 4.33333, 3.5, 2.5, 5.5, 2.5,
              1, 3.5, 2.5, 4.5, 3.03333, 4.16667, 1.5, 4.75, 2.41667, 4.08333,
              4, 2.75, 3.25, 1, 1, 2.83333, 2.83333, 4.33333, 3.33333, 4,
              4.03333, 3.5, 0.25, 3, 1.75, 1.5, 2.58333, 1.25, 1, 3.5,
              2.73333, 4.5, 2.66667, 2.2, 2.41667, 2, 3.75, 1, 4.5, 2, 2.5,
              1.25, 1.83333, 3.5, 1.25, 1.7, 2.83333, 2.83333, 5.33333,
              4.83333, 4.33333, 3.5, 3, 6.75, 0.833333, 4.25, 3.16667,
              2.33333, 1.5, 3.16667, 4.75, 2, 5.75, 2.33333, 3.5, 2.33333,
              3.33333, 0.833333, 3.64286, 3.16667, 4.25, 2.66667, 2.66667,
              4.66667, 2.5, 1.64286, 3, 1, 2.5, 3.5, 1, 1.2, 3.61667, 4, 3.2,
              5, 3.5, 0, 2.25, 0, 3.2, 3.66667, 6, 3.33333, 1, 2, 1.33333, 1,
              1.33333, 2.16667, 2.58333, 2.33333, 1.75, 3, 5.28333, 1.5, 3.5,
              6, 5.33333, 5, 3.66667, 3.5, 5, 2.58333, 2.5, 5.86667, 1.83333,
              2.5, 2.83333, 1.5, 1.5, 2.33333, 0, 6.83333, 2.5, 2.53333,
              2.33333, 2.16667, 4.33333, 3.5, 3.5, 2.16667, 3.83333, 2.5, 1,
              5.33333, 1, 2.41667, 5, 5.53333, 2.83333, 4.2, 2.5, 2.25, 0.25,
              0.5, 4, 1.33333, 1, 2.75, 2, 3, 0.833333, 1.5, 2.5, 2.5,
              1.83333, 0.833333, 0.833333, 4, 2.83333, 2.75, 1, 1.33333, 3,
              2.5, 0, 1.5, 5.5, 3, 1, 2.5, 0, 3, 3.83333, 1.83333, 4, 2,
              1.33333, 2.33333, 1, 0.5, 1, 3.5, 1.5, 2.5, 3, 1.5, 2.83333,
              2.5, 0.2, 1.83333, 1, 0.5, 1.5, 2.25, 2.5, 0.583333, 5, 2.75,
              0.5, 1.75, 0.5, 1.33333, 3.64286, 1, 2.39286, 1.5, 1, 1,
              2.33333, 1.66667, 1.25, 0.833333, 0, 2, 1, 1, 1, 3.14286, 1.5,
              1.33333, 0.666667, 2, 1.2, 0.5, 0.2, 0, 0, 1, 2.5, 1.5, 2.33333,
              3, 0.4, 1.5, 0.666667, 3, 0.833333, 2, 1, 0.5, 1.5, 0.333333, 1,
              2, 0.5, 2.25, 1, 0.333333, 1.5, 1, 0, 2.33333, 3, 1.25, 3.5, 1,
              5.33333, 2.23333, 0.25, 0.583333, 1, 2, 2.08333, 4.33333, 0,
              0.5, 2.33333, 3.25, 2, 2.5, 3.14286, 1, 3.33333, 1.83333, 0.5,
              1, 0, 0, 2, 2, 2, 0, 1.5, 1.58333, 2, 0, 1, 1.53333, 0,
              0.333333, 1, 2, 2, 1, 0, 1, 3, 1.83333, 1.5, 0.833333, 1.33333,
              0, 0, 0.5, 1.75, 0.5, 0.333333
            ],
            "seqs": [],
            "peaks": [
              {
                "center": 0,
                "spread": 203,
                "sites": 999,
                "log_adj_pvalue": -47.4105
              }
            ]
          }
        ]
      };
    </script>
    <script type="text/javascript">
var site_url = "https://meme-suite.org/meme";

    </script>
    <script type="text/javascript">
/*
 * $
 *
 * Shorthand function for getElementById
 */
function $(el) {
  return document.getElementById(el);
}

/*
 * See http://stackoverflow.com/a/5450113/66387
 * Does string multiplication like the perl x operator.
 */
function string_mult(pattern, count) {
    if (count < 1) return '';
    var result = '';
    while (count > 1) {
        if (count & 1) result += pattern;
        count >>= 1, pattern += pattern;
    }
    return result + pattern;
}

/*
 * See http://stackoverflow.com/questions/814613/how-to-read-get-data-from-a-url-using-javascript
 * Slightly modified with information from
 * https://developer.mozilla.org/en/DOM/window.location
 */
function parse_params() {
  "use strict";
  var search, queryStart, queryEnd, query, params, nvPairs, i, nv, n, v;
  search = window.location.search;
  queryStart = search.indexOf("?") + 1;
  queryEnd   = search.indexOf("#") + 1 || search.length + 1;
  query      = search.slice(queryStart, queryEnd - 1);

  if (query === search || query === "") return {};

  params  = {};
  nvPairs = query.replace(/\+/g, " ").split("&");

  for (i = 0; i < nvPairs.length; i++) {
    nv = nvPairs[i].split("=");
    n  = decodeURIComponent(nv[0]);
    v  = decodeURIComponent(nv[1]);
    // allow a name to be used multiple times
    // storing each value in the array
    if (!(n in params)) {
      params[n] = [];
    }
    params[n].push(nv.length === 2 ? v : null);
  }
  return params;
}

/*
 * coords
 *
 * Calculates the x and y offset of an element.
 * From http://www.quirksmode.org/js/findpos.html
 * with alterations to take into account scrolling regions
 */
function coords(elem) {
  var myX = myY = 0;
  if (elem.getBoundingClientRect) {
    var rect;
    rect = elem.getBoundingClientRect();
    myX = rect.left + ((typeof window.pageXOffset !== "undefined") ?
        window.pageXOffset : document.body.scrollLeft);
    myY = rect.top + ((typeof window.pageYOffset !== "undefined") ?
        window.pageYOffset : document.body.scrollTop);
  } else {
    // this fall back doesn't properly handle absolutely positioned elements
    // inside a scrollable box
    var node;
    if (elem.offsetParent) {
      // subtract all scrolling
      node = elem;
      do {
        myX -= node.scrollLeft ? node.scrollLeft : 0;
        myY -= node.scrollTop ? node.scrollTop : 0;
      } while (node = node.parentNode);
      // this will include the page scrolling (which is unwanted) so add it back on
      myX += (typeof window.pageXOffset !== "undefined") ? window.pageXOffset : document.body.scrollLeft;
      myY += (typeof window.pageYOffset !== "undefined") ? window.pageYOffset : document.body.scrollTop;
      // sum up offsets
      node = elem;
      do {
        myX += node.offsetLeft;
        myY += node.offsetTop;
      } while (node = node.offsetParent);
    }
  }
  return [myX, myY];
}

/*
 * position_popup
 *
 * Positions a popup relative to an anchor element.
 *
 * The available positions are:
 * 0 - Centered below the anchor.
 */
function position_popup(anchor, popup, position) {
  "use strict";
  var a_x, a_y, a_w, a_h, p_x, p_y, p_w, p_h;
  var a_xy, spacer, margin, scrollbar, page_w;
  // define constants
  spacer = 5;
  margin = 15;
  scrollbar = 15;
  // define the positions and widths
  a_xy = coords(anchor);
  a_x = a_xy[0];
  a_y = a_xy[1];
  a_w = anchor.offsetWidth;
  a_h = anchor.offsetHeight;
  p_w = popup.offsetWidth;
  p_h = popup.offsetHeight;
  page_w = null;
  if (window.innerWidth) {
    page_w = window.innerWidth;
  } else if (document.body) {
    page_w = document.body.clientWidth;
  }
  // check the position type is defined
  if (typeof position !== "number") {
    position = 0;
  }
  // calculate the popup position
  switch (position) {
    case 1:
      p_x = a_x + a_w + spacer;
      p_y = a_y + (a_h / 2) - (p_h / 2);
      break;
    case 0:
    default:
      p_x = a_x + (a_w / 2) - (p_w / 2);
      p_y = a_y + a_h + spacer;
      break;
  }
  // constrain the popup position
  if (p_x < margin) {
    p_x = margin;
  } else if (page_w != null && (p_x + p_w) > (page_w - margin - scrollbar)) {
    p_x = page_w - margin - scrollbar - p_w;
  }
  if (p_y < margin) {
    p_y = margin;
  }
  // position the popup
  popup.style.left = p_x + "px";
  popup.style.top = p_y + "px";
}

function lookup_help_popup(popup_id) {
  var _body, pop, info;
  pop = document.getElementById(popup_id);
  if (pop == null) {
    _body = document.getElementsByTagName("body")[0];
    pop = document.createElement("div");
    pop.className = "pop_content";
    pop.id = popup_id;
    pop.style.backgroundColor = "#FFC";
    pop.style.borderColor = "black";
    info = document.createElement("p");
    info.style.fontWeight = "bold";
    info.appendChild(document.createTextNode("Error: No popup for topic \"" + popup_id + "\"."));
    pop.appendChild(info);
    // this might cause problems with the menu, but as this only happens
    // when something is already wrong I don't think that's too much of a problem
    _body.insertBefore(pop, _body.firstChild);
  }
  if (document.getElementsByTagName('body')[0].hasAttribute("data-autobtns")) {
    if (!/\bauto_buttons\b/.test(pop.className)) {
      pop.className += " auto_buttons";
      var back_btn_sec = document.createElement("div");
      back_btn_sec.className = "nested_only pop_back_sec";
      var back_btn = document.createElement("span");
      back_btn.className = "pop_back";
      back_btn.appendChild(document.createTextNode("<< back"));
      back_btn.addEventListener("click", function(e) {
        help_return();
      }, false);
      back_btn_sec.appendChild(back_btn);
      pop.insertBefore(back_btn_sec, pop.firstChild);
      var close_btn_sec = document.createElement("div");
      close_btn_sec.className = "pop_close_sec";
      var close_btn = document.createElement("span");
      close_btn.className = "pop_close";
      close_btn.appendChild(document.createTextNode("close"));
      close_btn.addEventListener("click", function(e) {
        help_popup();
      }, false);
      close_btn_sec.appendChild(close_btn);
      pop.appendChild(close_btn_sec);
    }
  }
  return pop;
}

/*
 * help_popup
 *
 * Moves around help pop-ups so they appear
 * below an activator.
 */
function help_popup(activator, popup_id) {
  "use strict";
  var pop;
  // set default values
  if (typeof help_popup.popup === "undefined") {
    help_popup.popup = [];
  }
  if (typeof help_popup.activator === "undefined") {
    help_popup.activator = null;
  }
  var last_pop = (help_popup.popup.length > 0 ? help_popup.popup[help_popup.popup.length - 1] : null);
  if (typeof(activator) == "undefined") { // no activator so hide
    if (last_pop != null) {
      last_pop.style.display = 'none';
      help_popup.popup = [];
    }
    return;
  }
  pop = lookup_help_popup(popup_id);
  if (pop == last_pop) {
    if (activator == help_popup.activator) {
      //hide popup (as we've already shown it for the current help button)
      last_pop.style.display = 'none';
      help_popup.popup = [];
      return; // toggling complete!
    }
  } else if (last_pop != null) {
    //activating different popup so hide current one
    last_pop.style.display = 'none';
  }
  help_popup.popup = [pop];
  help_popup.activator = activator;
  toggle_class(pop, "nested", false);
  //must make the popup visible to measure it or it has zero width
  pop.style.display = 'block';
  position_popup(activator, pop);
}

/*
 * help_refine
 * 
 * Intended for links within a help popup. Stores a stack of state so
 * you can go back.
 */
function help_refine(popup_id) {
  if (help_popup.popup == null || help_popup.popup.length == 0 || help_popup.activator == null) {
    //throw new Error("Cannot refine a help popup when one is not shown!");
    var pop = lookup_help_popup(popup_id);
    var act_id = popup_id + '_act';
    var activator = document.getElementById(act_id);
    help_popup(activator, popup_id);
  }
  var pop = lookup_help_popup(popup_id);
  var last_pop = help_popup.popup[help_popup.popup.length - 1];
  if (pop == last_pop) return; // slightly odd, but no real cause for alarm
  help_popup.popup.push(pop);
  toggle_class(pop, "nested", true);
  last_pop.style.display = "none";
  //must make the popup visible to measure it or it has zero width
  pop.style.display = "block";
  position_popup(help_popup.activator, pop);
}

/*
 * help_return
 * 
 * Intended for links within a help popup. Stores a stack of state so
 * you can go back.
 */
function help_return() {
  if (help_popup.popup == null || help_popup.popup.length == 0 || help_popup.activator == null) {
    throw new Error("Can not return to a earlier help popup when one is not shown!");
  }
  var last_pop = help_popup.popup.pop();
  last_pop.style.display = "none";
  var pop = (help_popup.popup.length > 0 ? help_popup.popup[help_popup.popup.length - 1] : null);
  if (pop != null) {
    toggle_class(pop, "nested", help_popup.popup.length > 1);
    pop.style.display = "block";
    position_popup(help_popup.activator, pop);
  } else {
    help_popup.activator = null;
  }
}

/*
 * update_scroll_pad
 *
 * Creates padding at the bottom of the page to allow
 * scrolling of anything into view.
 */
function update_scroll_pad() {
  var page, pad;
  page = (document.compatMode === "CSS1Compat") ? document.documentElement : document.body;
  pad = $("scrollpad");
  if (pad === null) {
    pad = document.createElement("div");
    pad.id = 'scrollpad';
    document.getElementsByTagName('body')[0].appendChild(pad);
  }
  pad.style.height = Math.abs(page.clientHeight - 100) + "px";
}

function substitute_classes(node, remove, add) {
  "use strict";
  var list, all, i, cls, classes;
  list = node.className.split(/\s+/);
  all = {};
  for (i = 0; i < list.length; i++) {
    if (list[i].length > 0) all[list[i]] = true;
  }
  for (i = 0; i < remove.length; i++) {
    if (all.hasOwnProperty(remove[i])) {
      delete all[remove[i]];
    }
  }
  for (i = 0; i < add.length; i++) {
    all[add[i]] = true;
  }
  classes = "";
  for (cls in all) {
    classes += cls + " ";
  }
  node.className = classes;
}

/*
 * toggle_class
 *
 * Adds or removes a class from the node. If the parameter 'enabled' is not 
 * passed then the existence of the class will be toggled, otherwise it will be
 * included if enabled is true.
 */
function toggle_class(node, cls, enabled) {
  var classes = node.className;
  var list = classes.replace(/^\s+/, '').replace(/\s+$/, '').split(/\s+/);
  var found = false;
  for (var i = 0; i < list.length; i++) {
    if (list[i] == cls) {
      list.splice(i, 1);
      i--;
      found = true;
    }
  }
  if (typeof enabled == "undefined") {
    if (!found) list.push(cls);
  } else {
    if (enabled) list.push(cls);
  }
  node.className = list.join(" ");
}

/*
 * find_child
 *
 * Searches child nodes in depth first order and returns the first it finds
 * with the className specified.
 * TODO replace with querySelector
 */
function find_child(node, className) {
  var pattern;
  if (node == null || typeof node !== "object") {
    return null;
  }
  if (typeof className === "string") {
    pattern = new RegExp("\\b" + className + "\\b");
  } else {
    pattern = className;
  }
  if (node.nodeType == Node.ELEMENT_NODE && 
      pattern.test(node.className)) {
    return node;
  } else {
    var result = null;
    for (var i = 0; i < node.childNodes.length; i++) {
      result = find_child(node.childNodes[i], pattern);
      if (result != null) break;
    }
    return result;
  }
}

/*
 * find_parent
 *
 * Searches parent nodes outwards from the node and returns the first it finds
 * with the className specified.
 */
function find_parent(node, className) {
  var pattern;
  pattern = new RegExp("\\b" + className + "\\b");
  do {
    if (node.nodeType == Node.ELEMENT_NODE && 
        pattern.test(node.className)) {
      return node;
    }
  } while (node = node.parentNode);
  return null;
}

/*
 * find_parent_tag
 *
 * Searches parent nodes outwards from the node and returns the first it finds
 * with the tag name specified. HTML tags should be specified in upper case.
 */
function find_parent_tag(node, tag_name) {
  do {
    if (node.nodeType == Node.ELEMENT_NODE && node.tagName == tag_name) {
      return node;
    }
  } while (node = node.parentNode);
  return null;
}

/*
 * __toggle_help
 *
 * Uses the 'topic' property of the this object to
 * toggle display of a help topic.
 *
 * This function is not intended to be called directly.
 */
function __toggle_help(e) {
  if (!e) e = window.event;
  if (e.type === "keydown") {
    if (e.keyCode !== 13 && e.keyCode !== 32) {
      return;
    }
    // stop a submit or something like that
    e.preventDefault();
  }

  help_popup(this, this.getAttribute("data-topic"));
}

function setup_help_button(button) {
  "use strict";
  var topic;
  if (button.hasAttribute("data-topic")) {
    topic = button.getAttribute("data-topic");
    if (document.getElementById(topic) != null) {
      button.tabIndex = "0"; // make keyboard selectable
      button.addEventListener("click", function() {
        help_popup(button, topic);
      }, false);
      button.addEventListener("keydown", function(e) {
        // toggle only on Enter or Spacebar, let other keys do their thing
        if (e.keyCode !== 13 && e.keyCode !== 32) return;
        // stop a submit or something like that
        e.preventDefault();
        help_popup(button, topic);
      }, false);
    } else {
      button.style.visibility = "hidden";
    }
  }
  button.className += " active";
}

/*
 * help_button
 *
 * Makes a help button for the passed topic.
 */
function help_button(topic) {
  var btn = document.createElement("div");
  btn.className = "help";
  btn.setAttribute("data-topic", topic);
  setup_help_button(btn);
  return btn;
}

/*
 * prepare_download
 *
 * Sets the attributes of a link to setup a file download using the given content.
 * If no link is provided then create one and click it.
 */
function prepare_download(content, mimetype, filename, link) {
  "use strict";
  // if no link is provided then create one and click it
  var click_link = false;
  if (!link) {
    link = document.createElement("a");
    click_link = true;
  }
  try {
    // Use a BLOB to convert the text into a data URL.
    // We could do this manually with a base 64 conversion.
    // This will only be supported on modern browsers,
    // hence the try block.
    var blob = new Blob([content], {type: mimetype});
    var reader = new FileReader();
    reader.onloadend = function() {
      // If we're lucky the browser will also support the download
      // attribute which will let us suggest a file name to save the link.
      // Otherwise it is likely that the filename will be unintelligible. 
      link.setAttribute("download", filename);
      link.href = reader.result;
      if (click_link) {
        // must add the link to click it
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    }
    reader.readAsDataURL(blob);
  } catch (error) {
    if (console && console.log) console.log(error);
    // probably an old browser
    link.href = "";
    link.visible = false;
  }
}

/*
 * add_cell
 *
 * Add a cell to the table row.
 */
function add_cell(row, node, cls, click_action) {
  var cell = row.insertCell(row.cells.length);
  if (node) cell.appendChild(node);
  if (cls && cls !== "") cell.className = cls;
  if (click_action) cell.addEventListener("click", click_action, false);
}

/*
 * add_header_cell
 *
 * Add a header cell to the table row.
 */
function add_header_cell(row, node, help_topic, cls, colspan) {
  var th = document.createElement("th");
  if (node) th.appendChild(node);
  if (help_topic && help_topic !== "") th.appendChild(help_button(help_topic));
  if (cls && cls !== "") th.className = cls;
  if (typeof colspan == "number" && colspan > 1) th.colSpan = colspan;
  row.appendChild(th);
}

/*
 * add_text_cell
 *
 * Add a text cell to the table row.
 */
function add_text_cell(row, text, cls, action) {
  var node = null;
  if (typeof(text) != 'undefined') node = document.createTextNode(text);
  add_cell(row, node, cls, action);
}

/*
 * add_text_header_cell
 *
 * Add a text header cell to the table row.
 */
function add_text_header_cell(row, text, help_topic, cls, action, colspan) {
  var node = null;
  if (typeof(text) != 'undefined') {
    var nbsp = (help_topic ? "\u00A0" : "");
    var str = "" + text;
    var parts = str.split(/\n/);
    if (parts.length === 1) {
      if (action) {
        node = document.createElement("span");
        node.appendChild(document.createTextNode(str + nbsp));
      } else {
        node = document.createTextNode(str + nbsp);
      }
    } else {
      node = document.createElement("span");
      for (var i = 0; i < parts.length; i++) {
        if (i !== 0) {
          node.appendChild(document.createElement("br"));
        }
        node.appendChild(document.createTextNode(parts[i]));
      }
    }
    if (action) {
      node.addEventListener("click", action, false);
      node.style.cursor = "pointer";
    }
  }
  add_header_cell(row, node, help_topic, cls, colspan);
}

function setup_help() {
  "use strict";
  var help_buttons, i;
  help_buttons = document.querySelectorAll(".help:not(.active)");
  for (i = 0; i < help_buttons.length; i++) {
    setup_help_button(help_buttons[i]);
  }
}

function setup_scrollpad() {
  "use strict";
  if (document.getElementsByTagName('body')[0].hasAttribute("data-scrollpad") && document.getElementById("scrollpad") == null) {
    window.addEventListener("resize", update_scroll_pad, false);
    update_scroll_pad();
  }
}

// anon function to avoid polluting global scope
(function() {
  "use strict";
  window.addEventListener("load", function load(evt) {
    window.removeEventListener("load", load, false);
    setup_help();
    setup_scrollpad();
  }, false);
})();

/*
 *  make_link
 *
 *  Creates a text node and if a URL is specified it surrounds it with a link.
 *  If the URL doesn't begin with "http://" it automatically adds it, as
 *  relative links don't make much sense in this context.
 */
function make_link(text, url) {
  var textNode = null;
  var link = null;
  if (typeof text !== "undefined" && text !== null) textNode = document.createTextNode(text);
  if (typeof url === "string") {
    if (url.indexOf("//") == -1) {
      url = "http://" + url;
    }
    link = document.createElement('a');
    link.href = url;
    if (textNode) link.appendChild(textNode);
    return link;
  }
  return textNode;
}

//
// Function to create an HTML paragraph describing the 
// MEME Suite background model source.
//
function make_background_source(title, source, text) {
  var paraNode = document.createElement("P");
  var titleNode = document.createElement("B");
  var textNode1 = document.createTextNode("\u00A0\u00A0\u00A0\u00A0" + title + ": ");
  titleNode.appendChild(textNode1);
  var source_text = ((source == "--motif--") ? "the (first) motif file" : (source == "--nrdb--") ? "an old version of the NCBI non-redundant database" : (source == "--uniform--") ? "the uniform model" : (source == "--query--") ? "the query file" : (source == "--sequences--") ? "built from the (primary) sequences" : (source == "--control--") ? "built from the control (negative) sequences" : ((source == "--negatives--") ? "built from the negative (control) sequences" : "the file '" + source + "'"));
  if (text) { return source_text; }
  var textNode2 = document.createTextNode(source_text);
  paraNode.appendChild(titleNode);
  paraNode.appendChild(textNode2);
  return paraNode;
}

// Function to create a help button
function make_help_button(container, help_topic) {
  container.appendChild(help_button(help_topic));
}

// Function to toggle display.
function change_display(id) {
  var element=document.getElementById(id);
  element.style.display=(element.style.display=='none') ? element.style.display='inline' : element.style.display='none';
}

    </script>
    <script type="text/javascript">
function rad2deg(rad) {
  return rad * 180 / Math.PI;
}

function parse_line_join(line_join) {
  line_join = line_join.toLowerCase();
  if (line_join == "bevel") {
    return 2;
  } else if (line_join == "round") {
    return 1;
  } else { // miter
    return 0;
  }
}

function parse_line_cap(line_cap) {
  line_cap = line_cap.toLowerCase();
  if (line_cap == "square") {
    return 2;
  } else if (line_cap == "round") {
    return 1;
  } else { // butt 
    return 0;
  }
}

function parse_text_align(text_align) {
  text_align = text_align.toLowerCase();
  if (text_align == "center") {
    return "center";
  } else if (text_align == "end" || text_align == "right") {
    return "right"; 
  } else { // start or left
    return "left";
  }
}

function parse_text_baseline(text_baseline) {
  text_baseline = text_baseline.toLowerCase();
  if (text_baseline == "top" || text_baseline == "hanging") {
    return "top";
  } else if (text_baseline == "middle") {
    return "middle";
  } else if (text_baseline == "bottom") {
    return "bottom";
  } else { // alphabetic or ideographic
    return "alphabetic";
  }
}

function parse_colour(colour) {
  var hex6_re = /^#([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])$/;
  var hex3_re = /^#([0-9a-f])([0-9a-f])([0-9a-f])$/;
  var rgb_re = /^\s*rgb\s*\(\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*\)\s*$/;
  var rgba_re = /^\s*rgba\s*\(\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*,\s*(\d{1,3})(%?)\s*\)\s*$/;
  if (colour == null || colour == "") {
    return {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  }
  colour = colour.replace(/^\s\s*/, '').replace(/\s\s*$/, ''); //trim
  colour = colour.toLowerCase();
  if (colour == "maroon") {// #800000
    return {'red': 128, 'green': 0, 'blue': 0, 'alpha': 255};
  } else if (colour == "red") { // #FF0000
    return {'red': 255, 'green': 0, 'blue': 0, 'alpha': 255};
  } else if (colour == "orange") { // FFA500
    return {'red': 255, 'green': 165, 'blue': 0, 'alpha': 255};
  } else if (colour == "yellow") { // #FFFF00
    return {'red': 255, 'green': 255, 'blue': 0, 'alpha': 255};
  } else if (colour == "olive") { // #808000
    return {'red': 128, 'green': 128, 'blue': 0, 'alpha': 255};
  } else if (colour == "purple") { // #800080
    return {'red': 128, 'green': 0, 'blue': 128, 'alpha': 255};
  } else if (colour == "fuchsia" || colour == "magenta") { // #FF00FF
    return {'red': 255, 'green': 0, 'blue': 255, 'alpha': 255};
  } else if (colour == "white") { // #FFFFFF
    return {'red': 255, 'green': 255, 'blue': 255, 'alpha': 255};
  } else if (colour == "lime") { // #00FF00
    return {'red': 0, 'green': 255, 'blue': 0, 'alpha': 255};
  } else if (colour == "green") { // #008000
    return {'red': 0, 'green': 128, 'blue': 0, 'alpha': 255};
  } else if (colour == "navy") { // #000080
    return {'red': 0, 'green': 0, 'blue': 128, 'alpha': 255};
  } else if (colour == "blue") { // #0000FF
    return {'red': 0, 'green': 0, 'blue': 255, 'alpha': 255};
  } else if (colour == "aqua" || colour == "cyan") { // #00FFFF
    return {'red': 0, 'green': 255, 'blue': 255, 'alpha': 255};
  } else if (colour == "teal") { // #008080
    return {'red': 0, 'green': 128, 'blue': 128, 'alpha': 255};
  } else if (colour == "black") { // #000000
    return {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  } else if (colour == "silver") { // #C0C0C0
    return {'red': 192, 'green': 192, 'blue': 192, 'alpha': 255};
  } else if (colour == "gray") { // #808080
    return {'red': 128, 'green': 128, 'blue': 128, 'alpha': 255};
  }
  var matches;
  matches = hex6_re.exec(colour);
  if (matches) {
    var red = parseInt(matches[1], 16);
    var green = parseInt(matches[2], 16);
    var blue = parseInt(matches[3], 16);
    return {'red': red, 'green': green, 'blue': blue, 'alpha': 255};
  }
  matches = hex3_re.exec(colour);
  if (matches) {
    var red = parseInt(matches[1] + matches[1], 16);
    var green = parseInt(matches[2] + matches[2], 16);
    var blue = parseInt(matches[3] + matches[3], 16);
    return {'red': red, 'green': green, 'blue': blue, 'alpha': 255};
  }
  matches = rgb_re.exec(colour);
  if (matches) {
    var red = parseInt(matches[1]);
    if (matches[2] == "%") red = Math.round((red * 255) / 100);
    var green = parseInt(matches[3]);
    if (matches[4] == "%") green = Math.round((green * 255) / 100);
    var blue = parseInt(matches[5]);
    if (matches[6] == "%") blue = Math.round((blue * 255) / 100);
    return {'red': red, 'green': green, 'blue': blue, 'alpha': 255};
  }
  matches = rgba_re.exec(colour);
  if (matches) {
    var red = parseInt(matches[1]);
    if (matches[2] == "%") red = Math.round((red * 255) / 100);
    var green = parseInt(matches[3]);
    if (matches[4] == "%") green = Math.round((green * 255) / 100);
    var blue = parseInt(matches[5]);
    if (matches[6] == "%") blue = Math.round((blue * 255) / 100);
    var alpha = parseInt(matches[7]);
    if (matches[8] == "%") alpha = Math.round((alpha * 255) / 100);
    return {'red': red, 'green': green, 'blue': blue, 'alpha': alpha};
  }
  // default to black
  throw new Error("Failed to parse colour: " + colour);
}

function colour_equals(colour1, colour2) {
  if (colour1.red != colour2.red) return false;
  if (colour1.green != colour2.green) return false;
  if (colour1.blue != colour2.blue) return false;
  if (colour1.alpha != colour2.alpha) return false;
  return true;
}

// splits a font string into words
function split_words(str) {
  var words = [];
  var start = -1;
  var space = /\s/;
  var single_quote = false;
  var double_quote = false;
  // read words
  for (var i = 0; i < str.length; i++) {
    if (start == -1) {
      if (!space.test(str.charAt(i))) {
        switch (str.charAt(i)) {
          case "'":
            single_quote = true;
            start = i + 1;
            break;
          case '"':
            double_quote = true;
            start = i + 1;
            break;
          default:
            start = i;
        }
      }
    } else {
      if (!single_quote && !double_quote) {
        if (space.test(str.charAt(i))) {
          var len = i - start;
          if (len > 0) words.push(str.substr(start, len));
          start = -1;
        } else if (str.charAt(i) == "'" || str.charAt(i) == '"') {
          throw new Error("Quote in the middle of an unquoted word!");
        }
      } else if (single_quote) {
        if (str.charAt(i) == "'") {
          var len = i - start;
          if (len > 0) words.push(str.substr(start, len));
          start = -1;
          single_quote = false;
        }
      } else if (double_quote) {
        if (str.charAt(i) == '"') {
          var len = i - start;
          if (len > 0) words.push(str.substr(start, len));
          start = -1;
          double_quote = false;
        }
      }
    }
  }
  if (start != -1) {
    if (single_quote || double_quote) throw new Error("Unterminated quoted region");
    words.push(str.substr(start));
  }
  return words;
}

function add_intercepts(ctx2d, eps_callback) {
  ctx2d.eps_callback = eps_callback;
  ctx2d.save = function() {
    this.eps_callback.save();
    Object.getPrototypeOf(this).save.call(this);
  };
  ctx2d.restore = function() {
    this.eps_callback.restore();
    Object.getPrototypeOf(this).restore.call(this);
  };
  ctx2d.beginPath = function() {
    this.eps_callback.beginPath();
    Object.getPrototypeOf(this).beginPath.call(this);
  };
  ctx2d.closePath = function() {
    this.eps_callback.closePath();
    Object.getPrototypeOf(this).closePath.call(this);
  };
  ctx2d.moveTo = function(x, y) {
    this.eps_callback.moveTo(x, y);
    Object.getPrototypeOf(this).moveTo.call(this, x, y);
  };
  ctx2d.lineTo = function(x, y) {
    this.eps_callback.lineTo(x, y);
    Object.getPrototypeOf(this).lineTo.call(this, x, y);
  };
  ctx2d.rect = function(x, y, w, h) {
    this.eps_callback.rect(x, y, w, h);
    Object.getPrototypeOf(this).rect.call(this, x, y, w, h);
  };
  ctx2d.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
    this.eps_callback.arc(x, y, radius, startAngle, endAngle, anticlockwise);
    Object.getPrototypeOf(this).arc.call(this, x, y, radius, startAngle, endAngle, anticlockwise);
  };
  ctx2d.arcTo = function(cpx1, cpy1, cpx2, cpy2, radius) {
    this.eps_callback.arcTo(cpx1, cpy1, cpx2, cpy2, radius);
    Object.getPrototypeOf(this).arcTo.call(this, cpx1, cpy1, cpx2, cpy2, radius);
  };
  ctx2d.quadraticArcTo = function(cpx, cpy, x, y) {
    this.eps_callback.quadraticArcTo(cpx, cpy, x, y);
    Object.getPrototypeOf(this).quadraticArcTo.call(this, cpx, cpy, x, y);
  };
  ctx2d.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
    this.eps_callback.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);
    Object.getPrototypeOf(this).bezierCurveTo.call(this, cp1x, cp1y, cp2x, cp2y, x, y);
  };
  ctx2d.stroke = function() {
    this.eps_callback.stroke();
    Object.getPrototypeOf(this).stroke.call(this);
  };
  ctx2d.fill = function() {
    this.eps_callback.fill();
    Object.getPrototypeOf(this).fill.call(this);
  };
  ctx2d.clip = function() {
    this.eps_callback.clip();
    Object.getPrototypeOf(this).clip.call(this);
  };
  ctx2d.fillRect = function(x, y, width, height) {
    this.eps_callback.fillRect(x, y, width, height);
    Object.getPrototypeOf(this).fillRect.call(this, x, y, width, height);
  };
  ctx2d.strokeRect = function(x, y, width, height) {
    this.eps_callback.strokeRect(x, y, width, height);
    Object.getPrototypeOf(this).strokeRect.call(this, x, y, width, height);
  };
  ctx2d.clearRect = function(x, y, width, height) {
    this.eps_callback.clearRect(x, y, width, height);
    Object.getPrototypeOf(this).clearRect.call(this, x, y, width, height);
  };
  ctx2d.fillText = function(string, x, y) {
    this.eps_callback.fillText(string, x, y);
    Object.getPrototypeOf(this).fillText.call(this, string, x, y);
  };
  ctx2d.translate = function(dx, dy) {
    this.eps_callback.translate(dx, dy);
    Object.getPrototypeOf(this).translate.call(this, dx, dy);
  };
  ctx2d.rotate = function(angle) {
    this.eps_callback.rotate(angle);
    Object.getPrototypeOf(this).rotate.call(this, angle);
  };
  ctx2d.scale = function(sx, sy) {
    this.eps_callback.scale(sx, sy);
    Object.getPrototypeOf(this).scale.call(this, sx, sy);
  };
  ctx2d.transform = function(m11, m12, m21, m22, dx, dy) {
    this.eps_callback.transform(m11, m12, m21, m22, dx, dy);
    Object.getPrototypeOf(this).transform.call(this, m11, m12, m21, m22, dx, dy);
  };
  ctx2d.setTransform = function(m11, m12, m21, m22, dx, dy) {
    this.eps_callback.setTransform(m11, m12, m21, m22, dx, dy);
    Object.getPrototypeOf(this).setTransform.call(this, m11, m12, m21, m22, dx, dy);
  };
}

var EpsState = function(copy) {
  // canvas vars
  this.activeStyle = {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  this.fillStyle = {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  this.strokeStyle = {'red': 0, 'green': 0, 'blue': 0, 'alpha': 255};
  this.lineWidth = 1.0;
  this.lineCap = 0;
  this.lineJoin = 0;
  this.miterLimit = 10.0;
  this.font = null;
  this.textAlign = "left";
  this.textBaseline = "alphabetic";
  if (copy) {
    this.activeStyle = copy.activeStyle;
    this.fillStyle = copy.fillStyle;
    this.strokeStyle = copy.strokeStyle;
    this.lineWidth = copy.lineWidth;
    this.lineCap = copy.lineCap;
    this.lineJoin = copy.lineJoin;
    this.miterLimit = copy.miterLimit;
    this.font = copy.font;
    this.textAlign = copy.textAlign;
    this.textBaseline = copy.textBaseline;
  }
};


var EpsContext = function(ctx, width, height) {
  var title = "Image Title";
  var creator = "Image Creator";
  var date = new Date();
  // private parameters
  this.ctx = ctx;
  this.width = width;
  this.height = height;
  this.stack = [];
  this.current_state = new EpsState();
  this.font_lookup = {};
  this.indent = "";
  this.eps_text = 
    "%!PS-Adobe-3.0 EPSF-3.0\n" + 
    "%%Title: " + title + "\n" + 
    "%%Creator: " + creator + "\n" +
    "%%CreationDate: " + date.toUTCString() + "\n" + 
    "%%BoundingBox: 0 0 " + (width * 0.75) + " " + (height * 0.75) + "\n" +
    "%%Pages: 0\n" +
    "%%DocumentFonts:\n" +
    "%%EndComments\n" +
    "0.75 0.75 scale\n" +
    "0 " + height + " translate\n" + 
    "1 -1 scale\n";
  add_intercepts(ctx, this);
};

// look for differences between the current state and the settings to see 
// what has changed. Apply the changes to the eps file.
EpsContext.prototype.detect = function() {
  var state = this.current_state;
  var ctx = this.ctx;
  if (ctx.lineWidth != state.lineWidth) {
    state.lineWidth = ctx.lineWidth;
    this.eps_text += this.indent + state.lineWidth + " setlinewidth\n";
  }
  var cap = parse_line_cap(ctx.lineCap);
  if (cap != state.lineCap) {
    state.lineCap = cap;
    this.eps_text += this.indent + state.lineCap + " setlinecap\n";
  }
  var join = parse_line_join(ctx.lineJoin);
  if (join != state.lineJoin) {
    state.lineJoin = join;
    this.eps_text += this.indent + state.lineJoin + " setlinejoin\n";
  }
  var miterLimit = parseInt(ctx.miterLimit);
  if (miterLimit != state.miterLimit) {
    state.miterLimit = miterLimit;
    this.eps_text += this.indent + state.miterLimit + " setmiterlimit\n";
  }
  var strokeStyle = parse_colour(ctx.strokeStyle);
  if (!colour_equals(strokeStyle, state.strokeStyle)) {
    state.strokeStyle = strokeStyle;
    this.activateStyle(false);
  }
  var fillStyle = parse_colour(ctx.fillStyle);
  if (!colour_equals(fillStyle, state.fillStyle)) {
    state.fillStyle = fillStyle;
    this.activateStyle(true);
  }
  var textAlign = parse_text_align(ctx.textAlign);
  if (textAlign != state.textAlign) {
    state.textAlign = textAlign;
  }
  var textBaseline = parse_text_baseline(ctx.textBaseline);
  if (textBaseline != state.textBaseline) {
    state.textBaseline = textBaseline;
  }
  var font = this.lookup_font(ctx.font);
  if (font != null && font !== state.font) {
    state.font = font;
    this.eps_text += this.indent + "/" + font.name + " findfont " +  
      font.size + " scalefont setfont\n";
  }
};

EpsContext.prototype.activateStyle = function(useFillStyle) {
  var state = this.current_state;
  var style = (useFillStyle ? state.fillStyle : state.strokeStyle);
  if (!colour_equals(state.activeStyle, style)) {
    this.eps_text += this.indent + (style.red / 255) + " " + 
      (style.green / 255) + " " + (style.blue / 255) + " setrgbcolor\n";
    state.activeStyle = style;
  }
};


// saves the current state on the stack
EpsContext.prototype.save = function() {
  this.detect();
  // gsave
  this.eps_text += this.indent + "gsave\n";
  this.stack.push(new EpsState(this.current_state));
  this.indent += "  ";
};

// restores the last saved state
EpsContext.prototype.restore = function() {
  if (this.stack.length == 0) throw new Error("Call to restore not matched with call to save.");
  this.detect();
  this.current_state = this.stack.pop();
  this.indent = Array(this.stack.length + 1).join("  ");
  // grestore
  this.eps_text += this.indent + "grestore\n";
};

// start a path
EpsContext.prototype.beginPath = function() {
  this.detect();
  // newpath
  this.eps_text += this.indent + "newpath\n";
};

// join the current position to the path start
EpsContext.prototype.closePath = function() {
  this.detect();
  // closepath
  this.eps_text += this.indent + "closepath\n";
};

// move the current position
EpsContext.prototype.moveTo = function(x, y) {
  this.detect();
  // moveto
  this.eps_text += this.indent + x + " " + y + " moveto\n";
};

// join the current position to a new position and update the current position
EpsContext.prototype.lineTo = function(x, y) {
  this.detect();
  // lineto
  this.eps_text += this.indent + x + " " + y + " lineto\n";
};

// add a rectangle to the path
EpsContext.prototype.rect = function(x, y, width, height) {
  this.moveTo(x, y);
  this.lineTo(x + width, y);
  this.lineTo(x + width, y + height);
  this.lineTo(x, y + height);
  this.closePath();
};

// add an arc to the path
EpsContext.prototype.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
  this.detect();
  if (anticlockwise) {
    // command "X Y RADIUS START_ANGLE END_ANGLE arc"
    this.eps_text += this.indent + x + " " + y + " " + radius + " " + rad2deg(startAngle) + " " + rad2deg(endAngle) + " arcn\n";
  } else {
    // command "X Y RADIUS START_ANGLE END_ANGLE arcn"
    this.eps_text += this.indent + x + " " + y + " " + radius + " " + rad2deg(startAngle) + " " + rad2deg(endAngle) + " arc\n";
  }
};

// imagine two lines, one going from the current position to point 1 and
// another going from point 1 to point 2. 
// Now imagine a circle of the given radius which touches the two lines at at 
// two tangental points T01 and T12. Add a line to the path that goes from
// the current position to T01 and add the arc which goes from T01 to T12.
// see http://www.dbp-consulting.com/tutorials/canvas/CanvasArcTo.html
EpsContext.prototype.arcTo = function(cpx1, cpy1, cpx2, cpy2, radius) {
  this.detect();
  // command "X1 Y1 X2 Y2 RADIUS arct"
  this.eps_text += this.indent + cpx1 + " " + cpy1 + " " + cpx2 + " " + cpy2 + " " + radius + " arct\n";
};

EpsContext.prototype.quadraticArcTo = function(cpx, cpy, x, y) {
  /* 
   For the equations below the following variable name prefixes are used: 
     qp0 is the quadratic curve starting point (you must keep this from your 
        last point sent to moveTo(), lineTo(), or bezierCurveTo() ). 
     qp1 is the quadratic curve control point (this is the cpx,cpy you would 
        have sent to quadraticCurveTo() ). 
     qp2 is the quadratic curve ending point (this is the x,y arguments you 
        would have sent to quadraticCurveTo() ). 
   We will convert these points to compute the two needed cubic control points 
    (the starting/ending points are the same for both 
   the quadratic and cubic curves. 
 
   The exact equations for the two cubic control points are: 
     cp0 = qp0 and cp3 = qp2 
     cp1 = qp0 + (qp1 - qp0) * ratio 
     cp2 = cp1 + (qp2 - qp0) * (1 - ratio) 
     where ratio = (sqrt(2) - 1) * 4 / 3 exactly (approx. 0.5522847498307933984022516322796) 
                   if the quadratic is an approximation of an elliptic arc, 
                      and the cubic must approximate the same arc, or 
           ratio = 2.0 / 3.0 for keeping the same quadratic curve. 
 
   In the code below, we must compute both the x and y terms for each point separately. 
 
    cp1x = qp0x + (qp1x - qp0x) * ratio; 
    cp1y = qp0y + (qp1y - qp0y) * ratio; 
    cp2x = cp1x + (qp2x - qp0x) * (1 - ratio); 
    cp2y = cp1y + (qp2y - qp0y) * (1 - ratio); 
 
   We will now  
     a) replace the qp0x and qp0y variables with currentX and currentY 
        (which *you* must store for each moveTo/lineTo/bezierCurveTo) 
     b) replace the qp1x and qp1y variables with cpx and cpy (which we would 
        have passed to quadraticCurveTo) 
     c) replace the qp2x and qp2y variables with x and y. 
   which leaves us with:  
  */  
  var ratio = 2.0 / 3.0; // 0.5522847498307933984022516322796 if the Bezier is 
                        // approximating an elliptic arc with best fitting  
  var cp1x = this.currentX + (cpx - this.currentX) * ratio;  
  var cp1y = this.currentY + (cpy - this.currentY) * ratio;  
  var cp2x = cp1x + (x - this.currentX) * (1 - ratio);  
  var cp2y = cp1y + (y - this.currentY) * (1 - ratio);  
  
  // and now call cubic Bezier curve to function   
  this.bezierCurveTo( cp1x, cp1y, cp2x, cp2y, x, y );
};

// add a bezier curve to the path
EpsContext.prototype.bezierCurveTo = function(cp1x, cp1y, cp2x, cp2y, x, y) {
  this.detect();
  // command "CP1X CP1Y CP2X CP2Y X Y curveto"
  this.eps_text += this.indent + cp1x + " " + cp1y + " " + cp2x + " " + cp2y + " " + x + " " + y + " curveto";
};

// stroke the current path
EpsContext.prototype.stroke = function() {
  this.detect();
  this.activateStyle(false);
  // stroke
  this.eps_text += this.indent + "stroke\n";
};

// fill the current path
EpsContext.prototype.fill = function() {
  this.detect();
  this.activateStyle(true);
  // fill
  this.eps_text += this.indent + "fill\n";
};

// create a clipping region from the current path
EpsContext.prototype.clip = function() {
  this.detect();
  // clip
  this.eps_text += this.indent + "clip\n";
};

// Draws a filled rectangle
EpsContext.prototype.fillRect = function(x, y, width, height) {
  this.detect();
  this.activateStyle(true);
  // rectfill
  this.eps_text += this.indent + x + " " + y + " " + width + " " + height + " rectfill\n";
};

// Draws a rectangular outline
EpsContext.prototype.strokeRect = function(x, y, width, height) {
  this.detect();
  this.activateStyle(false);
  // rectstroke
  this.eps_text += this.indent + x + " " + y + " " + width + " " + height + " rectstroke\n";
};

// Clears the specified area and makes it transparent.
EpsContext.prototype.clearRect = function(x, y, width, height) {
  this.detect();
  // fill a rectangle with white in the cleared region
  // EPS doesn't do transparency so this is as close as it can get
  // command "1 setgray X Y WIDTH HEIGHT rectfill"
  this.eps_text += this.indent + "gsave\n";
  this.eps_text += this.indent + "  1 setgray\n";
  this.eps_text += this.indent + "  " + x + " " + y + " " + width + " " + height + " rectfill\n";
  this.eps_text += this.indent + "grestore\n";
};

// Draws a filled string
EpsContext.prototype.fillText = function(string, x, y) {
  var state = this.current_state;
  this.detect();
  this.activateStyle(true);
  // lookup the font with "/FONT_NAME findfont" (leaves FONT on stack)
  // scale the font with "FONT SIZE scalefont" (leaves FONT on stack
  // set the font with "FONT setfont"
  // move the printing location with "X Y moveto"
  // various measurement commands will be needed to do center alignment etc
  // like "stringwidth"
  // show the text with "(STRING) show"
  string = string.replace(/\\/g, "\\\\");
  string = string.replace(/\(/g, "\\(");
  string = string.replace(/\)/g, "\\)");
  this.save();
  this.translate(x, y);
  this.scale(1, -1);
  this.eps_text += this.indent + "(" + string + ")\n";
  if (state.textBaseline != "alphabetic") {
    this.beginPath();
    this.moveTo(0,0);
    this.eps_text += this.indent + "dup true charpath flattenpath pathbbox %bounding box\n";
    this.eps_text += this.indent + "/ascent exch def pop /decent exch def pop\n";
    if (state.textBaseline == "top") {
      this.eps_text += this.indent + "0 ascent neg translate %vertical align top\n";
    } else if (state.textBaseline == "middle") {
      this.eps_text += this.indent + "0 ascent decent sub 2 div decent sub neg translate %vertical align middle\n";
    } else if (state.textBaseline == "bottom") {
      this.eps_text += this.indent + "0 decent neg translate %vertical align bottom\n";
    }
  }
  if (state.textAlign == "right") {
    this.eps_text += this.indent + "dup stringwidth pop neg 0 translate %right align\n"  
  } else if (state.textAlign == "center") {
    this.eps_text += this.indent + "dup stringwidth pop 2 div neg 0 translate %center align\n"  
  }
  this.moveTo(0,0);
  this.eps_text += this.indent + "show\n";
  this.restore();
};

// move the canvas origin
EpsContext.prototype.translate = function(dx, dy) {
  this.detect();
  // command "DELTA_X DELTA_Y translate"
  this.eps_text += this.indent + dx + " " + dy + " translate\n";
};

// rotate around the canvas origin
EpsContext.prototype.rotate = function(angle) {
  this.detect();
  // command "DEGREES rotate" (note need to convert angle from radians to degrees)
  this.eps_text += this.indent + rad2deg(angle) + " rotate\n";
};

// scale 
EpsContext.prototype.scale = function(scale_x, scale_y) {
  this.detect();
  // command "SCALE_X SCALE_Y scale
  this.eps_text += this.indent + scale_x + " " + scale_y + " scale\n";
};

// multiplies the current transform matrix by the matrix described by:
// m11    m21   dx
// m12    m22   dy
// 0      0     1
EpsContext.prototype.transform = function(m11, m12, m21, m22, dx, dy) {
  this.detect();
  // command "[M11 M12 M21 M22 DX DY] concat"
  this.eps_text += this.indent + "[" + m11 + " " + m12 + " " + m21 + " " + m22 + " " + dx + " " + dy + "] concat\n";
};

// reset transform matrix to the identity matrix then call transform
EpsContext.prototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
  // command:
  // "[1 0 0 1 0 0] defaultmatrix setmatrix 0 height translate 1 -1 scale "
  // "[M11 M12 M21 M22 DX DY] concat"
  this.eps_text += this.indent + "[1 0 0 1 0 0] defaultmatrix setmatrix\n";
  this.eps_text += this.indent + "0 " + this.height + " translate\n";
  this.eps_text += this.indent + "1 -1 scale\n";
  this.transform(m11, m12, m21, m22, dx, dy);
};

EpsContext.prototype.register_font = function(font_str, eps_font, size) {
  font_str = font_str.replace(/\s+/g, ""); // remove spaces
  font_str = font_str.toLowerCase(); // lower case
  this.font_lookup[font_str] = {'name': eps_font, 'size': size};
};

EpsContext.prototype.lookup_font = function(font_str) {
  font_str = font_str.replace(/\s+/g, ""); // remove spaces
  font_str = font_str.toLowerCase(); // lower case
  return this.font_lookup[font_str];
};

// return the EPS text
EpsContext.prototype.eps = function() {
  return this.eps_text + this.indent + "showpage\n";
};

    </script>
    <script type="text/javascript">
//======================================================================
// start Alphabet object
//======================================================================
var Alphabet = function(alphabet, background) {
  "use strict";
  var i, j, sym, aliases, complement, comp_e_sym, ambigs, generate_background;
  generate_background = (background == null);
  if (generate_background) {
    background = [];
    for (i = 0; i < alphabet.ncore; i++) background[i] = 1.0 / alphabet.ncore;
  } else if (alphabet.ncore != background.length) {
    throw new Error("The background length does not match the alphabet length.");
  }
  this.name = alphabet.name;
  this.like = (alphabet.like != null ? alphabet.like.toUpperCase() : null);
  this.ncore = alphabet.ncore;
  this.symbols = alphabet.symbols;
  this.background = background;
  this.genbg = generate_background;
  this.encode = {};
  this.encode2core = {};
  this.complement = {};
  // check if all symbols are same case
  var seen_uc = false;
  var seen_lc = false;
  var check_case = function (syms) {
    var s, sym;
    if (typeof syms === "string") {
      for (s = 0; s < syms.length; s++) {
        sym = syms.charAt(s);
        if (sym >= 'a' && sym <= 'z') seen_lc = true;
        else if (sym >= 'A' && sym <= 'Z') seen_uc = true;
      }
    }
  };
  for (i = 0; i < this.symbols.length; i++) {
    check_case(this.symbols[i].symbol);
    check_case(this.symbols[i].aliases);
  }
  // now map symbols to indexes
  var update_array = function(array, syms, index) {
    var s, sym;
    if (typeof syms === "string") {
      for (s = 0; s < syms.length; s++) {
        sym = syms.charAt(s);
        array[sym] = index;
        // when only a single case is used, then encode as case insensitive
        if (seen_uc != seen_lc) {
          if (sym >= 'a' && sym <= 'z') {
            array[sym.toUpperCase()] = index;
          } else if (sym >= 'A' && sym <= 'Z') {
            array[sym.toLowerCase()] = index;
          }
        }
      }
    }
  }
  // map core symbols to index
  for (i = 0; i < this.ncore; i++) {
    update_array(this.encode2core, this.symbols[i].symbol, i);
    update_array(this.encode, this.symbols[i].symbol, i);
    update_array(this.encode2core, this.symbols[i].aliases, i);
    update_array(this.encode, this.symbols[i].aliases, i);
  }
  // map ambiguous symbols to index
  ambigs = {};
  for (i = this.ncore; i < this.symbols.length; i++) {
    update_array(this.encode, this.symbols[i].symbol, i);
    update_array(this.encode, this.symbols[i].aliases, i);
    ambigs[this.symbols[i].equals] = i;
  }
  // determine complements
  for (i = 0; i < this.ncore; i++) {
    complement = this.symbols[i].complement;
    if (typeof complement === "string") {
      this.complement[i] = this.encode2core[complement];
    }
  }
  next_symbol:
  for (i = this.ncore; i < this.symbols.length; i++) {
    complement = "";
    for (j = 0; j < this.symbols[i].equals.length; j++) {
      comp_e_sym = this.complement[this.encode2core[this.symbols[i].equals.charAt(j)]];
      if (typeof comp_e_sym !== "number") continue next_symbol;
      complement += this.symbols[comp_e_sym].symbol;
    }
    complement = complement.split("").sort().join("");
    if (typeof ambigs[complement] === "number") {
      this.complement[i] = ambigs[complement];
    }
  }
  // determine case insensitivity
  this.case_insensitive = true;
  if (seen_uc == seen_lc) {
    // when there is a mixture of cases it probably won't
    // be case insensitive but we still need to check
    loop:
    for (i = 0; i < this.symbols.length; i++) {
      sym = this.symbols[i].symbol;
      if (sym >= 'A' && sym <= 'Z') {
        if (this.encode[sym.toLowerCase()] != i) {
          this.case_insensitive = false;
          break loop;
        }
      } else if (sym >= 'a' && sym <= 'z') {
        if (this.encode[sym.toUpperCase()] != i) {
          this.case_insensitive = false;
          break loop;
        }
      }
      aliases = this.symbols[i].aliases;
      if (aliases != null) {
        for (j = 0; j < aliases.length; j++) {
          sym = aliases.charAt(j);
          if (sym >= 'A' && sym <= 'Z') {
            if (this.encode[sym.toLowerCase()] != i) {
              this.case_insensitive = false;
              break loop;
            }
          } else if (sym >= 'a' && sym <= 'z') {
            if (this.encode[sym.toUpperCase()] != i) {
              this.case_insensitive = false;
              break loop;
            }
          }
        }
      }
    }
  }
  // normalise aliases to remove the prime symbol and eliminate
  // the alternate cases when the alphabet is case insensitive
  var seen, out;
  for (i = 0; i < this.symbols.length; i++) {
    sym = this.symbols[i].symbol;
    aliases = this.symbols[i].aliases;
    if (typeof aliases != "string") aliases = "";
    seen = {};
    out = [];
    if (this.case_insensitive) {
      sym = sym.toUpperCase();
      aliases = aliases.toUpperCase();
    }
    seen[sym] = true;
    for (j = 0; j < aliases.length; j++) {
      if (!seen[aliases.charAt(j)]) {
        seen[aliases.charAt(j)] = true;
        out.push(aliases.charAt(j));
      }
    }
    this.symbols[i].aliases = out.sort().join("");
  }
};
// return the name of the alphabet
Alphabet.prototype.get_alphabet_name = function() {
  return this.name;
};
// return if the alphabet can be complemented
Alphabet.prototype.has_complement = function() {
  return (typeof this.symbols[0].complement === "string");
};
// return true if an uppercase letter has the same meaning as the lowercase form
Alphabet.prototype.is_case_insensitive = function() {
  return this.case_insensitive;
};
// return the information content of an alphabet letter
Alphabet.prototype.get_ic = function() {
  return Math.log(this.ncore) / Math.LN2;
};
// return the count of the core alphabet symbols
Alphabet.prototype.get_size_core = function() {
  return this.ncore;
};
// return the count of all alphabet symbols
Alphabet.prototype.get_size_full = function() {
  return this.symbols.length;
};
// return the symbol for the given alphabet index
Alphabet.prototype.get_symbol = function(alph_index) {
  "use strict";
  if (alph_index < 0 || alph_index >= this.symbols.length) {
    throw new Error("Alphabet index out of bounds");
  }
  return this.symbols[alph_index].symbol;
};
// return the aliases for the given alphabet index
Alphabet.prototype.get_aliases = function(alph_index) {
  "use strict";
  if (alph_index < 0 || alph_index >= this.symbols.length) {
    throw new Error("Alphabet index out of bounds");
  }
  var sym_obj = this.symbols[alph_index];
  return (sym_obj.aliases != null ? sym_obj.aliases : "");
};
// return the name for the given alphabet index
Alphabet.prototype.get_name = function(alph_index) {
  "use strict";
  var sym;
  if (alph_index < 0 || alph_index >= this.symbols.length) {
    throw new Error("Alphabet index out of bounds");
  }
  sym = this.symbols[alph_index];
  return (typeof sym.name === "string" ? sym.name : sym.symbol);
};
// return the alphabet it is like or null
Alphabet.prototype.get_like = function() {
  "use strict";
  return this.like;
};
// return the index of the complement for the given alphabet index
Alphabet.prototype.get_complement = function(alph_index) {
  var comp_e_sym = this.complement[alph_index];
  if (typeof comp_e_sym === "number") {
    return comp_e_sym;
  } else {
    return -1;
  }
};
// return a string containing the core symbols
Alphabet.prototype.get_symbols = function() {
  "use strict";
  var i, core_symbols;
  core_symbols = "";
  for (i = 0; i < this.ncore; i++) {
    core_symbols += this.symbols[i].symbol;
  }
  return core_symbols;
};
// return if the background was not a uniform generated background
Alphabet.prototype.has_bg = function() {
  "use strict";
  return !this.genbg;
};
// get the background frequency for the index
Alphabet.prototype.get_bg_freq = function(alph_index) {
  "use strict";
  var freq, i, symbols;
  if (alph_index >= 0) {
    if (alph_index < this.ncore) {
      return this.background[alph_index];
    } else if (alph_index < this.symbols.length) {
      freq = 0;
      symbols = this.symbols[alph_index].equals;
      for (i = 0; i < symbols.length; i++) {
        freq += this.background[this.encode2core[symbols.charAt(i)]];
      }
      return freq;
    } 
  }
  throw new Error("The alphabet index is out of range.");
};
// get the colour of the index
Alphabet.prototype.get_colour = function(alph_index) {
  "use strict";
  if (alph_index < 0 || alph_index >= this.symbols.length) {
    throw new Error("BAD_ALPHABET_INDEX");
  }
  if (typeof this.symbols[alph_index].colour != "string") {
    return "black";
  }
  return "#" + this.symbols[alph_index].colour;
};
// get the rgb components of the colour at the index
Alphabet.prototype.get_rgb = function(alph_index) {
  "use strict";
  if (alph_index < 0 || alph_index >= this.symbols.length) {
    throw new Error("BAD_ALPHABET_INDEX");
  }
  if (typeof this.symbols[alph_index].colour != "string") {
    return {"red": 0, "green": 0, "blue": 0};
  }
  var colour = this.symbols[alph_index].colour;
  var red = parseInt(colour.substr(0, 2), 16) / 255;
  var green = parseInt(colour.substr(2, 2), 16) / 255;
  var blue = parseInt(colour.substr(4, 2), 16) / 255;
  return {"red": red, "green": green, "blue": blue};
};
// convert a symbol into the index
Alphabet.prototype.get_index = function(letter) {
  "use strict";
  var alph_index;
  alph_index = this.encode[letter];
  if (typeof alph_index === "undefined") {
    return -1;
  }
  return alph_index;
};
// convert a symbol into the list of core indexes that it equals
Alphabet.prototype.get_indexes = function(letter) {
  "use strict";
  var alph_index, comprise_str, i, comprise_list;
  alph_index = this.encode[letter];
  if (typeof alph_index === "undefined") {
    throw new Error("Unknown letter");
  }
  comprise_str = this.symbols[alph_index].equals;
  comprise_list = [];
  if (typeof comprise_str == "string") {
    for (i = 0; i < comprise_str.length; i++) {
      comprise_list.push(this.encode2core[comprise_str.charAt(i)]);
    }
  } else {
    comprise_list.push(alph_index);
  }
  return comprise_list;
};
// check if a symbol is the primary way of representing the symbol in the alphabet
Alphabet.prototype.is_prime_symbol = function(letter) {
  var alph_index;
  alph_index = this.encode[letter];
  if (alph_index == null) return false;
  if (this.is_case_insensitive()) {
    return (this.symbols[alph_index].symbol.toUpperCase() == letter.toUpperCase());
  } else {
    return (this.symbols[alph_index].symbol == letter);
  }
};
// compare 2 alphabets
Alphabet.prototype.equals = function(other) {
  "use strict";
  var i, sym1, sym2;
  // first check that it's actually an alphabet object
  if (!(typeof other === "object" && other != null && other instanceof Alphabet)) {
    return false;
  }
  // second shortcircuit if it's the same object
  if (this === other) return true;
  // compare
  if (this.name !== other.name) return false;
  if (this.ncore !== other.ncore) return false;
  if (this.symbols.length !== other.symbols.length) return false;
  for (i = 0; i < this.symbols.length; i++) {
    sym1 = this.symbols[i];
    sym2 = other.symbols[i];
    if (sym1.symbol !== sym2.symbol) return false;
    if (sym1.aliases !== sym2.aliases) return false;
    if (sym1.name !== sym2.name) return false;
    if (typeof sym1.colour !== typeof sym2.colour || 
        (typeof sym1.colour === "string" && typeof sym2.colour === "string" &&
         parseInt(sym1.colour, 16) != parseInt(sym2.colour, 16))) {
      return false;
    }
    if (sym1.complement !== sym2.complement) return false;
    if (sym1.equals !== sym2.equals) return false;
  }
  return true;
};
Alphabet.prototype.check_core_subset = function(super_alph) {
  var complement_same = true;
  var seen_set = {};
  var sub_i, sub_symbol, super_i, super_symbol;
  for (sub_i = 0; sub_i < this.ncore; sub_i++) {
    sub_symbol = this.symbols[sub_i];
    super_i = super_alph.encode[sub_symbol.symbol]; 
    if (super_i == null) return 0;
    super_symbol = super_alph.symbols[super_i];
    if (seen_set[super_i]) return 0;
    seen_set[super_i] = true;
    // check complement
    if (sub_symbol.complement != null && super_symbol.complement != null) {
      if (super_alph.encode[sub_symbol.complement] != super_alph.encode[super_symbol.complement]) {
        complement_same = false;
      }
    } else if (sub_symbol.complement != null || super_symbol.complement != null) {
      complement_same = false;
    }
  }
  return (complement_same ? 1 : -1);
};
// convert a sequence to its reverse complement
Alphabet.prototype.invcomp_seq = function(seq) {
  "use strict";
  var syms, i, e_sym, comp_e_sym;
  if (!this.has_complement()) throw new Error("Alphabet must be complementable");
  syms = seq.split("");
  for (i = 0; i < syms.length; i++) {
    e_sym = this.encode[syms[i]];
    if (typeof e_sym === "undefined") {
      e_sym = this.ncore; // wildcard
    }
    comp_e_sym = this.complement[e_sym];
    if (typeof comp_e_sym === "undefined") {
      comp_e_sym = e_sym; // not complementable
    }
    syms[i] = this.symbols[comp_e_sym].symbol;
  }
  return syms.reverse().join("");
};
// convert the alphabet to the text version
Alphabet.prototype.as_text = function() {
  "use strict";
  function name_as_text(name) {
    var i, c, out;
    out = "\"";
    for (i = 0; i < name.length; i++) {
      c = name.charAt(i);
      if (c == "\"") {
        out += "\\\"";
      } else if (c == "/") {
        out += "\\/";
      } else if (c == "\\") {
        out += "\\\\";
      } else {
        out += c;
      }
    }
    out += "\"";
    return out;
  }
  function symbol_as_text(sym) {
    var out;
    out = sym.symbol;
    if (typeof sym.name === "string" && sym.name != sym.symbol) {
      out += " " + name_as_text(sym.name);
    }
    if (typeof sym.colour === "string") {
      out += " " + sym.colour;
    }
    return out;
  }
  var out, i, j, c, sym;
  out = "";
  // output core symbols with 2 way complements
  for (i = 0; i < this.ncore; i++) {
    c = this.complement[i];
    if (typeof c === "number" && i < c && this.complement[c] === i) {
      out += symbol_as_text(this.symbols[i]) + " ~ " + symbol_as_text(this.symbols[c]) + "\n";  
    }
  }
  // output core symbols with no complement
  for (i = 0; i < this.ncore; i++) {
    if (typeof this.complement[i] === "undefined") {
      out += symbol_as_text(this.symbols[i]) + "\n";
    }
  }
  // output ambiguous symbols that have comprising characters
  for (i = this.ncore; i < this.symbols.length; i++) {
    if (this.symbols[i].equals.length == 0) break;
    out += symbol_as_text(this.symbols[i]) + " = " + this.symbols[i].equals + "\n";
    if (typeof this.symbols[i].aliases === "string") {
      for (j = 0; j < this.symbols[i].aliases.length; j++) {
        if (this.symbols[i].aliases.charAt(j) == this.symbols[i].symbol) continue;
        out += this.symbols[i].aliases.charAt(j) + " = " + this.symbols[i].equals + "\n";
      }
    }
  }
  // output aliases of core symbols
  for (i = 0; i < this.ncore; i++) {
    if (typeof this.symbols[i].aliases === "string") {
      for (j = 0; j < this.symbols[i].aliases.length; j++) {
        if (this.symbols[i].aliases.charAt(j) == this.symbols[i].symbol) continue;
        out += this.symbols[i].aliases.charAt(j) + " = " + this.symbols[i].symbol + "\n";
      }
    }
  }
  // output gap symbols
  i = this.symbols.length - 1;
  if (this.symbols[i].equals.length == 0) {
    out += symbol_as_text(this.symbols[i]) + " =\n";
    if (typeof this.symbols[i].aliases === "string") {
      for (j = 0; j < this.symbols[i].aliases.length; j++) {
        if (this.symbols[i].aliases.charAt(j) == this.symbols[i].symbol) continue;
        out += this.symbols[i].aliases.charAt(j) + " =\n";
      }
    }
  }
  return out;
};
// output the alphabet as it appears in minimal MEME format
Alphabet.prototype.as_meme = function() {
  "use strict";
  function name_as_text(name) {
    var i, c, out;
    out = "\"";
    for (i = 0; i < name.length; i++) {
      c = name.charAt(i);
      if (c == "\"") {
        out += "\\\"";
      } else if (c == "/") {
        out += "\\/";
      } else if (c == "\\") {
        out += "\\\\";
      } else {
        out += c;
      }
    }
    out += "\"";
    return out;
  }
  if (this.equals(AlphStd.DNA)) {
    return "ALPHABET= ACGT\n";
  } else if (this.equals(AlphStd.PROTEIN)) {
    return "ALPHABET= ACDEFGHIKLMNPQRSTVWY\n";
  } else {
    return "ALPHABET" + 
      (this.name != null ? " " + name_as_text(this.name) : "") + 
      (this.like != null ? " " + this.like + "-LIKE" : "") + "\n" +
      this.as_text() + "END ALPHABET\n";
  }
};

// Returns a table showing all the letters in the alphabet
Alphabet.prototype.as_table = function() {
  "use strict";
  var i, j, row, th, td, aliases, equals, sym;
  var table = document.createElement("table");
  // create the core symbol header
  row = table.insertRow(table.rows.length);
  th = document.createElement("th");
  th.appendChild(document.createTextNode("Symbol(s)"));
  row.appendChild(th);
  th = document.createElement("th");
  th.appendChild(document.createTextNode("Name"));
  row.appendChild(th);
  th = document.createElement("th");
  if (this.has_complement()) {
    th.appendChild(document.createTextNode("Complement"));
  }
  row.appendChild(th);
  // list the core symbols
  for (i = 0; i < this.ncore; i++) {
    row = table.insertRow(table.rows.length);
    td = document.createElement("td");
    if (this.symbols[i].colour != null) {
      td.style.color = '#' + this.symbols[i].colour;
    }
    td.appendChild(document.createTextNode(this.symbols[i].symbol));
    aliases = this.get_aliases(i);
    if (aliases.length > 0) {
      td.appendChild(document.createTextNode(' ' + aliases.split('').join(' ')));
    }
    row.appendChild(td);
    td = document.createElement("td");
    if (this.symbols[i].name != null) {
      td.appendChild(document.createTextNode(this.symbols[i].name));
    }
    row.appendChild(td);
    td = document.createElement("td");
    if (this.symbols[i].complement != null) {
      td.style.color = this.get_colour(this.get_index(this.symbols[i].complement));
      td.appendChild(document.createTextNode(this.symbols[i].complement));
    }
    row.appendChild(td);
  }
  // create the ambiguous symbol header
  row = table.insertRow(table.rows.length);
  th = document.createElement("th");
  th.appendChild(document.createTextNode("Symbol(s)"));
  row.appendChild(th);
  th = document.createElement("th");
  th.appendChild(document.createTextNode("Name"));
  row.appendChild(th);
  th = document.createElement("th");
  th.appendChild(document.createTextNode("Matches"));
  row.appendChild(th);
  // list the ambiguous symbols
  for (i = this.ncore; i < this.symbols.length; i++) {
    row = table.insertRow(table.rows.length);
    td = document.createElement("td");
    if (this.symbols[i].colour != null) {
      td.style.color = '#' + this.symbols[i].colour;
    }
    td.appendChild(document.createTextNode(this.symbols[i].symbol));
    aliases = this.get_aliases(i);
    if (aliases.length > 0) {
      td.appendChild(document.createTextNode(' ' + aliases.split('').join(' ')));
    }
    row.appendChild(td);
    td = document.createElement("td");
    if (this.symbols[i].name != null) {
      td.appendChild(document.createTextNode(this.symbols[i].name));
    }
    row.appendChild(td);
    td = document.createElement("td");
    equals = this.symbols[i].equals.split('');
    for (j = 0; j < equals.length; j++) {
      if (j != 0) td.appendChild(document.createTextNode(' '));
      sym = document.createElement("span");
      sym.style.color = this.get_colour(this.get_index(equals[j]));
      sym.appendChild(document.createTextNode(equals[j]));
      td.appendChild(sym);
    }
    row.appendChild(td);
  }
  return table;
};

// returns a dictionary of the colours for EPS
Alphabet.prototype._as_eps_dict = function() {
  "use strict";
  var i, sym, rgb;
  var out = "/fullColourDict <<\n";
  for (i = 0; i < this.ncore; i++) {
    sym = this.get_symbol(i);
    sym = sym.replace(/\\/g, "\\\\");
    sym = sym.replace(/\(/g, "\\(");
    sym = sym.replace(/\)/g, "\\)");
    rgb = this.get_rgb(i);
    out += " (" + sym + ") [" + rgb.red.toFixed(4) + " " + rgb.green.toFixed(4) + " " + rgb.blue.toFixed(4) + "]\n";
  }
  out += ">> def\n";
  out += "/mutedColourDict <<\n";
  for (i = 0; i < this.ncore; i++) {
    sym = this.get_symbol(i);
    sym = sym.replace(/\\/g, "\\\\");
    sym = sym.replace(/\(/g, "\\(");
    sym = sym.replace(/\)/g, "\\)");
    rgb = Alphabet.lighten_colour(this.get_rgb(i));
    out += " (" + sym + ") [" + rgb.red.toFixed(4) + " " + rgb.green.toFixed(4) + " " + rgb.blue.toFixed(4) + "]\n";
  }
  out += ">> def\n";
  return out;
};

// return the alphabet name or a list of primary symbols
Alphabet.prototype.toString = function() {
  "use strict";
  if (this.name != null) {
    return this.name;
  } else {
    return this.get_symbols();
  }
};

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// Helper functions
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

// Convert a colour specified in RGB colourspace values into LAB colourspace
Alphabet.rgb2lab = function(rgb) {
  "use strict";
  var xyzHelper, labHelper;
  // XYZ helper
  xyzHelper = function(value) {
    if (value > 0.0445) {
      value = (value + 0.055) / 1.055;
      value = Math.pow(value, 2.4);
    } else {
      value /= 12.92;
    }
    value *= 100;
    return value;
  };
  // lab helper
  labHelper = function(value) {
    if (value > 0.008856) {
      value = Math.pow(value, 1.0 / 3.0);
    } else {
      value = (7.787 * value) + (16.0 / 116.0);
    }
    return value;
  };
  // convert into XYZ colourspace
  var c1, c2, c3;
  if (typeof rgb == "number") {
    c1 = xyzHelper(((rgb >> 16) & 0xFF) / 255.0);
    c2 = xyzHelper(((rgb >> 8) & 0xFF) / 255.0);
    c3 = xyzHelper((rgb & 0xFF) / 255.0);
  } else {
    c1 = xyzHelper(rgb.red);
    c2 = xyzHelper(rgb.green);
    c3 = xyzHelper(rgb.blue);
  }
  var x = (c1 * 0.4124) + (c2 * 0.3576) + (c3 * 0.1805);
  var y = (c1 * 0.2126) + (c2 * 0.7152) + (c3 * 0.0722);
  var z = (c1 * 0.0193) + (c2 * 0.1192) + (c3 * 0.9505);
  // convert into Lab colourspace
  c1 = labHelper(x / 95.047);
  c2 = labHelper(y / 100.0);
  c3 = labHelper(z / 108.883);
  var l = (116.0 * c2) - 16;
  var a = 500.0 * (c1 - c2);
  var b = 200.0 * (c2 - c3);
  return {"l": l, "a": a, "b": b};
};

// Convert a colour specified in HSV colourspace into RGB colourspace
Alphabet.hsv2rgb = function(hue, sat, value, output_object) {
  // achromatic (grey)
  var r = value;
  var g = value;
  var b = value;
  if (sat != 0) {
    var h = hue / 60.0;
    var i = Math.floor(h);
    var f = h - i;
    var p = value * (1.0 - sat);
    var q = value * (1.0 - (sat * f));
    var t = value * (1.0 - (sat * (1.0 - f)));
    if (i == 0) {
      r = value;
      g = t;
      b = p;
    } else if (i == 1) {
      r = q;
      g = value;
      b = p;
    } else if (i == 2) {
      r = p;
      g = value;
      b = t;
    } else if (i == 3) {
      r = p;
      g = q;
      b = value;
    } else if (i == 4) {
      r = t;
      g = p;
      b = value;
    } else {
      r = value;
      g = p;
      b = q;
    }
  }
  if (output_object) {
    return {"red": r, "green": g, "blue": b};
  } else {
    return (Math.floor(r * 255) << 15) | (Math.floor(g * 255) << 8) | (Math.floor(b * 255));
  }
};

// Calculate a distance score between two colours in LAB colourspace
Alphabet.lab_dist = function(lab1, lab2) {
  var c1 = Math.sqrt((lab1.l * lab1.l) + (lab1.a * lab1.a));
  var c2 = Math.sqrt((lab2.l * lab2.l) + (lab2.a * lab2.a));
  var dc = c1 - c2;
  var dl = lab1.l - lab2.l;
  var da = lab1.a - lab2.a;
  var db = lab1.b - lab2.b;
  // we don't want NaN due to rounding errors so fudge things a bit...
  var dh = 0;
  var dh_squared = (da * da) + (db * db) - (dc * dc);
  if (dh_squared > 0) {
    dh = Math.sqrt(dh_squared);
  }
  var first = dl;
  var second = dc / (1.0 + (0.045 * c1));
  var third = dh / (1.0 + (0.015 * c1));
  return Math.sqrt((first * first) + (second * second) + (third * third));
};

// convert an RGB value into a HSL value
Alphabet.rgb2hsl = function(rgb) {
  "use strict";
  var min, max, delta, h, s, l, r, g, b;
  if (typeof rgb == "number") {
    r = ((rgb >> 16) & 0xFF) / 255.0;
    g = ((rgb >> 8) & 0xFF) / 255.0;
    b = (rgb & 0xFF) / 255.0;
  } else {
    r = rgb.red;
    g = rgb.green;
    b = rgb.blue;
  }
  min = Math.min(r, g, b);
  max = Math.max(r, g, b);
  delta = max - min;
  l = min + (delta / 2);
  if (max == min) {
    h = 0; // achromatic (grayscale)
    s = 0;
  } else {
    if (l > 0.5) {
      s = delta / (2 - max - min);
    } else {
      s = delta / (max + min);
    }
    if (max == r) {
      h = (g - b) / delta;
      if (g < b) h += 6;
    } else if (max == g) {
      h = ((b - r) / delta) + 2;
    } else {
      h = ((r - g) / delta) + 4;
    }
    h /= 6;
  }
  return {"h": h, "s": s, "l": l};
};

// convert a HSL value into an RGB value
Alphabet.hsl2rgb = function(hsl, output_object) {
  "use strict";
  function _hue(p, q, t) {
    "use strict";
    if (t < 0) t += 1;
    else if (t > 1) t -= 1;
    if (t < (1.0 / 6.0)) {
      return p + ((q - p) * 6.0 * t);
    } else if (t < 0.5) {
      return q;
    } else if (t < (2.0 / 3.0)) {
      return p + ((q - p) * ((2.0 / 3.0) - t) * 6.0);
    } else {
      return p;
    }
  }
  var r, g, b, p, q;
  if (hsl.s == 0) {
    // achromatic (grayscale)
    r = hsl.l;
    g = hsl.l;
    b = hsl.l;
  } else {
    if (hsl.l < 0.5) {
      q = hsl.l * (1 + hsl.s);
    } else {
      q = hsl.l + hsl.s - (hsl.l * hsl.s);
    }
    p = (2 * hsl.l) - q;
    r = _hue(p, q, hsl.h + (1.0 / 3.0));
    g = _hue(p, q, hsl.h);
    b = _hue(p, q, hsl.h - (1.0 / 3.0));
  }
  if (output_object) {
    return {"red": r, "green": g, "blue": b};
  } else {
    return (Math.floor(r * 255) << 15) | (Math.floor(g * 255) << 8) | (Math.floor(b * 255));
  }
};

Alphabet.lighten_colour = function(rgb) {
  "use strict";
  var hsl = Alphabet.rgb2hsl(rgb);
  hsl.l += (1.0 - hsl.l) * 2 / 3;
  return Alphabet.hsl2rgb(hsl, typeof rgb != "number");
};

//======================================================================
// end Alphabet object
//======================================================================

//======================================================================
// start StandardAlphabet object
//======================================================================

// an extension of the alphabet object to support some additional fields 
// only present in standard alphabets.
var StandardAlphabet = function(enum_code, enum_name, alphabet_data) {
  Alphabet.apply(this, [alphabet_data]);
  this.enum_code = enum_code;
  this.enum_name = enum_name;
};
StandardAlphabet.prototype = Alphabet.prototype;
StandardAlphabet.prototype.constructor = StandardAlphabet;

// A unique code for this standard alphabet.
// This code will be a power of 2 to enable creation of bitsets for
// a selection of standard alphabets.
StandardAlphabet.prototype.get_code = function() {
  return this.enum_code;
};

// A unique name for this standard alphabet.
// this name will be all upper case and the same as the property that
// refers to this alphabet in the AlphStd collection.
StandardAlphabet.prototype.get_enum = function() {
  return this.enum_name;
};

//======================================================================
// end StandardAlphabet object
//======================================================================

// A collection of standard alphabets.
var AlphStd = {
  RNA: new StandardAlphabet(1, "RNA", {
    "name": "RNA",
    "like": "RNA",
    "ncore": 4,
    "symbols": [
      {"symbol": "A", "name": "Adenine", "colour": "CC0000"},
      {"symbol": "C", "name": "Cytosine", "colour": "0000CC"},
      {"symbol": "G", "name": "Guanine", "colour": "FFB300"},
      {"symbol": "U", "name": "Uracil", "colour": "008000",
        "aliases": "T"},
      {"symbol": "N", "name": "Any base", "equals": "ACGU", "aliases": "X."},
      {"symbol": "V", "name": "Not U", "equals": "ACG"},
      {"symbol": "H", "name": "Not G", "equals": "ACU"},
      {"symbol": "D", "name": "Not C", "equals": "AGU"},
      {"symbol": "B", "name": "Not A", "equals": "CGU"},
      {"symbol": "M", "name": "Amino", "equals": "AC"},
      {"symbol": "R", "name": "Purine", "equals": "AG"},
      {"symbol": "W", "name": "Weak", "equals": "AU"}, 
      {"symbol": "S", "name": "Strong", "equals": "CG"},
      {"symbol": "Y", "name": "Pyrimidine", "equals": "CU"},
      {"symbol": "K", "name": "Keto", "equals": "GU"}
    ]
  }), 
  DNA: new StandardAlphabet(2, "DNA", {
    "name": "DNA",
    "like": "DNA",
    "ncore": 4,
    "symbols": [
      {"symbol": "A", "name": "Adenine", "colour": "CC0000", "complement": "T"},
      {"symbol": "C", "name": "Cytosine", "colour": "0000CC", "complement": "G"},
      {"symbol": "G", "name": "Guanine", "colour": "FFB300", "complement": "C"},
      {"symbol": "T", "name": "Thymine", "colour": "008000", "complement": "A",
        "aliases": "U"},
      {"symbol": "N", "name": "Any base", "equals": "ACGT", "aliases": "X."},
      {"symbol": "V", "name": "Not T", "equals": "ACG"},
      {"symbol": "H", "name": "Not G", "equals": "ACT"},
      {"symbol": "D", "name": "Not C", "equals": "AGT"},
      {"symbol": "B", "name": "Not A", "equals": "CGT"},
      {"symbol": "M", "name": "Amino", "equals": "AC"},
      {"symbol": "R", "name": "Purine", "equals": "AG"},
      {"symbol": "W", "name": "Weak", "equals": "AT"}, 
      {"symbol": "S", "name": "Strong", "equals": "CG"},
      {"symbol": "Y", "name": "Pyrimidine", "equals": "CT"},
      {"symbol": "K", "name": "Keto", "equals": "GT"}
    ]
  }), 
  PROTEIN: new StandardAlphabet(4, "PROTEIN", {
    "name": "Protein",
    "like": "PROTEIN",
    "ncore": 20,
    "symbols": [
      {"symbol": "A", "name": "Alanine", "colour": "0000CC"},
      {"symbol": "C", "name": "Cysteine", "colour": "0000CC"},
      {"symbol": "D", "name": "Aspartic acid", "colour": "FF00FF"},
      {"symbol": "E", "name": "Glutamic acid", "colour": "FF00FF"},
      {"symbol": "F", "name": "Phenylalanine", "colour": "0000CC"},
      {"symbol": "G", "name": "Glycine", "colour": "FFB300"},
      {"symbol": "H", "name": "Histidine", "colour": "FFCCCC"},
      {"symbol": "I", "name": "Isoleucine", "colour": "0000CC"},
      {"symbol": "K", "name": "Lysine", "colour": "CC0000"},
      {"symbol": "L", "name": "Leucine", "colour": "0000CC"},
      {"symbol": "M", "name": "Methionine", "colour": "0000CC"},
      {"symbol": "N", "name": "Asparagine", "colour": "008000"},
      {"symbol": "P", "name": "Proline", "colour": "FFFF00"},
      {"symbol": "Q", "name": "Glutamine", "colour": "008000"},
      {"symbol": "R", "name": "Arginine", "colour": "CC0000"},
      {"symbol": "S", "name": "Serine", "colour": "008000"},
      {"symbol": "T", "name": "Threonine", "colour": "008000"},
      {"symbol": "V", "name": "Valine", "colour": "0000CC"},
      {"symbol": "W", "name": "Tryptophan", "colour": "0000CC"},
      {"symbol": "Y", "name": "Tyrosine", "colour": "33E6CC"},
      {"symbol": "X", "name": "Any amino acid", "equals": "ACDEFGHIKLMNPQRSTVWY", "aliases": "*."},
      {"symbol": "B", "name": "Asparagine or Aspartic acid", "equals": "DN"}, 
      {"symbol": "Z", "name": "Glutamine or Glutamic acid", "equals": "EQ"}, 
      {"symbol": "J", "name": "Leucine or Isoleucine", "equals": "IL"}
    ]
  })
};

//======================================================================
// start Symbol object
//======================================================================
var Symbol = function(alph_index, scale, alphabet) {
  "use strict";
  //variable prototype
  this.symbol = alphabet.get_symbol(alph_index);
  this.scale = scale;
  this.colour = alphabet.get_colour(alph_index);
};

Symbol.prototype.get_symbol = function() {
  "use strict";
  return this.symbol;
};

Symbol.prototype.get_scale = function() {
  "use strict";
  return this.scale;
};

Symbol.prototype.get_colour = function() {
  "use strict";
  return this.colour;
};

Symbol.prototype.toString = function() {
  "use strict";
  return this.symbol + " " + (Math.round(this.scale*1000)/10) + "%";
};

function compare_symbol(sym1, sym2) {
  "use strict";
  if (sym1.get_scale() < sym2.get_scale()) {
    return -1;
  } else if (sym1.get_scale() > sym2.get_scale()) {
    return 1;
  } else {
    return 0;
  }
}
//======================================================================
// end Symbol object
//======================================================================

//======================================================================
// start Pspm object
//======================================================================
var Pspm = function(matrix, name, ltrim, rtrim, nsites, evalue, pssm, alt, pgm) {
  "use strict";
  var row, col, data, row_sum, delta, evalue_re;
  if (typeof name !== "string") {
    name = "";
  }
  this.name = name;
  //construct
  if (matrix instanceof Pspm) {
    // copy constructor
    this.alph_length = matrix.alph_length;
    this.motif_length = matrix.motif_length;
    this.name = matrix.name;
    this.alt = matrix.alt;
    this.nsites = matrix.nsites;
    this.evalue = matrix.evalue;
    this.ltrim = matrix.ltrim;
    this.rtrim = matrix.rtrim;
    this.pspm = [];
    this.pgm = matrix.pgm;
    for (row = 0; row < matrix.motif_length; row++) {
      this.pspm[row] = [];
      for (col = 0; col < matrix.alph_length; col++) {
        this.pspm[row][col] = matrix.pspm[row][col];
      }
    }
    if (matrix.pssm != null) {
      this.pssm = [];
      for (row = 0; row < matrix.motif_length; row++) {
        this.pspm[row] = [];
        for (col = 0; col < matrix.alph_length; col++) {
          this.pssm[row][col] = matrix.pssm[row][col];
        }
      }
    }
  } else {
    // check parameters
    if (ltrim == null) {
      ltrim = 0;
    } else if (typeof ltrim !== "number" || ltrim % 1 !== 0 || ltrim < 0) {
      throw new Error("ltrim must be a non-negative integer, got: " + ltrim);
    }
    if (rtrim == null) {
      rtrim = 0;
    } else if (typeof rtrim !== "number" || rtrim % 1 !== 0 || rtrim < 0) {
      throw new Error("rtrim must be a non-negative integer, got: " + rtrim);
    }
    if (nsites != null) {
      if (typeof nsites !== "number" || nsites < 0) {
        throw new Error("nsites must be a positive number, got: " + nsites);
      } else if (nsites == 0) {
        nsites = null;
      }
    }
    if (evalue != null) {
      if (typeof evalue === "number") {
        if (evalue < 0) {
          throw new Error("evalue must be a non-negative number, got: " + evalue);
        }
      } else if (typeof evalue === "string") {
        evalue_re = /^((?:[+]?[0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)|inf)$/;
        if (!evalue_re.test(evalue)) {
          throw new Error("evalue must be a non-negative number, got: " + evalue);
        }
      } else {
        throw new Error("evalue must be a non-negative number, got: " + evalue);
      }
    }
    // set properties
    this.name = name;
    this.alt = alt;
    this.nsites = nsites;
    this.evalue = evalue;
    this.ltrim = ltrim;
    this.rtrim = rtrim;
    this.pgm = pgm;
    if (typeof matrix === "string") {
      // string constructor
      data = parse_pspm_string(matrix);
      this.alph_length = data["alph_length"];
      this.motif_length = data["motif_length"];
      this.pspm = data["pspm"];
      if (this.evalue == null) {
        if (data["evalue"] != null) {
          this.evalue = data["evalue"];
        } else {
          this.evalue = 0;
        }
      }
      if (this.nsites == null) {
        if (typeof data["nsites"] === "number") {
          this.nsites = data["nsites"];
        } else {
          this.nsites = 20;
        }
      }
    } else {
      // assume pspm is a nested array
      this.motif_length = matrix.length;
      this.alph_length = (matrix.length > 0 ? matrix[0].length : 0);
      if (this.nsites == null) {
        this.nsites = 20;
      }
      if (this.evalue == null) {
        this.evalue = 0;
      }
      this.pspm = [];
      // copy pspm and check
      for (row = 0; row < this.motif_length; row++) {
        if (this.alph_length != matrix[row].length) {
          throw new Error("COLUMN_MISMATCH");
        }
        this.pspm[row] = [];
        row_sum = 0;
        for (col = 0; col < this.alph_length; col++) {
          this.pspm[row][col] = matrix[row][col];
          row_sum += this.pspm[row][col];
        }
        delta = 0.1;
        if (isNaN(row_sum) || (row_sum > 1 && (row_sum - 1) > delta) || 
            (row_sum < 1 && (1 - row_sum) > delta)) {
          throw new Error("INVALID_SUM");
        }
      }
      // copy pssm
      if (pssm != null) {
        this.pssm = [];
        for (row = 0; row < this.motif_length; row++) {
          this.pssm[row] = [];
          for (col = 0; col < this.alph_length; col++) {
            this.pssm[row][col] = pssm[row][col];
          }
        }
      }
    }
  }
};

Pspm.prototype.copy = function() {
  "use strict";
  return new Pspm(this);
};

Pspm.prototype.reverse = function() {
  "use strict";
  var x, y, temp, temp_trim;
  //reverse
  x = 0;
  y = this.motif_length-1;
  while (x < y) {
    temp = this.pspm[x];
    this.pspm[x] = this.pspm[y];
    this.pspm[y] = temp;
    x++;
    y--;
  }
  // reverse pssm (if defined)
  if (typeof this.pssm !== "undefined") {
    //reverse
    x = 0;
    y = this.motif_length-1;
    while (x < y) {
      temp = this.pssm[x];
      this.pspm[x] = this.pssm[y];
      this.pssm[y] = temp;
      x++;
      y--;
    }
  }
  //swap triming
  temp_trim = this.ltrim;
  this.ltrim = this.rtrim;
  this.rtrim = temp_trim;
  return this; //allow function chaining...
};

Pspm.prototype.reverse_complement = function(alphabet) {
  "use strict";
  var x, y, temp, i, row, c, temp_trim;
  if (this.alph_length != alphabet.get_size_core()) {
    throw new Error("The alphabet size does not match the size of the pspm.");
  }
  if (!alphabet.has_complement()) {
    throw new Error("The specified alphabet can not be complemented.");
  }
  // reverse motif
  this.reverse();
  //complement
  for (x = 0; x < this.motif_length; x++) {
    row = this.pspm[x];
    for (i = 0; i < row.length; i++) {
      c = alphabet.get_complement(i);
      if (c < i) continue;
      temp = row[i];
      row[i] = row[c];
      row[c] = temp;
    }
  }
  // complement pssm (if defined)
  if (typeof this.pssm !== "undefined") {
    //complement
    for (x = 0; x < this.motif_length; x++) {
      row = this.pssm[x];
      for (i = 0; i < row.length; i++) {
        c = alphabet.get_complement(i);
        if (c < i) continue;
        temp = row[i];
        row[i] = row[c];
        row[c] = temp;
      }
    }
  }
  return this; //allow function chaining...
};

Pspm.prototype.get_stack = function(position, alphabet, ssc) {
  "use strict";
  var row, stack_ic, alphabet_ic, stack, i, sym;
  if (this.alph_length != alphabet.get_size_core()) {
    throw new Error("The alphabet size does not match the size of the pspm.");
  }
  row = this.pspm[position];
  stack_ic = this.get_stack_ic(position, alphabet);
  if (ssc) stack_ic -= this.get_error(alphabet);
  alphabet_ic = alphabet.get_ic();
  stack = [];
  for (i = 0; i < this.alph_length; i++) {
    sym = new Symbol(i, row[i]*stack_ic/alphabet_ic, alphabet);
    if (sym.get_scale() <= 0) {
      continue;
    }
    stack.push(sym);
  }
  stack.sort(compare_symbol);
  return stack;
};

Pspm.prototype.get_stack_ic = function(position, alphabet) {
  "use strict";
  var row, H, i;
  if (this.alph_length != alphabet.get_size_core()) {
    throw new Error("The alphabet size does not match the size fo the pspm.");
  }
  row = this.pspm[position];
  H = 0;
  for (i = 0; i < this.alph_length; i++) {
    if (row[i] === 0) {
      continue;
    }
    H -= (row[i] * (Math.log(row[i]) / Math.LN2));
  }
  return alphabet.get_ic() - H;
};

Pspm.prototype.get_error = function(alphabet) {
  "use strict";
  if (this.nsites === 0) {
    return 0;
  }
  return (alphabet.get_size_core()-1) / (2 * Math.LN2 * this.nsites);
};

Pspm.prototype.get_motif_length = function() {
  "use strict";
  return this.motif_length;
};

Pspm.prototype.get_alph_length = function() {
  "use strict";
  return this.alph_length;
};

Pspm.prototype.get_left_trim = function() {
  "use strict";
  return this.ltrim;
};

Pspm.prototype.get_right_trim = function() {
  "use strict";
  return this.rtrim;
};

Pspm.prototype.as_best_match = function(alphabet) {
  "use strict";
  var match, odds, best_odds, best_index;
  var i, j;
  match = "";
  for (i = 0; i < this.motif_length; i++) {
    best_index = 0;
    best_odds = this.pspm[i][0] / alphabet.get_bg_freq(0);
    for (j = 1; j < this.alph_length; j++) {
      odds = this.pspm[i][j] / alphabet.get_bg_freq(j);
      if (odds > best_odds) {
        best_odds = odds;
        best_index = j;
      }
    }
    match += alphabet.get_symbol(best_index);
  }
  return match;
};

Pspm.prototype.as_count_matrix = function() {
  "use strict";
  var count, count_text, text;
  var i, j;
  text = "";
  for (i = 0; i < this.motif_length; i++) {
    if (i !== 0) {
      text += "\n";
    }
    for (j = 0; j < this.alph_length; j++) {
      if (j !== 0) {
        text += " ";
      }
      count = Math.round(this.nsites * this.pspm[i][j]);
      count_text = "" + count;
      // pad up to length of 4
      if (count_text.length < 4) {
        text += (new Array(5 - count_text.length)).join(" ") + count_text;
      } else {
        text += count_text;
      }
    }
  }
  return text; 
};

Pspm.prototype.as_probability_matrix = function() {
  "use strict";
  var text;
  var i, j;
  text = "";
  for (i = 0; i < this.motif_length; i++) {
    if (i !== 0) {
      text += "\n";
    }
    for (j = 0; j < this.alph_length; j++) {
      if (j !== 0) {
        text += " ";
      }
      text += this.pspm[i][j].toFixed(6);
    }
  }
  return text; 
};

Pspm.prototype.as_score_matrix = function(alphabet, pseudo) {
  "use strict";
  var me, score, out, row, col, score_text;
  me = this;
  if (typeof this.pssm === "undefined") {
    if (!(typeof alphabet === "object" && alphabet != null && alphabet instanceof Alphabet)) {
      throw new Error("The alphabet is required to generate the pssm.");
    }
    if (typeof pseudo === "undefined") {
      pseudo = 0.01;
    } else if (typeof pseudo !== "number" || pseudo < 0) {
      throw new Error("Expected positive number for pseudocount");
    }
    score = function(row, col) {
      "use strict";
      var p, bg, p2;
      p = me.pspm[row][col];
      bg = alphabet.get_bg_freq(col);
      p2 = (p * me.nsites + bg * pseudo) / (me.nsites + pseudo);
      return (p2 > 0 ? Math.round((Math.log(p2 / bg) / Math.LN2) * 100) : -10000);
    };
  } else {
    score = function(row, col) {
      "use strict";
      return me.pssm[row][col];
    };
  }
  out = "";
  for (row = 0; row < this.motif_length; row++) {
    for (col = 0; col < this.alph_length; col++) {
      if (col !== 0) {
        out += " ";
      }
      score_text = "" + score(row, col);
      // pad out to 6 characters
      if (score_text.length < 6) {
        out += (new Array(7 - score_text.length)).join(" ") + score_text;
      } else {
        out += score_text;
      }
    }
    out += "\n";
  }
  return out;
}

Pspm.prototype.as_pspm = function() {
  "use strict";
  return "letter-probability matrix: alength= " + this.alph_length + 
      " w= " + this.motif_length + " nsites= " + this.nsites + 
      (this.pgm === "STREME" ? " P= " : " E= ") + 
          (typeof this.evalue === "number" ? 
          this.evalue.toExponential() : this.evalue) + "\n" +
      this.as_probability_matrix();
};

Pspm.prototype.as_pssm = function(alphabet, pseudo) {
  "use strict";
  return "log-odds matrix: alength= " + this.alph_length + 
      " w= " + this.motif_length + 
      " E= " + (typeof this.evalue == "number" ?
          this.evalue.toExponential() : this.evalue) + "\n" +
      this.as_score_matrix(alphabet, pseudo);
};

Pspm.prototype.as_meme = function(options) {
  var with_header, with_pspm, with_pssm, version, alphabet, bg_source, pseudocount, strands;
  var out, alen, i;
  // get the options
  if (typeof options !== "object" || options === null) {
    options = {};
  }
  with_header = (typeof options["with_header"] === "boolean" ? options["with_header"] : false);
  with_pspm = (typeof options["with_pspm"] === "boolean" ? options["with_pspm"] : false);
  with_pssm = (typeof options["with_pssm"] === "boolean" ? options["with_pssm"] : false);
  if (!with_pspm && !with_pssm) with_pspm = true;
  if (with_header) {
    if (typeof options["version"] === "string" && /^\d+(?:\.\d+){0,2}$/.test(options["version"])) {
      version = options["version"];
    } else if (typeof options["version"] === "number") {
      version = options["version"].toFixed(0);
    } else {
      version = "4";
    }
    if (typeof options["strands"] === "number" && options["strands"] === 1) {
      strands = 1;
    } else {
      strands = 2;
    }
    if (typeof options["bg_source"] === "string") {
      bg_source = options["bg_source"];
    } else {
      bg_source = "unknown source";
    }
    if (typeof options["alphabet"] === "object" && options["alphabet"] != null
        && options["alphabet"] instanceof Alphabet) {
      alphabet = options["alphabet"];
    } else {
      throw new Error("The alphabet is required to generate the header.");
    }
  }
  // now create the output
  out = "";
  if (with_header) {
    out = "MEME version " + version + "\n\n";
    out += alphabet.as_meme() + "\n";
    if (alphabet.has_complement()) { // assume DNA has both strands unless otherwise specified
      out += "strands: " + (strands === 1 ? "+" : "+ -") + "\n\n";
    }
    out += "Background letter frequencies (from " + bg_source + "):\n";
    alen = alphabet.get_size_core();
    for (i = 0; i < alen; i++) {
      if (i !== 0) {
        if (i % 9 === 0) { // maximum of nine entries per line
          out += "\n";
        } else {
          out += " ";
        }
      }
      out += alphabet.get_symbol(i) + " " + alphabet.get_bg_freq(i).toFixed(3);
    }
  }
  out += "\n\n";
  out += "MOTIF " + this.name + (this.alt == null ? "" : " " + this.alt);
  if (with_pssm) {
    out += "\n\n";
    out += this.as_pssm(options["alphabet"], options["pseudocount"]);
  }
  if (with_pspm) {
    out += "\n\n";
    out += this.as_pspm();
  }
  return out;
}

Pspm.prototype.toString = function() {
  "use strict";
  var str, i, row;
  str = "";
  for (i = 0; i < this.pspm.length; i++) {
    row = this.pspm[i];
    str += row.join("\t") + "\n";
  }
  return str;
};

function parse_pspm_properties(str) {
  "use strict";
  var parts, i, eqpos, before, after, properties, prop, num, num_re;
  num_re = /^((?:[+]?[0-9]*\.?[0-9]+(?:[eE][-+]?[0-9]+)?)|inf)$/;
  parts = trim(str).split(/\s+/);
  // split up words containing =
  for (i = 0; i < parts.length;) {
    eqpos = parts[i].indexOf("=");
    if (eqpos != -1) {
      before = parts[i].substr(0, eqpos);
      after = parts[i].substr(eqpos+1);
      if (before.length > 0 && after.length > 0) {
        parts.splice(i, 1, before, "=", after);
        i += 3;
      } else if (before.length > 0) {
        parts.splice(i, 1, before, "=");
        i += 2;
      } else if (after.length > 0) {
        parts.splice(i, 1, "=", after);
        i += 2;
      } else {
        parts.splice(i, 1, "=");
        i++;
      }
    } else {
      i++;
    }
  }
  properties = {};
  for (i = 0; i < parts.length; i += 3) {
    if (parts.length - i < 3) {
      throw new Error("Expected PSPM property was incomplete. "+
          "Remaing parts are: " + parts.slice(i).join(" "));
    }
    if (parts[i+1] !== "=") {
      throw new Error("Expected '=' in PSPM property between key and " +
          "value but got " + parts[i+1]); 
    }
    prop = parts[i].toLowerCase();
    num = parts[i+2];
    if (!num_re.test(num)) {
      throw new Error("Expected numeric value for PSPM property '" + 
          prop + "' but got '" + num + "'");
    }
    properties[prop] = num;
  }
  return properties;
}

function parse_pspm_string(pspm_string) {
  "use strict";
  var header_re, lines, first_line, line_num, col_num, alph_length, 
      motif_length, nsites, evalue, pspm, i, line, match, props, parts,
      j, prob;
  header_re = /^letter-probability\s+matrix:(.*)$/i;
  lines = pspm_string.split(/\n/);
  first_line = true;
  line_num = 0;
  col_num = 0;
  alph_length;
  motif_length;
  nsites;
  evalue;
  pspm = [];
  for (i = 0; i < lines.length; i++) {
    line = trim(lines[i]);
    if (line.length === 0) { 
      continue;
    }
    // check the first line for a header though allow matrices without it
    if (first_line) {
      first_line = false;
      match = header_re.exec(line);
      if (match !== null) {
        props = parse_pspm_properties(match[1]);
        if (props.hasOwnProperty("alength")) {
          alph_length = parseFloat(props["alength"]);
          if (alph_length != 4 && alph_length != 20) {
            throw new Error("PSPM property alength should be 4 or 20" +
                " but got " + alph_length);
          }
        }
        if (props.hasOwnProperty("w")) {
          motif_length = parseFloat(props["w"]);
          if (motif_length % 1 !== 0 || motif_length < 1) {
            throw new Error("PSPM property w should be an integer larger " +
                "than zero but got " + motif_length);
          }
        }
        if (props.hasOwnProperty("nsites")) {
          nsites = parseFloat(props["nsites"]);
          if (nsites <= 0) {
            throw new Error("PSPM property nsites should be larger than " +
                "zero but got " + nsites);
          }
        }
        if (props.hasOwnProperty("e")) {
          evalue = props["e"];
          if (evalue < 0) {
            throw new Error("PSPM property evalue should be " +
                "non-negative but got " + evalue);
          }
        }
        continue;
      }
    }
    pspm[line_num] = [];
    col_num = 0;
    parts = line.split(/\s+/);
    for (j = 0; j < parts.length; j++) {
      prob = parseFloat(parts[j]);
      if (prob != parts[j] || prob < 0 || prob > 1) {
        throw new Error("Expected probability but got '" + parts[j] + "'"); 
      }
      pspm[line_num][col_num] = prob;
      col_num++;
    }
    line_num++;
  }
  if (typeof motif_length === "number") {
    if (pspm.length != motif_length) {
      throw new Error("Expected PSPM to have a motif length of " + 
          motif_length + " but it was actually " + pspm.length);
    }
  } else {
    motif_length = pspm.length;
  }
  if (typeof alph_length !== "number") {
    alph_length = pspm[0].length;
    if (alph_length != 4 && alph_length != 20) {
      throw new Error("Expected length of first row in the PSPM to be " +
          "either 4 or 20 but got " + alph_length);
    }
  }
  for (i = 0; i < pspm.length; i++) {
    if (pspm[i].length != alph_length) {
      throw new Error("Expected PSPM row " + i + " to have a length of " + 
          alph_length + " but the length was " + pspm[i].length);
    }
  }
  return {"pspm": pspm, "motif_length": motif_length, 
    "alph_length": alph_length, "nsites": nsites, "evalue": evalue};
}
//======================================================================
// end Pspm object
//======================================================================

//======================================================================
// start Logo object
//======================================================================

var Logo = function(alphabet, options) {
  "use strict";
  this.alphabet = alphabet;
  this.fine_text = "";
  this.x_axis = 1;
  this.y_axis = true;
  this.xlate_nsyms = 1;
  this.xlate_start = null;
  this.xlate_end = null;
  this.pspm_list = [];
  this.pspm_column = [];
  this.rows = 0;
  this.columns = 0;
  if (typeof options === "string") {
    // the old method signature had fine_text here so we support that
    this.fine_text = options;
  } else if (typeof options === "object" && options != null) {
    this.fine_text = (typeof options.fine_text === "string" ? options.fine_text : "");
    this.x_axis = (typeof options.x_axis === "boolean" ? (options.x_axis ? 1 : 0) : 1);
    if (options.x_axis_hidden != null && options.x_axis_hidden) this.x_axis = -1;
    this.y_axis = (typeof options.y_axis === "boolean" ? options.y_axis : true);
    this.xlate_nsyms = (typeof options.xlate_nsyms === "number" ? options.xlate_nsyms : this.xlate_nsyms);
    this.xlate_start = (typeof options.xlate_start === "number" ? options.xlate_start : this.xlate_start);
    this.xlate_end = (typeof options.xlate_end === "number" ? options.xlate_end : this.xlate_end);
  }
};

Logo.prototype.add_pspm = function(pspm, column) {
  "use strict";
  var col;
  if (typeof column === "undefined") {
    column = 0;
  } else if (column < 0) {
    throw new Error("Column index out of bounds.");
  }
  this.pspm_list[this.rows] = pspm;
  this.pspm_column[this.rows] = column;
  this.rows++;
  col = column + pspm.get_motif_length();
  if (col > this.columns) {
    this.columns = col;
  }
};

Logo.prototype.get_columns = function() {
  "use strict";
  return this.columns;
};

Logo.prototype.get_xlate_nsyms = function() {
  "use strict";
  return this.xlate_nsyms;
};

Logo.prototype.get_xlate_start = function() {
  "use strict";
  return (this.xlate_start != null ? this.xlate_start : 0);
};

Logo.prototype.get_xlate_end = function() {
  "use strict";
  return (this.xlate_end != null ? this.xlate_end : this.columns * this.xlate_nsyms);
};

Logo.prototype.get_xlate_columns = function() {
  "use strict";
  return this.get_xlate_end() - this.get_xlate_start();
};

Logo.prototype.get_rows = function() {
  "use strict";
  return this.rows;
};

Logo.prototype.get_pspm = function(row_index) {
  "use strict";
  if (row_index < 0 || row_index >= this.rows) {
    throw new Error("INDEX_OUT_OF_BOUNDS");
  }
  return this.pspm_list[row_index];
};

Logo.prototype.get_offset = function(row_index) {
  "use strict";
  if (row_index < 0 || row_index >= this.rows) {
    throw new Error("INDEX_OUT_OF_BOUNDS");
  }
  return this.pspm_column[row_index];
};

Logo.prototype._as_eps_data = function(ssc, errbars) {
  var i, j, pos, stack_pos, pspm, stack, sym, out;
  out = "";
  for (i = 0; i < this.rows; i++) {
    out += "\nStartLine\n";
    // Indent
    for (j = 0; j < this.pspm_column[i]; j++) {
      out += "() startstack\nendstack\n\n";
    }
    pspm = this.pspm_list[i];
    if (pspm.get_left_trim() > 0) {
      out += "MuteColour\nDrawTrimEdge\n" + pspm.get_left_trim() + " DrawTrimBg\n";
    }
    for (pos = 0; pos < pspm.get_motif_length(); pos++) {
      if (pos != 0 && pos == pspm.get_left_trim()) { // enable full colour
        out += "DrawTrimEdge\nRestoreColour\n";
      } else if (pos == (pspm.get_motif_length() - pspm.get_right_trim())) {
        out += "MuteColour\n" + pspm.get_right_trim() + " DrawTrimBg\n";
      }
      out += "(" + (pos + 1) + ") startstack\n";
      stack = pspm.get_stack(pos, this.alphabet, ssc);
      for (stack_pos = 0; stack_pos < stack.length; stack_pos++) {
        sym = stack[stack_pos];
        out += " " + (sym.get_scale() * this.alphabet.get_ic()) + " (" + sym.get_symbol() + ") numchar\n";
      }
      if (errbars) {
        out += " " + pspm.get_error(this.alphabet) + " Ibeam\n";
      }
      out += "endstack\n\n";
    }
    if (pspm.get_right_trim() > 0 || pspm.get_left_trim() == pspm.get_motif_length()) {
      out += "RestoreColour\n";
    }
    out += "EndLine\n";
  }
  return out;
};

Logo.prototype.as_eps = function(options) {
  "use strict";
  if (this.xlate_nsyms != 1) throw new Error("Unsupported setting xlate_nsyms for EPS");
  if (this.xlate_start != null) throw new Error("Unsupported setting xlate_start for EPS");
  if (this.xlate_end != null) throw new Error("Unsupported setting xlate_end for EPS");

  var LOGOHEIGHT = 7.5; // default height of line in cm
  var cm2pts, height, width, now, ssc, errbars;
  if (typeof options === "undefined") {
    options = {};
  }
  cm2pts = 72 / 2.54;
  if (typeof options.logo_height == "number") {
    height = options.logo_height;
  } else {
    height = LOGOHEIGHT * this.rows;
  }
  if (typeof options.logo_width == "number") {
    width = options.logo_width;
  } else {
    width = this.columns + 2;
  }
  now = new Date();
  ssc = (typeof options.ssc == "boolean" ? options.ssc : false);
  errbars = (typeof options.show_error_bar == "boolean" ? options.show_error_bar : ssc);
  var values = {
    "LOGOHEIGHT": height,
    "LOGOWIDTH": width,
    "BOUNDINGHEIGHT": Math.round(height * cm2pts),
    "BOUNDINGWIDTH": Math.round(width * cm2pts),
    "LOGOLINEHEIGHT": (height / this.rows),
    "CHARSPERLINE": this.columns,
    "BARBITS": this.alphabet.get_ic(),
    "LOGOTYPE": (this.alphabet.has_complement() ? "NA" : "AA"),
    "CREATIONDATE": now.getDate() + "." + (now.getMonth() + 1) + "." + now.getFullYear() + " " + now.getHours() + ":" + now.getMinutes() + ":" + now.getSeconds(),
    "ERRORBARFRACTION": (typeof options.error_bar_fraction == "number" ? options.error_bar_fraction : 1.0),
    "TICBITS": (typeof options.ticbits == "number" ? options.ticbits : 1.0),
    "TITLE": (typeof options.title == "string" ? options.title : ""),
    "FINEPRINT": (typeof options.fineprint == "string" ? options.fineprint : this.fine_text),
    "XAXISLABEL": (typeof options.xaxislabel == "string" ? options.xaxislabel : ""),
    "YAXISLABEL": (typeof options.yaxislabel == "string" ? options.yaxislabel : "bits"),
    "SSC": ssc,
    "YAXIS": (typeof options.show_y_axis == "boolean" ? options.show_y_axis : this.y_axis),
    "SHOWENDS": (typeof options.show_ends == "boolean" ? options.show_ends : false),
    "ERRBAR": errbars,
    "OUTLINE": (typeof options.show_outline == "boolean" ? options.show_outline : false),
    "NUMBERING": (typeof options.show_numbering == "boolean" ? options.show_numbering : this.x_axis != 0),
    "SHOWINGBOX": (typeof options.show_box == "boolean" ? options.show_box : false),
    "CREATOR": (typeof options.creator == "string" ? options.creator : "motif_logo.js"),
    "FONTSIZE": (typeof options.label_font_size == "number" ? options.label_font_size : 12),
    "TITLEFONTSIZE": (typeof options.title_font_size == "number" ? options.title_font_size : 12),
    "SMALLFONTSIZE": (typeof options.small_font_size == "number" ? options.small_font_size : 6),
    "TOPMARGIN" : (typeof options.top_margin == "number" ? options.top_margin : 0.9),
    "BOTTOMMARGIN": (typeof options.bottom_margin == "number" ? options.bottom_margin : 0.9),
    "COLORDICT": this.alphabet._as_eps_dict(),
    "DATA": this._as_eps_data(ssc, errbars)
  };
  // now this requires that the script containing the template has been imported!
  return motif_logo_template(values);
};

//======================================================================
// end Logo object
//======================================================================

// calculate the exact size (in pixels) of an object drawn on the
// canvas assuming that the background of the canvas is transparent.
function canvas_bounds(ctx, cwidth, cheight) {
  "use strict";
  var data, r, c, top_line, bottom_line, left_line, right_line, 
      txt_width, txt_height;

  // extract the image data
  data = ctx.getImageData(0, 0, cwidth, cheight).data;

  // set initial values
  top_line = -1; bottom_line = -1; left_line = -1; right_line = -1;
  txt_width = 0; txt_height = 0;

  // Find the top-most line with a non-transparent pixel
  for (r = 0; r < cheight; r++) {
    for (c = 0; c < cwidth; c++) {
      if (data[r * cwidth * 4 + c * 4 + 3]) {
        top_line = r;
        break;
      }
    }
    if (top_line != -1) {
      break;
    }
  }
  
  // Only bother looking if we found at least one set pixel... 
  if (top_line != -1) {

    //find the last line with a non-transparent pixel
    for (r = cheight-1; r >= top_line; r--) {
      for(c = 0; c < cwidth; c++) {
        if(data[r * cwidth * 4 + c * 4 + 3]) {
          bottom_line = r;
          break;
        }
      }
      if (bottom_line != -1) {
        break;
      }
    }
    // calculate height
    txt_height = bottom_line - top_line + 1;

    // Find the left-most line with a non-transparent pixel
    for (c = 0; c < cwidth; c++) {
      for (r = top_line; r <= bottom_line; r++) {
        if (data[r * cwidth * 4 + c * 4 + 3]) {
          left_line = c;
          break;
        }
      }
      if (left_line != -1) {
        break;
      }
    }

    //find the right most line with a non-transparent pixel
    for (c = cwidth-1; c >= left_line; c--) {
      for(r = top_line; r <= bottom_line; r++) {
        if(data[r * cwidth * 4 + c * 4 + 3]) {
          right_line = c;
          break;
        }
      }
      if (right_line != -1) {
        break;
      }
    }
    txt_width = right_line - left_line + 1;
  }

  //return the bounds
  return {bound_top: top_line, bound_bottom: bottom_line, 
    bound_left: left_line, bound_right: right_line, width: txt_width, 
    height: txt_height};
}

//======================================================================
// start RasterizedAlphabet
//======================================================================

// Rasterize Alphabet
// 1) Measure width of text at default font for all symbols in alphabet
// 2) sort in width ascending
// 3) Drop the top and bottom 10% (designed to ignore outliers like 'W' and 'I')
// 4) Calculate the average as the maximum scaling factor (designed to stop I becoming a rectangular blob).
// 5) Assume scale of zero would result in width of zero, interpolate scale required to make perfect width font
// 6) Draw text onto temp canvas at calculated scale
// 7) Find bounds of drawn text
// 8) Paint on to another canvas at the desired height (but only scaling width to fit if larger).
var RasterizedAlphabet = function(alphabet, logo_scale, font, width) {
  "use strict";
  var default_size, safety_pad, canvas, ctx, middle, baseline, widths, sizes,
      i, sym, size, tenpercent, avg_width, scale, 
      target_width, target_height;
  //variable prototypes
  this.alphabet = alphabet;
  this.scale = logo_scale;
  this.sym_cache = {};
  this.stack_num_cache = [];
  this.scale_num_cache = [];
  // size of canvas
  default_size = 60; // size of measuring canvas
  safety_pad = 20; // pixels to pad around so we don't miss the edges
  // create a canvas to do our measuring
  canvas = document.createElement("canvas");
  if (!canvas.getContext) throw new Error("No canvas support");
  canvas.width = default_size + 2 * safety_pad;
  canvas.height = default_size + 2 * safety_pad;
  middle = Math.round(canvas.width / 2);
  baseline = Math.round(canvas.height - safety_pad);
  ctx = canvas.getContext('2d');
  if (!supports_text(ctx)) throw new Error("Canvas does not support text");
  ctx.font = font;
  ctx.textAlign = "center";
  ctx.translate(middle, baseline);
  // list of widths
  widths = [];
  sizes = [];
  //now measure each letter in the alphabet
  for (i = 0; i < alphabet.get_size_core(); ++i) {
    // reset the canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.fillStyle = alphabet.get_colour(i);
    // draw the test text
    ctx.fillText(alphabet.get_symbol(i), 0, 0);
    //measure
    size = canvas_bounds(ctx, canvas.width, canvas.height);
    if (size.width === 0) throw new Error("Invisible symbol!");
    widths.push(size.width);
    sizes[i] = size;
  }
  //sort the widths
  widths.sort(function(a,b) {return a - b;});
  //drop 10% of the items off each end
  tenpercent = Math.floor(widths.length / 10);
  for (i = 0; i < tenpercent; ++i) {
    widths.pop();
    widths.shift();
  }
  //calculate average width
  avg_width = 0;
  for (i = 0; i < widths.length; ++i) {
    avg_width += widths[i];
  }
  avg_width /= widths.length;
  // calculate the target width
  target_width = width * this.scale * 2;
  // calculate scales
  for (i = 0; i < alphabet.get_size_core(); ++i) {
    sym = alphabet.get_symbol(i);
    size = sizes[i];
    // calculate scale
    scale = target_width / Math.max(avg_width, size.width);
    // estimate scaled height
    target_height = size.height * scale;
    // create an appropriately sized canvas
    canvas = document.createElement("canvas");
    canvas.width = target_width;
    canvas.height = target_height + safety_pad * 2;
    // calculate the middle
    middle = Math.round(canvas.width / 2);
    // calculate the baseline
    baseline = Math.round(canvas.height - safety_pad);
    // get the context and prepare to draw the rasterized text
    ctx = canvas.getContext('2d');
    ctx.font = font;
    ctx.fillStyle = alphabet.get_colour(i);
    ctx.textAlign = "center";
    ctx.translate(middle, baseline);
    ctx.save();
    ctx.scale(scale, scale);
    // draw the text
    ctx.fillText(sym, 0, 0);
    ctx.restore();
    this.sym_cache[sym] = {"image": canvas, "size": canvas_bounds(ctx, canvas.width, canvas.height)};
  }
};

RasterizedAlphabet.prototype.get_alphabet = function() {
  return this.alphabet;
};

RasterizedAlphabet.prototype.get_scale = function() {
  return this.scale;
};

RasterizedAlphabet.prototype.draw_stack_sym = function(ctx, letter, dx, dy, dWidth, dHeight) {
  "use strict";
  var entry, image, size;
  entry = this.sym_cache[letter];
  image = entry.image;
  size = entry.size;
  ctx.drawImage(image, 0, size.bound_top -1, image.width, size.height+1, dx, dy, dWidth, dHeight);
};

RasterizedAlphabet.prototype.draw_stack_num = function(ctx, font, stack_width, index) {
  var image, image_ctx, text_length;
  if (index >= this.stack_num_cache.length) {
    image = document.createElement("canvas");
    // measure the text
    image_ctx = image.getContext('2d');
    image_ctx.save();
    image_ctx.font = font;
    text_length = image_ctx.measureText("" + (index + 1)).width;
    image_ctx.restore();
    // resize the canvas to fit
    image.width = Math.ceil(stack_width);
    image.height = Math.ceil(text_length);
    // draw the text
    image_ctx = image.getContext('2d');
    image_ctx.translate(Math.round(stack_width / 2), 0);
    image_ctx.font = font;
    image_ctx.textBaseline = "middle";
    image_ctx.textAlign = "right";
    image_ctx.rotate(-(Math.PI / 2));
    image_ctx.fillText("" + (index + 1), 0, 0);
    this.stack_num_cache[index] = image;
  } else {
    image = this.stack_num_cache[index];
  }
  ctx.drawImage(image, 0, 0);
}

RasterizedAlphabet.prototype.draw_scale_num = function(ctx, font, num) {
  var image, image_ctx, text_size, m_length;
  if (num >= this.scale_num_cache.length) {
    image = document.createElement("canvas");
    // measure the text
    image_ctx = image.getContext('2d');
    image_ctx.font = font;
    text_size = image_ctx.measureText("" + num);
    if (text_size.actualBoundingBoxAscent && text_size.actualBoundingBoxDesent) {
      // resize the canvas to fit
      image.width = Math.ceil(text_size.width);
      image.height = Math.ceil(text_size.actualBoundingBoxAscent + text_size.actualBoundingBoxDesent);
      // draw the text
      image_ctx = image.getContext('2d');
      image_ctx.font = font;
      image_ctx.textAlign = "right";
      image_ctx.fillText("" + num, image.width, text_size.actualBoundingBoxAscent);
    } else {
      // measure width of 'm' to approximate height, we double it later anyway
      m_length = image_ctx.measureText("m").width;
      // resize the canvas to fit
      image.width = Math.ceil(text_size.width);
      image.height = Math.ceil(2 * m_length);
      // draw the text
      image_ctx = image.getContext('2d');
      image_ctx.font = font;
      image_ctx.textAlign = "right";
      image_ctx.textBaseline = "middle";
      image_ctx.fillText("" + num, image.width, m_length);
    }
    this.scale_num_cache[num] = image;
  } else {
    image = this.scale_num_cache[num];
  }
  ctx.drawImage(image, -image.width, -Math.round(image.height / 2))
}

//======================================================================
// end RasterizedAlphabet
//======================================================================

//======================================================================
// start LogoMetrics object
//======================================================================

var LogoMetrics = function(ctx, logo_columns, logo_rows, has_names, has_finetext, x_axis, y_axis) {
  "use strict";
  var i, row_height;
  //variable prototypes
  this.pad_top = (has_names ? 5 : 0);
  this.pad_left = (y_axis ? 10 : 0);
  this.pad_right = (has_finetext ? 15 : 0);
  this.pad_bottom = 0;
  this.pad_middle = 20;
  this.name_height = 14;
  this.name_font = "bold " + this.name_height + "px Times, sans-serif";
  this.name_spacer = 0;
  this.y_axis = y_axis;
  this.y_label = "bits";
  this.y_label_height = 12;
  this.y_label_font = "bold " + this.y_label_height + "px Helvetica, sans-serif";
  this.y_label_spacer = 3;
  this.y_num_height = 12;
  this.y_num_width = 0;
  this.y_num_font = "bold " + this.y_num_height + "px Helvetica, sans-serif";
  this.y_tic_width = 5;
  this.stack_pad_left = 0;
  this.stack_font = "bold 25px Helvetica, sans-serif";
  this.stack_height = 90;
  this.stack_width = 26;
  this.stacks_pad_right = 5;
  this.x_axis = x_axis;
  this.x_num_above = 2;
  this.x_num_height = 12;
  this.x_num_width = 0;
  this.x_num_font = "bold " + this.x_num_height + "px Helvetica, sans-serif";
  this.fine_txt_height = 6;
  this.fine_txt_above = 2;
  this.fine_txt_font = "normal " + this.fine_txt_height + "px Helvetica, sans-serif";
  this.letter_metrics = new Array();
  this.summed_width = 0;
  this.summed_height = 0;
  //calculate the width of the y axis numbers
  ctx.font = this.y_num_font;
  for (i = 0; i <= 2; i++) {
    this.y_num_width = Math.max(this.y_num_width, ctx.measureText("" + i).width);
  }
  //calculate the width of the x axis numbers (but they are rotated so it becomes height)
  if (x_axis == 1) {
    ctx.font = this.x_num_font;
    for (i = 1; i <= logo_columns; i++) {
      this.x_num_width = Math.max(this.x_num_width, ctx.measureText("" + i).width);
    }
  } else if (x_axis == 0) {
    this.x_num_height = 4;
    this.x_num_width = 4;
  } else {
    this.x_num_height = 0;
    this.x_num_width = 0;
  }
  
  //calculate how much vertical space we want to draw this
  //first we add the padding at the top and bottom since that's always there
  this.summed_height += this.pad_top + this.pad_bottom;
  //all except the last row have the same amount of space allocated to them
  if (logo_rows > 1) {
    row_height = this.stack_height + this.pad_middle;
    if (has_names) {
      row_height += this.name_height;
      //the label is allowed to overlap into the spacer
      row_height += Math.max(this.y_num_height/2, this.name_spacer); 
      //the label is allowed to overlap the space used by the other label
      row_height += Math.max(this.y_num_height/2, this.x_num_height + this.x_num_above); 
    } else {
      row_height += this.y_num_height/2; 
      //the label is allowed to overlap the space used by the other label
      row_height += Math.max(this.y_num_height/2, this.x_num_height + this.x_num_above); 
    }
    this.summed_height += row_height * (logo_rows - 1);
  }
  //the last row has the name and fine text below it but no padding
  this.summed_height += this.stack_height + (this.y_axis ? this.y_num_height/2 : 0);

  var fine_txt_total = (has_finetext ? this.fine_txt_height + this.fine_txt_above : 0);
  if (has_names) {
    this.summed_height += fine_txt_total + this.name_height;
    this.summed_height += Math.max((this.y_axis ? this.y_num_height/2 : 0), 
        this.x_num_height + this.x_num_above + this.name_spacer);
  } else {
    this.summed_height += Math.max((this.y_axis ? this.y_num_height/2 : 0), 
        this.x_num_height + this.x_num_above + fine_txt_total);
  }

  //calculate how much horizontal space we want to draw this
  //first add the padding at the left and right since that's always there
  this.summed_width += this.pad_left + this.pad_right;
  if (this.y_axis) {
    //add on the space for the y-axis label
    this.summed_width += this.y_label_height + this.y_label_spacer;
    //add on the space for the y-axis
    this.summed_width += this.y_num_width + this.y_tic_width;
  }
  //add on the space for the stacks
  this.summed_width += (this.stack_pad_left + this.stack_width) * logo_columns;
  //add on the padding after the stacks (an offset from the fine text)
  this.summed_width += this.stacks_pad_right;

};

//======================================================================
// end LogoMetrics object
//======================================================================

//found this trick at http://talideon.com/weblog/2005/02/detecting-broken-images-js.cfm
function image_ok(img) {
  "use strict";
  // During the onload event, IE correctly identifies any images that
  // weren't downloaded as not complete. Others should too. Gecko-based
  // browsers act like NS4 in that they report this incorrectly.
  if (!img.complete) {
    return false;
  }
  // However, they do have two very useful properties: naturalWidth and
  // naturalHeight. These give the true size of the image. If it failed
  // to load, either of these should be zero.
  if (typeof img.naturalWidth !== "undefined" && img.naturalWidth === 0) {
    return false;
  }
  // No other way of checking: assume it's ok.
  return true;
}
  
function supports_text(ctx) {
  "use strict";
  if (!ctx.fillText) {
    return false;
  }
  if (!ctx.measureText) {
    return false;
  }
  return true;
}

//draws the scale, returns the width
function draw_scale(ctx, metrics, alphabet_ic, raster) {
  "use strict";
  var tic_height, i;
  tic_height = metrics.stack_height / alphabet_ic;
  ctx.save();
  ctx.translate(metrics.y_label_height, metrics.y_num_height/2);
  //draw the axis label
  ctx.save();
  ctx.font = metrics.y_label_font;
  ctx.translate(0, metrics.stack_height/2);
  ctx.rotate(-(Math.PI / 2));
  ctx.textAlign = "center";
  ctx.fillText("bits", 0, 0);
  ctx.restore();

  ctx.translate(metrics.y_label_spacer + metrics.y_num_width, 0);

  //draw the axis tics
  ctx.save();
  ctx.translate(0, metrics.stack_height);
  for (i = 0; i <= alphabet_ic; i++) {
    //draw the number
    ctx.save();
    ctx.translate(-1, 0);
    raster.draw_scale_num(ctx, metrics.y_num_font, i);
    ctx.restore();
    //draw the tic
    ctx.fillRect(0, -1, metrics.y_tic_width, 2);
    //prepare for next tic
    ctx.translate(0, -tic_height);
  }
  ctx.restore();

  ctx.fillRect(metrics.y_tic_width - 2, 0, 2, metrics.stack_height)

  ctx.restore();
}

function draw_stack_num(ctx, metrics, row_index, raster) {
  "use strict";
  ctx.save();
  ctx.translate(0, Math.round(metrics.stack_height + metrics.x_num_above));
  if (metrics.x_axis == 1) {
    raster.draw_stack_num(ctx, metrics.x_num_font, metrics.stack_width, row_index);
  } else if (metrics.x_axis == 0) {
    // draw dots instead of the numbers (good for small logos)
    ctx.beginPath();
    var radius = Math.round(metrics.x_num_height / 2);
    ctx.arc(Math.round(metrics.stack_width / 2), radius, radius, 0, 2 * Math.PI, false);
    ctx.fill();
  }
  ctx.restore();
}

function draw_stack(ctx, metrics, symbols, raster) {
  "use strict";
  var preferred_pad, sym_min, i, sym, sym_height, pad;
  preferred_pad = 0;
  sym_min = 5;

  ctx.save();//1
  ctx.translate(0, metrics.stack_height);
  for (i = 0; i < symbols.length; i++) {
    sym = symbols[i];
    sym_height = metrics.stack_height * sym.get_scale();
    
    pad = preferred_pad;
    if (sym_height - pad < sym_min) {
      pad = Math.min(pad, Math.max(0, sym_height - sym_min));
    }
    sym_height -= pad;

    //translate to the correct position
    ctx.translate(0, -(pad/2 + sym_height));

    //draw
    raster.draw_stack_sym(ctx, sym.get_symbol(), 0, 0, metrics.stack_width, sym_height);
    //translate past the padding
    ctx.translate(0, -(pad/2));
  }
  ctx.restore();//1
}

function draw_dashed_line(ctx, pattern, start, x1, y1, x2, y2) {
  "use strict";
  var x, y, len, i, dx, dy, tlen, theta, mulx, muly, lx, ly;
  dx = x2 - x1;
  dy = y2 - y1;
  tlen = Math.pow(dx*dx + dy*dy, 0.5);
  theta = Math.atan2(dy,dx);
  mulx = Math.cos(theta);
  muly = Math.sin(theta);
  lx = [];
  ly = [];
  for (i = 0; i < pattern; ++i) {
    lx.push(pattern[i] * mulx);
    ly.push(pattern[i] * muly);
  }
  i = start;
  x = x1;
  y = y1;
  len = 0;
  ctx.beginPath();
  while (len + pattern[i] < tlen) {
    ctx.moveTo(x, y);
    x += lx[i];
    y += ly[i];
    ctx.lineTo(x, y);
    len += pattern[i];
    i = (i + 1) % pattern.length;
    x += lx[i];
    y += ly[i];
    len += pattern[i];
    i = (i + 1) % pattern.length;
  }
  if (len < tlen) {
    ctx.moveTo(x, y);
    x += mulx * (tlen - len);
    y += muly * (tlen - len);
    ctx.lineTo(x, y);
  }
  ctx.stroke();
}

function draw_trim_background(ctx, metrics, left_start, left_end, left_divider, right_start, right_end, right_divider) {
  "use strict";
  var left_size = left_end - left_start;
  var right_size = right_end - right_start;
  var line_x;

  ctx.save();//s8
  ctx.fillStyle = "rgb(240, 240, 240)";
  if (left_size > 0) {
    ctx.fillRect(left_start * metrics.stack_width, 0, left_size * metrics.stack_width, metrics.stack_height);
  }
  if (right_size > 0) {
    ctx.fillRect(right_start * metrics.stack_width, 0, right_size * metrics.stack_width, metrics.stack_height);
  }
  ctx.fillStyle = "rgb(51, 51, 51)";
  if (left_size > 0 && left_divider) {
    line_x = (left_end * metrics.stack_width) - 0.5;
    draw_dashed_line(ctx, [3], 0, line_x, 0, line_x, metrics.stack_height);
  }
  if (right_size > 0 && right_divider) {
    line_x = (right_start * metrics.stack_width) + 0.5;
    draw_dashed_line(ctx, [3], 0, line_x, 0, line_x, metrics.stack_height);
  }
  ctx.restore();//s8
}

function size_logo_on_canvas(logo, canvas, show_names, scale) {
  "use strict";
  var draw_name, draw_finetext, metrics;
  draw_name = (typeof show_names === "boolean" ? show_names : (logo.get_rows() > 1));
  draw_finetext = (logo.fine_text.length > 0);
  if (canvas.width !== 0 && canvas.height !== 0) {
    return;
  }
  metrics = new LogoMetrics(canvas.getContext('2d'), 
      logo.get_xlate_columns(), logo.get_rows(), draw_name, draw_finetext, logo.x_axis, logo.y_axis);
  if (typeof scale == "number") {
    //resize the canvas to fit the scaled logo
    canvas.width = metrics.summed_width * scale;
    canvas.height = metrics.summed_height * scale;
  } else {
    if (canvas.width === 0 && canvas.height === 0) {
      canvas.width = metrics.summed_width;
      canvas.height = metrics.summed_height;
    } else if (canvas.width === 0) {
      canvas.width = metrics.summed_width * (canvas.height / metrics.summed_height);
    } else if (canvas.height === 0) {
      canvas.height = metrics.summed_height * (canvas.width / metrics.summed_width);
    }
  }
}

function draw_logo_on_canvas(logo, canvas, show_names, scale) {
  "use strict";
  var i, draw_name, draw_finetext, ctx, metrics, raster, pspm_i, pspm, 
      offset, col_index, motif_position, ssc;
  ssc = false;
  draw_name = (typeof show_names === "boolean" ? show_names : (logo.get_rows() > 1));
  draw_finetext = (logo.fine_text.length > 0);
  ctx = canvas.getContext('2d');
  //assume that the user wants the canvas scaled equally so calculate what the best width for this image should be
  metrics = new LogoMetrics(ctx, logo.get_xlate_columns(), logo.get_rows(), draw_name, draw_finetext, logo.x_axis, logo.y_axis);
  if (typeof scale == "number") {
    //resize the canvas to fit the scaled logo
    canvas.width = metrics.summed_width * scale;
    canvas.height = metrics.summed_height * scale;
  } else {
    if (canvas.width === 0 && canvas.height === 0) {
      scale = 1;
      canvas.width = metrics.summed_width;
      canvas.height = metrics.summed_height;
    } else if (canvas.width === 0) {
      scale = canvas.height / metrics.summed_height;
      canvas.width = metrics.summed_width * scale;
    } else if (canvas.height === 0) {
      scale = canvas.width / metrics.summed_width;
      canvas.height = metrics.summed_height * scale;
    } else {
      scale = Math.min(canvas.width / metrics.summed_width, canvas.height / metrics.summed_height);
    }
  }
  // cache the raster based on the assumption that we will be drawing a lot
  // of logos the same size and alphabet
  if (typeof draw_logo_on_canvas.raster_cache === "undefined") {
    draw_logo_on_canvas.raster_cache = [];
  }
  for (i = 0; i < draw_logo_on_canvas.raster_cache.length; i++) {
    raster = draw_logo_on_canvas.raster_cache[i];
    if (raster.get_alphabet().equals(logo.alphabet) &&
        Math.abs(raster.get_scale() - scale) < 0.1) break;
    raster = null;
  }
  if (raster == null) {
    raster = new RasterizedAlphabet(logo.alphabet, scale, metrics.stack_font, metrics.stack_width);
    draw_logo_on_canvas.raster_cache.push(raster);
  }
  ctx = canvas.getContext('2d');
  ctx.save();//s1
  ctx.scale(scale, scale);
  ctx.save();//s2
  ctx.save();//s7
  //create margin
  ctx.translate(Math.round(metrics.pad_left), Math.round(metrics.pad_top));
  for (pspm_i = 0; pspm_i < logo.get_rows(); ++pspm_i) {
    pspm = logo.get_pspm(pspm_i);
    offset = logo.get_offset(pspm_i);
    //optionally draw name if this isn't the last row or is the only row 
    if (draw_name && (logo.get_rows() == 1 || pspm_i != (logo.get_rows()-1))) {
      ctx.save();//s4
      ctx.translate(Math.round(metrics.summed_width/2), Math.round(metrics.name_height));
      ctx.font = metrics.name_font;
      ctx.textAlign = "center";
      ctx.fillText(pspm.name, 0, 0);
      ctx.restore();//s4
      ctx.translate(0, Math.round(metrics.name_height + 
          Math.min(0, metrics.name_spacer - metrics.y_num_height/2)));
    }
    //draw scale
    if (logo.y_axis) draw_scale(ctx, metrics, logo.alphabet.get_ic(), raster);
    ctx.save();//s5
    //translate across past the scale
    if (logo.y_axis) {
      ctx.translate(Math.round(metrics.y_label_height + metrics.y_label_spacer + 
        metrics.y_num_width + metrics.y_tic_width), Math.round(metrics.y_num_height / 2));
    }
    //draw the trimming background
    if (pspm.get_left_trim() > 0 || pspm.get_right_trim() > 0) {
      var left_start = offset * logo.get_xlate_nsyms();
      var left_end = (offset + pspm.get_left_trim()) * logo.get_xlate_nsyms();
      var left_divider = true;
      if (left_end < logo.get_xlate_start() || left_start > logo.get_xlate_end()) {
        // no overlap
        left_start = 0;
        left_end = 0;
        left_divider = false;
      } else {
        if (left_start < logo.get_xlate_start()) {
          left_start = logo.get_xlate_start();
        }
        if (left_end > logo.get_xlate_end()) {
          left_end = logo.get_xlate_end();
          left_divider = false;
        }
        left_start -= logo.get_xlate_start();
        left_end -= logo.get_xlate_start();
        if (left_end < left_start) {
          left_start = 0;
          left_end = 0;
          left_divider = false;
        }
      }
      var right_end = (offset + pspm.get_motif_length()) * logo.get_xlate_nsyms();
      //var right_start = right_end - (pspm.get_left_trim() * logo.get_xlate_nsyms());
      var right_start = right_end - (pspm.get_right_trim() * logo.get_xlate_nsyms());
      var right_divider = true;
      if (right_end < logo.get_xlate_start() || right_start > logo.get_xlate_end()) {
        // no overlap
        right_start = 0;
        right_end = 0;
        right_divider = false;
      } else {
        if (right_start < logo.get_xlate_start()) {
          right_start = logo.get_xlate_start();
          right_divider = false;
        }
        if (right_end > logo.get_xlate_end()) {
          right_end = logo.get_xlate_end();
        }
        right_start -= logo.get_xlate_start();
        right_end -= logo.get_xlate_start();
        if (right_end < right_start) {
          right_start = 0;
          right_end = 0;
          right_divider = false;
        }
      }
      draw_trim_background(ctx, metrics, left_start, left_end, left_divider, right_start, right_end, right_divider);
    }
    //draw letters
    var xlate_col;
    for (xlate_col = logo.get_xlate_start(); xlate_col < logo.get_xlate_end(); xlate_col++) {
      ctx.translate(metrics.stack_pad_left,0);
      col_index = Math.floor(xlate_col / logo.get_xlate_nsyms());
      if (xlate_col % logo.get_xlate_nsyms() == 0) {
        if (col_index >= offset && col_index < (offset + pspm.get_motif_length())) {
          motif_position = col_index - offset;
          draw_stack_num(ctx, metrics, motif_position, raster);
          draw_stack(ctx, metrics, pspm.get_stack(motif_position, logo.alphabet, ssc), raster);
        }
      } else {
        if (col_index >= offset && col_index < (offset + pspm.get_motif_length())) {
          ctx.save();// s5.1
          ctx.translate(0, Math.round(metrics.stack_height));
          // TODO draw a dot or dash or something to indicate continuity of the motif
          ctx.restore(); //s5.1
        }
      }
      ctx.translate(Math.round(metrics.stack_width), 0);
    }
    ctx.restore();//s5
    ////optionally draw name if this is the last row but isn't the only row 
    if (draw_name && (logo.get_rows() != 1 && pspm_i == (logo.get_rows()-1))) {
      //translate vertically past the stack and axis's        
      ctx.translate(0, metrics.y_num_height/2 + metrics.stack_height + 
          Math.max(metrics.y_num_height/2, metrics.x_num_above + metrics.x_num_width + metrics.name_spacer));

      ctx.save();//s6
      ctx.translate(metrics.summed_width/2, metrics.name_height);
      ctx.font = metrics.name_font;
      ctx.textAlign = "center";
      ctx.fillText(pspm.name, 0, 0);
      ctx.restore();//s6
      ctx.translate(0, metrics.name_height);
    } else {
      //translate vertically past the stack and axis's        
      ctx.translate(0, metrics.y_num_height/2 + metrics.stack_height + 
          Math.max(metrics.y_num_height/2, metrics.x_num_above + metrics.x_num_width));
    }
    //if not the last row then add middle padding
    if (pspm_i != (logo.get_rows() -1)) {
      ctx.translate(0, metrics.pad_middle);
    }
  }
  ctx.restore();//s7
  if (logo.fine_text.length > 0) {
    ctx.translate(metrics.summed_width - metrics.pad_right, metrics.summed_height - metrics.pad_bottom);
    ctx.font = metrics.fine_txt_font;
    ctx.textAlign = "right";
    ctx.fillText(logo.fine_text, 0,0);
  }
  ctx.restore();//s2
  ctx.restore();//s1
}

function create_canvas(c_width, c_height, c_id, c_title, c_display) {
  "use strict";
  var canvas = document.createElement("canvas");
  //check for canvas support before attempting anything
  if (!canvas.getContext) {
    return null;
  }
  var ctx = canvas.getContext('2d');
  //check for html5 text drawing support
  if (!supports_text(ctx)) {
    return null;
  }
  //size the canvas
  canvas.width = c_width;
  canvas.height = c_height;
  canvas.id = c_id;
  canvas.title = c_title;
  canvas.style.display = c_display;
  return canvas;
}

function logo_1(alphabet, fine_text, pspm) {
  "use strict";
  var logo = new Logo(alphabet, fine_text);
  logo.add_pspm(pspm);
  return logo;
}

function logo_2(alphabet, fine_text, target, query, query_offset) {
  "use strict";
  var logo = new Logo(alphabet, fine_text);
  if (query_offset < 0) {
    logo.add_pspm(target, -query_offset);
    logo.add_pspm(query);
  } else {
    logo.add_pspm(target);
    logo.add_pspm(query, query_offset);
  }      
  return logo;
}

/*
 * Specifies an alternate source for an image.
 * If the image with the image_id specified has
 * not loaded then a generated logo will be used 
 * to replace it.
 *
 * Note that the image must either have dimensions
 * or a scale must be set.
 */
function alternate_logo(logo, image_id, scale) {
  "use strict";
  var image = document.getElementById(image_id);
  if (!image) {
    alert("Can't find specified image id (" +  image_id + ")");
    return;
  }
  //if the image has loaded then there is no reason to use the canvas
  if (image_ok(image)) {
    return;
  }
  //the image has failed to load so replace it with a canvas if we can.
  var canvas = create_canvas(image.width, image.height, image_id, image.title, image.style.display);
  if (canvas === null) {
    return;
  }
  //draw the logo on the canvas
  draw_logo_on_canvas(logo, canvas, null, scale);
  //replace the image with the canvas
  image.parentNode.replaceChild(canvas, image);
}

/*
 * Specifies that the element with the specified id
 * should be replaced with a generated logo.
 */
function replace_logo(logo, replace_id, scale, title_txt, display_style) {
  "use strict";
  var element = document.getElementById(replace_id);
  if (!replace_id) {
    alert("Can't find specified id (" + replace_id + ")");
    return;
  }
  //found the element!
  var canvas = create_canvas(50, 120, replace_id, title_txt, display_style);
  if (canvas === null) {
    return;
  }
  //draw the logo on the canvas
  draw_logo_on_canvas(logo, canvas, null, scale);
  //replace the element with the canvas
  element.parentNode.replaceChild(canvas, element);
}

/*
 * Fast string trimming implementation found at
 * http://blog.stevenlevithan.com/archives/faster-trim-javascript
 *
 * Note that regex is good at removing leading space but
 * bad at removing trailing space as it has to first go through
 * the whole string.
 */
function trim (str) {
  "use strict";
  var ws, i;
  str = str.replace(/^\s\s*/, '');
  ws = /\s/; i = str.length;
  while (ws.test(str.charAt(--i)));
  return str.slice(0, i + 1);
}

//
// Delay drawing a logo
//
var DelayLogoTask = function(logo, canvas) {
  "use strict";
  canvas.width = canvas.width; // clear canvas
  this.logo = logo;
  this.canvas = canvas;
};

DelayLogoTask.prototype.run = function () {
  "use strict";
  this.canvas.width = this.canvas.width; // clear canvas
  draw_logo_on_canvas(this.logo, this.canvas, false);
};

/*
 * Make a canvas with the motif logo drawn on it.
 */
function make_logo(alphabet, pspm, height, rc, offset, className) {
  if (rc) pspm = pspm.copy().reverse_complement(alphabet);
  var logo = new Logo(alphabet);
  logo.add_pspm(pspm, offset);
  var canvas = document.createElement('canvas');
  var sizeit = (height < 0);
  canvas.height = (sizeit ? -height : height); 
  canvas.width = 0;
  canvas.className = className;
  if (sizeit) size_logo_on_canvas(logo, canvas, false);
  add_draw_task(canvas, new DelayLogoTask(logo, canvas));
  return canvas;
}

    </script>
    <script type="text/javascript">
//
// centrimo_doc.js
//

//
// Function to return the HTML text of a given type.
// This function can be used directly to document the output format (xx-output-format.html)
// and indirectly via print_doc_para for help pop-ups in the actual output HTML,
// to prevent duplication of documentation.
//
function get_centrimo_doc_text(doc_type, extra) {
  if (extra == undefined) {extra = ""};

  switch (doc_type) {
    case 'centrimo-adj-pvalue':
      return(`
        The statistical significance of the enrichment of the motif, adjusted for multiple tests. ` + extra + `
      `);
    case 'centrimo-evalue':
      var evalue_html = `
        at least one region as enriched for best matches to the motif as the reported region
        (or would have optimal average distance to the sequence center as low as observed,
        if you used the <code>--cd</code> option).
      `;
      return(`
        The expected number motifs that would have ` + (extra ? extra : evalue_html) + `
        The <i>E</i>-value is the adjusted <i>p</i>-value multiplied by the number of motifs in the
        input files(s).</td> </tr>
      `);
    case 'centrimo-bin-width':
      return(`
        The width (in sequence positions) of the most enriched region (default),
        <b>or</b> two times the average distance between the center of the best site
        and the sequence center if you used the option <code>--cd</code>.
        A best match to the motif is counted as being in the region if
        the center of the motif falls in the region.
      `);
    case 'centrimo-sites-in-bin':
      return(`
        The number of (positive) sequences whose best match to the motif `
        + (extra ? extra : "falls in the reported region (default) or anywhere in the sequence (if you used the option <code>--cd</code>).") + `
        <br>Note: This number may be less than the number of
        (positive) sequences that have a best match in the region.
        The reason for this is that a sequence may have many matches that score
        equally best.  If <i>n</i> matches have the best score in a sequence, 1/<i>n</i> is added to the
        appropriate bin for each match.</td> </tr>
      `);
    case 'centrimo-mult-tests':
      return(`
        This is the number of multiple tests (<i>n</i>) done for this motif.
        It was used to adjust the <i>p</i>-value of a region for
        multiple tests using the formula:
        <br>&nbsp;&nbsp;
          <i>p</i>' = 1 - (1-<i>p</i>)<sup><i>n</i></sup> where <i>p</i> is the unadjusted <i>p</i>-value.
        <br>
        The number of multiple tests is the number of regions
        considered times the number of score thresholds considered.
        It depends on the motif length, sequence length, and the type of
        optimizations being done (central enrichment, local enrichment, central distance or
        score optimization).</td> </tr>
      `);

    case 'centrimo-results-tsv':
      return(` 
        <p>
          CentriMo outputs a tab-separated values (TSV) file ('centrimo.tsv') that contains one line for each
          region found to be significantly enriched for a motif.
          The lines are sorted in order of decreasing statistical significance.
          The first line in the file contains the (tab-separated) names of the fields.
          Your command line is given at the end of the file in a comment line starting with the
          character '#'.
          The names and meanings of each of the fields, which depend on whether or not you provide
          control sequences to CentriMo, are described in the table below.
        </p>
        <table class="dark" style="width:100%" border=1>
          <tr> <th>field</th> <th>name</th> <th>contents</th> </tr>
          <tr> <td>1</td> <td>db_index</td> <td>The index of the motif file that contains the motif.  Motif
              files are numbered in the order the appeared in the command line.</td> </tr>
          <tr> <td>2</td> <td>motif_id</td> <td> ` + get_doc_text('shared', 'motif-id') + `
              If more than one motif has the same ID, CentriMo uses only the first such motif.
              The name is single-quoted and preceded with '+' or '-' if you scanned separately with
              the reverse complement motif (using the <code>--sep</code> option).</td> </tr>
          <tr> <td>3</td> <td>motif_alt_id</td> <td> ` + get_doc_text('shared', 'motif-alt-id') + `</td> </tr>
          <tr> <td>4</td> <td>consensus</td> <td> ` + get_doc_text('shared', 'motif-cons') + `</td> </tr>
          <tr> <td>5</td> <td>E-value</td> <td> ` + get_doc_text('centrimo', 'centrimo-evalue') + `</td> </tr>
          <tr> <td>6</td> <td>adj_p-value</td> <td> ` + get_doc_text('centrimo', 'centrimo-adj-pvalue') + `
              By default, a <i>p</i>-value is calculated by using the one-tailed binomial
              test on the number of sequences with a match to the motif
              that have their best match in the reported region;
              if you provided control sequences, the <i>p</i>-value of Fisher\'s exact test on the enrichment of
              best matches in the positive sequences relative to the negative sequences is computed instead;
              if you used the <code>--cd</code> option, the <i>p</i>-value is the probability that the average
              distance between the best site and the sequence center would be as low or lower than observed,
              computed using the cumulative Bates distribution, optimized over different score thresholds.
              In all cases, the reported <i>p</i>-value has been adjusted for the number of regions
              and/or score thresholds tested.</td> </tr>
          <tr> <td>7</td> <td>log_adj_p-value</td> <td>Log of adjusted <i>p</i>-value.</td> </tr>
          <tr> <td>8</td> <td>bin_location</td> <td>Location of the center of the most enriched region, or
                0 if you used the <code>--cd</code> option.
          <tr> <td>9</td> <td>bin_width</td> <td> ` + get_doc_text('centrimo', 'centrimo-bin-width') + `</td> </tr>
          <tr> <td>10</td> <td>total_width</td> <td>The maximum number of regions possible for this motif
              <br>&nbsp;&nbsp;
              round(sequence_length - motif_length + 1)/2,<br>
              or the number of places the motif will fit if you used the <code>--cd</code> option.</td> </tr>
          <tr> <td>11</td> <td>sites_in_bin</td> <td> ` + get_doc_text('centrimo', 'centrimo-sites-in-bin') + `</td> </tr>
          <tr> <td>12</td> <td>total_sites</td> <td>The number of sequences containing a match to the motif
              above the score threshold.
          <tr> <td>13</td> <td>p_success</td> <td>The probability of a random match falling into the enriched region:
              <br>&nbsp;&nbsp;
              bin_width / total_width</td> </tr>
          <tr> <td>14</td> <td>p-value</td> <td>The uncorrected <i>p</i>-value before it gets adjusted for the
              number of multiple tests to give the adjusted <i>p</i>-value.</td> </tr>
          <tr> <td>15</td> <td>mult_tests</td> <td> ` + get_doc_text('centrimo', 'centrimo-mult-tests') + `</td> </tr>
          <tr> <th colspan=3>The following additional columns are present when you provide control sequences to CentriMo
          (using the <code>--neg</code> option).</th> </tr>
          <tr> <td>16</td> <td>neg_sites_in_bin</td> <td>The number of negative sequences where the best
              match to the motif falls in the reported region.
              This value is rounded but the underlying value may contain fractional counts.
              Note: This number may be less than the number of negative have a best match in the region.
              The reason for this is that a sequence may have many matches that score equally best.
              If n matches have the best score in a sequence, 1/n is added to the
              appropriate bin for each match.</td> </tr>
          <tr> <td>17</td> <td>neg_sites</td> <td>The number of negative sequences containing a match to the
              motif above the minimum score threshold.
              When score optimization is enabled the score threshold may be raised
              higher than the minimum.</td> </tr>
          <tr> <td>18</td> <td>neg_adj_pvalue</td> <td>The probability that any tested region in the negative
              sequences would be as enriched for best matches to this motif
              according to the Binomial test.</td> </tr>
          <tr> <td>19</td> <td>log_neg_adj_pvalue</td> <td>Log of negative adjusted <i>p</i>-value.</td> </tr>
          <tr> <td>20</td> <td>fisher_adj_pvalue</td> <td>Fisher adjusted <i>p</i>-value before it gets adjusted for the
              number of motifs in the input files(s).</td> </tr>
          <tr> <td>21</td> <td>log_fisher_adj_pvalue</td> <td>Log of Fisher adjusted <i>p</i>-value.</td> </tr>
        </table>
      `);

    case 'centrimo-sites-txt':
      return(`
        <p>
          CentriMo outputs a text file ('site_counts.txt') that contains,
          for each motif, pairs of values (bin_position, site_count),
          or triples of values (bin_position, site_count, neg_site_count) if
          you provided control sequences to CentriMo.
          This data can be used to plot the density of motif best matches (sites)
          along the input sequences.  Fractional counts are possible if multiple (n)
          bins contain the best match for a given sequence, with each bin
          receiving an incremental count of 1/n.
        </p>
        <p>
          The data for each motif begins with a header line with the format:
          <br>&nbsp&nbsp
                DB &lt;db_number&gt; MOTIF &lt;id&gt; &lt;alt&gt;
          </br>
          where &lt;id&gt; and &lt;alt&gt; are as described above.
          The following lines (up to the next header line)
          each contain a single value-pair or value-triple for the motif
          named in the header line.
        </p>
      `);

    default:
      Return("Error--Unrecognized centrimo doc_type: " + doc_type);
  }
} // get_centrimo_doc_text

    </script>
    <script type="text/javascript">
//
// simple-shared-doc.js
//

//
// Function to redirect to appropriate doc file.
//
function get_doc_text(pgm, doc_type, extra, extra2) {
  switch (pgm) {
    case 'shared':
      return(get_shared_doc_text(doc_type, extra, extra2));
    case 'ame':
      return(get_ame_doc_text(doc_type, extra, extra2));
    case 'centrimo':
      return(get_centrimo_doc_text(doc_type, extra, extra2));
    case 'discovery':
      return(get_discovery_doc_text(doc_type, extra, extra2));
    case 'fimo':
      return(get_fimo_doc_text(doc_type, extra, extra2));
    case 'gomo':
      return(get_gomo_doc_text(doc_type, extra, extra2));
    case 'mcast':
      return(get_mcast_doc_text(doc_type, extra, extra2));
    case 'meme-chip':
      return(get_meme_chip_doc_text(doc_type, extra, extra2));
    case 'momo':
      return(get_momo_doc_text(doc_type, extra, extra2));
    case 'sea':
      return(get_sea_doc_text(doc_type, extra, extra2));
    case 'spamo':
      return(get_spamo_doc_text(doc_type, extra, extra2));
    case 'streme':
      return(get_streme_doc_text(doc_type, extra, extra2));
    case 'tgene':
      return(get_tgene_doc_text(doc_type, extra, extra2));
    case 'tomtom':
      return(get_tomtom_doc_text(doc_type, extra, extra2));
    case 'xstreme':
      return(get_xstreme_doc_text(doc_type, extra, extra2));
    default:
      return("<b>Unknown program type: <font color=red>" + pgm + "</font></b>");
  }
} // get_doc_text

//
// Function to replace the innerHTML of element "id" with the HTML indicated by "doc_type".
// Easier to read and update than the more flexible approach in shared-doc.js. 
//
function print_doc(id, pgm, doc_type, extra) {
  document.getElementById(id).insertAdjacentHTML('beforeend', get_doc_text(pgm, doc_type, extra));
} // print_doc

//
// Function to replace the innerHTML of element "id" with an HTML paragraph
// containing the text for 'pgm' and 'doc_type'.
// This function can be used in help pop-ups.
//
function print_doc_para(id, pgm, doc_type, extra, extra2) {
  html = "<p>" + get_doc_text(pgm, doc_type, extra, extra2) + "</p>"; 
  document.getElementById(id).insertAdjacentHTML('beforeend', html);
} // print_doc_para

//
// Function to return the Shared HTML text of a given type.
// This function can be used directly to document the output format (xx-output-format.html)
// and indirectly via print_doc_para for help pop-ups in the actual output HTML,
// to prevent duplication of documentation.
//
function get_shared_doc_text(doc_type, extra, extra2) {
  if (extra == undefined) {extra = ""};
  if (extra2 == undefined) {extra2 = ""};
  switch (doc_type) {
    case 'motif-db':
      return(`
	The name of ` + extra2 + ` a file of motifs ("motif database file") that contains ` + extra + `
      `);
    case 'motif-id':
      return(`
	The name of the ` + extra + ` motif, which is unique ` + extra2 + ` in the motif database file.
      `);
    case 'motif-alt-id':
      return(`
	An alternate name for the ` + extra + ` motif that may be provided ` + extra2 + ` in the motif database file.
      `);
    case 'motif-width':
      return(`
	The width of the motif. No gaps are allowed in motifs supplied to ` + extra + `
        as it only works for motifs of a fixed width.
      `);
    case 'motif-cons':
      return(`
	A consensus sequence computed from the ` + extra + ` motif (as described <a href="#consensus_doc">below</a>).
      `);
    case 'motif-match-score':
     return(`
	` + extra2 + ` The motif match score of a position in a sequence is
	computed by summing the appropriate entry from each column of the
	position-dependent scoring matrix that represents the motif. ` + extra + `
     `);
    case 'motif-match-p-value':
      return(`
	The <i>p</i>-value of a motif match is the probability of a single random
	subsequence of the length of the motif
	<a href="javascript:help_refine('pop_motif_match_score')">scoring</a>
	at least as well as the observed match.
      `);
    case 'bh-q-value':
      if (extra2 == "") extra2 = "match";
      return(`
	The q-value is the minimum False Discovery Rate (FDR) required to consider this
        ` + extra2 + ` significant.</br>` +
        get_shared_doc_text('bh-q-value-method', extra, extra2) + `
      `);
    case 'bh-q-value-method':
      return(`
        <br>` + extra + ` estimates q-values from all the ` + extra2 + ` <i>p</i>-values 
	using the method proposed by Benjamini & Hochberg (<i>Journal of the Royal Statistical Society B</i>, 57:289-300, 1995).
	See also Storey JD, Tibshirani R. Statistical significance for
	genome-wide studies, <i>Proc. Natl. Acad. Sci. USA</i> (2003) <b>100</b>:9440&ndash;9445.
      `);
    case 'sdb-name':
      return(`
	The name of the (FASTA) sequence database file.
      `);
    case 'sdb-psp':
      return(`
	The name of the position specific priors (PSP) file.
      `);
    case 'sdb-dist':
      return(`
	The name of the binned distribution of priors file.
      `);
    case 'sdb-count':
      return(`
	The number of sequences in the database.
      `);
    case 'sdb-letters':
      return(`
	The number of letters in the sequence database.
      `);
    case 'lastmod':
      return(`
	The date of the last modification to the ` + extra + ` database.
      `);
    case 'sequence-id':
      return(`
        The identifier of the sequence (from the FASTA sequence header line)` + extra + `
      `);
    case 'sequence-name':
      return(`
	` + extra + `name of the sequence extracted from the sequence identifier (in the FASTA sequence header line).<br>
	When you use the <code>--parse-genomic--coord</code> option, the sequence name ends at the
	first colon ':' (if any) present in the sequence\'s FASTA identifier.  Typically this is the
	chromosome or contig name.  With the <code>--parse-genomic--coord</code> option,
	the start and stop positions are in 0-based coordinates relative to the sequence start given 
	in the FASTA sequence identifier (just after the sequence name).</td> </tr>
      `);
    case 'sequence-desc':
      return(`
        The description appearing after the identifier of the sequence in the FASTA header line.
      `);
    case 'sequence-name':
    case 'alph-name':
      return(`
	The name of the alphabet symbol.
      `);
    case 'alph-bg':
      return(`
	The frequency of the alphabet symbol as defined by the background model.
      `);
    case 'match-start-seq':
      return(`
	The start position of the ` + extra + `; 1-based sequence coordinates.
      `);
    case 'match-stop-seq':
      return(`
	The end position of the ` + extra + `; 1-based sequence coordinates.
      `);
    case 'match-start-genomic':
      return(`
	The start position of the ` + extra + `; genomic coordinates.
      `);
    case 'match-stop-genomic':
      return(`
	The end position of the ` + extra + `; genomic coordinates.
      `);
    case 'parse-genomic-coord':
      return(`
	` + extra + ` was run with the <code>--parse-genomic-coord</code> option
	and has split the sequence identifier into sequence name, sequence start and sequence end 
	in genomic coordinates.
      `);
    case 'motif-consensus':
      return(`
        <p id="consensus_doc">
           A <b>consensus sequence</b> is constructed from each column in a
           motif's frequency matrix using the <b>"50% rule"</b>
           as follows:
        </p>
        <ol>
          <li>The letter frequencies in the column are sorted in decreasing order.</li>
          <li>Letters with frequency less 50% of the maximum are discarded.</li>
          <li>The letter used in this position in the consensus sequence is determined
          by the first rule below that applies:</li>
          <ul>
            <li>If there is only one letter left, or if the remaining letters exactly match
            an ambiguous symbol in the alphabet, the <b>letter</b> or <b>ambiguous symbol</b>,
            respectively, is used.</li>
            <li>Otherwise, if the remaining set contains at least 50% of the core
            symbols in the alphabet, the alphabet's <b>wildcard</b>
            (e.g., "N" for DNA or RNA, and "X" for protein) is used.</li>
            <li>Otherwise, the letter with the <b>maximum frequency</b> is used.</li>
          </ul>
        </ol>
      `);
    default:
      return("Error--Unrecognized shared doc_type: " + doc_type);
  }
} // get_shared_doc_text

    </script>
    <script type="text/javascript">
function make_alpha_bg_table(alph, freqs) {
  function colour_symbol(index) {
    var span = document.createElement("span");
    span.appendChild(document.createTextNode(alph.get_symbol(index)));
    span.style.color = alph.get_colour(index);
    span.className = "alpha_symbol";
    return span;
  }
  var table, thead, tbody, row, th, span, i;
  // create table
  table = document.createElement("table");
  table.className = "alpha_bg_table";
  // create header
  thead = document.createElement("thead");
  table.appendChild(thead);
  row = thead.insertRow(thead.rows.length);
  if (alph.has_complement()) {
    add_text_header_cell(row, "Name", "pop_alph_name");
    if (freqs != null) add_text_header_cell(row, "Freq.", "pop_alph_freq");
    if (alph.has_bg()) add_text_header_cell(row, "Bg.", "pop_alph_bg");
    add_text_header_cell(row, "");
    add_text_header_cell(row, "");
    add_text_header_cell(row, "");
    if (alph.has_bg()) add_text_header_cell(row, "Bg.", "pop_alph_bg");
    if (freqs != null) add_text_header_cell(row, "Freq.", "pop_alph_freq");
    add_text_header_cell(row, "Name", "pop_alph_name");
  } else {
    add_text_header_cell(row, "");
    add_text_header_cell(row, "Name", "pop_alph_name");
    if (freqs != null) add_text_header_cell(row, "Freq.", "pop_alph_freq");
    if (alph.has_bg()) add_text_header_cell(row, "Bg.", "pop_alph_bg");
  }
  // add alphabet entries
  tbody = document.createElement("tbody");
  table.appendChild(tbody);
  if (alph.has_complement()) {
    for (i = 0; i < alph.get_size_core(); i++) {
      var c = alph.get_complement(i);
      if (i > c) continue;
      row = tbody.insertRow(tbody.rows.length);
      add_text_cell(row, alph.get_name(i));
      if (freqs != null) add_text_cell(row, "" + freqs[i]);
      if (alph.has_bg()) add_text_cell(row, "" + alph.get_bg_freq(i));
      add_cell(row, colour_symbol(i)); 
      add_text_cell(row, "~");
      add_cell(row, colour_symbol(c)); 
      if (alph.has_bg()) add_text_cell(row, "" + alph.get_bg_freq(c));
      if (freqs != null) add_text_cell(row, "" + freqs[c]);
      add_text_cell(row, alph.get_name(c));
    }
  } else {
    for (i = 0; i < alph.get_size_core(); i++) {
      row = tbody.insertRow(tbody.rows.length);
      add_cell(row, colour_symbol(i)); 
      add_text_cell(row, alph.get_name(i));
      if (freqs != null) add_text_cell(row, "" + freqs[i]);
      if (alph.has_bg()) add_text_cell(row, "" + alph.get_bg_freq(i));
    }
  }
  return table;
}


    </script>
    <script type="text/javascript">
var LEGEND_LINE = 16;
var LEGEND_FONT = "Helvetica";
var LEGEND_PAD = 5;

var Dasher = function(ctx, start_x, start_y, pattern) {
  if (typeof pattern === "undefined") pattern = [];
  this.ctx = ctx;
  this.x = start_x;
  this.y = start_y;
  this.pattern = pattern;
  this.index = 0;     // where in the pattern are we up to?
  this.fragment = 0;  // how much of the current pattern have we drawn
  this.on = true;     // pen on paper?
  ctx.moveTo(start_x, start_y);
};

Dasher.prototype.dashTo = function(x, y) {
  var dx = x - this.x;
  var dy = y - this.y;
  var d = Math.pow(dx * dx + dy * dy, 0.5);
  if (this.pattern.length == 0) {
    // when no pattern is specified this just draws lines
    this.ctx.lineTo(x, y);
  } else {
    // calculate distance to complete dash
    var dc = this.pattern[this.index] - this.fragment;
    while (dc <= d) {
      // calculate the fraction of the line needed
      var f = dc / d;
      this.x += dx * f;
      this.y += dy * f;
      if (this.on) {
        this.ctx.lineTo(this.x, this.y);
      } else {
        this.ctx.moveTo(this.x, this.y);
      }
      // move to the next dash
      this.fragment = 0;
      // skip empty dashes, just toggling on state
      do {
        this.index = (this.index + 1) % this.pattern.length;
        this.on = !this.on;
      } while (this.pattern[this.index] <= 0);
      // update variables
      dc = this.pattern[this.index];
      dx = x - this.x;
      dy = y - this.y;
      d = Math.pow(dx * dx + dy * dy, 0.5);
    }
    this.fragment += d;
    this.x = x;
    this.y = y;
    if (this.on) {
      this.ctx.lineTo(this.x, this.y);
    } else {
      this.ctx.moveTo(this.x, this.y);
    }
  }
}

var CentrimoResult = function(name, sig, colour, motif_length, 
    total_sites, site_counts, neg_total_sites, neg_site_counts) {
  "use strict";
  if (typeof name === "undefined") {
    name = "";
  }
  if (typeof sig === "undefined") {
    sig = "";
  }
  if (typeof colour == "undefined") {
    colour = "#000000";
  }
  this.name = name;
  this.sig = sig;
  this.colour = colour;
  this.motif_length = motif_length;
  this.total_sites = total_sites;
  this.site_counts = site_counts;
  this.has_neg = (typeof neg_total_sites === "number" && 
      typeof neg_site_counts === "object" && neg_site_counts instanceof Array);
  this.neg_total_sites = neg_total_sites;
  this.neg_site_counts = neg_site_counts;
};

CentrimoResult.prototype.get_site_count = function (index, mirror, neg) {
  count = neg ? this.neg_site_counts[index] : this.site_counts[index];
  if (mirror) {
    i_mirror = this.site_counts.length - 1 - index;
    return (count + (neg ? this.neg_site_counts[i_mirror] : this.site_counts[i_mirror]));
  } else {
    return count;
  }
};

/*
 * CentrimoRSet
 * Construct a centrimo result set.
 */
var CentrimoRSet = function(sequence_length) {
  "use strict";
  this.sequence_length = sequence_length;
  this.results = [];
};

/*
 * seq_len
 * Get the sequence length of the result set.
 */
CentrimoRSet.prototype.seq_len = function() {
  "use strict";
  return this.sequence_length;
};

/*
 * add
 * Add a centrimo result to the set
 */
CentrimoRSet.prototype.add = function(name, sig, colour, motif_length, 
    total_sites, site_counts, neg_total_sites, neg_site_counts) {
  "use strict";
  this.results.push(new CentrimoResult(name, sig, colour, motif_length, 
    total_sites, site_counts, neg_total_sites, neg_site_counts));
};

/*
 * count
 * Return the count of centrimo results.
 */
CentrimoRSet.prototype.count = function() {
  "use strict";
  return this.results.length;
};

/*
 *  get
 *  Get an entry in the result set.
 */
CentrimoRSet.prototype.get = function(index) {
  "use strict";
  return this.results[index];
};

/*
 * CentrimoLine
 */
var CentrimoLine = function(name, sig, colour, dash, thickness, show_on_legend, xlist, ylist) {
  "use strict";
  if (xlist.length != ylist.length) {
    throw new Error("The list of x and y points must be the same length.");
  }
  this.xlist = xlist;
  this.ylist = ylist;
  this.name = name;
  this.sig = sig;
  this.colour = colour;
  this.dash = dash;
  this.thickness = thickness;
  this.show_on_legend = show_on_legend;
  this.max_prob = -1;
};

/*
 * trim
 *
 * Removes points from the ends so the lines are the same length.
 */
CentrimoLine.prototype.trim = function(left, right) {
  "use strict";
  var lefti, righti, gradient, gap, left_y, right_y;
  if (this.xlist.length == 0) return;
  if (typeof left !== "number"|| isNaN(left)) {
    throw new Error("left trim is not a number");
  }
  if (typeof right !== "number" || isNaN(right)) {
    throw new Error("right trim is not a number");
  }
  for (lefti = 0; lefti < this.xlist.length; lefti++) {
    if (this.xlist[lefti] >= left) {
      break;
    }
  }
  if (lefti === 0 && this.xlist[0] !== left) {
    throw new Error("Attempt to undertrim line on the left.");
  }
  for (righti = this.xlist.length - 1; righti >= 0; righti--) {
    if (this.xlist[righti] <= right) {
      break;
    }
  }
  if (righti === (this.xlist.length - 1) && this.xlist[righti] !== right) {
    throw new Error("Attempt to undertrim line on the right.");
  }
  if (lefti == this.xlist.length || righti == -1) {
    // all points outside of drawable region
    this.xlist = [];
    this.ylist = [];
    return;
  }
  if (this.xlist[lefti] != left) {
    // create a new point that is exactly at left by interpolating
    gradient = (this.ylist[lefti] - this.ylist[lefti-1]) / 
      (this.xlist[lefti] - this.xlist[lefti-1]);
    gap = left - this.xlist[lefti-1];
    left_y = this.ylist[lefti-1] + gradient * gap;
    this.xlist.splice(0, lefti, left);
    this.ylist.splice(0, lefti, left_y);
    righti = righti - lefti + 1;
  } else {
    this.xlist.splice(0, lefti);
    this.ylist.splice(0, lefti);
    righti -= lefti;
  }
  if (this.xlist[righti] != right) {
    // create a new point that is exactly at right by interpolating
    gradient = (this.ylist[righti + 1] - this.ylist[righti]) /
      (this.xlist[righti + 1] - this.xlist[righti]);
    gap = right - this.xlist[righti];
    right_y = this.ylist[righti] + gradient * gap;
    // truncate the lists
    this.xlist.length = righti + 1;
    this.ylist.length = righti + 1;
    // push the new item on the end of the lists
    this.xlist.push(right);
    this.ylist.push(right_y);
  } else {
    // truncate the lists
    this.xlist.length = righti + 1;
    this.ylist.length = righti + 1;
  }
  this.max_prob = -1;
};

CentrimoLine.prototype.max = function() {
  "use strict";
  var y_max, i;
  if (this.max_prob != -1) {
    return this.max_prob;
  }
  y_max = 0;
  for (i = 0; i < this.xlist.length; i++) {
    if (this.ylist[i] > y_max) {
      y_max = this.ylist[i];
    }
  }
  this.max_prop = y_max;
  return this.max_prop;
};

/*
 * CentrimoScale
 *
 * Calculates the increments on the y axis
 */
var CentrimoScale = function(max_prob) {
  "use strict";
  var decimals, inc, rounder, max, inc_plus;
  if (max_prob === 0) {
    this.max = 0.01;
    this.inc = 0.002;
    this.digits = 3;
    return;
  }
  // find the minimum number of decimals needed to display the largest
  // digit of the maximum probability
  decimals = Math.ceil(-(Math.log(max_prob) / Math.log(10)));
  // calculate an increment which is (at minimum) 10 times smaller the the max
  inc = Math.pow(10, -(decimals+1));
  // round-up the maximum probabilty to its largest digit
  rounder = Math.pow(10, decimals);
  max = Math.ceil(max_prob * rounder) / rounder;
  // adjust the increment so it's between 5 and 12 times the maximum
  // probability
  if (inc * 5 < max && inc * 12 > max) {
    inc *= 1;
  } else if (inc * 10 < max && inc * 24 > max) {
    inc *= 2;
  } else if (inc * 25 < max && inc * 60 > max) {
    inc *= 5;
  } else if (inc * 50 < max && inc * 120 > max) {
    inc *= 10;
  }
  max += inc;
  inc_plus = (1.125 * inc);
  while (max - inc_plus > max_prob) {
    max -= inc;
  }
  max = Math.min(max, 1.0);
  this.max = max;
  this.inc = inc;
  this.digits = decimals+1;
};

var CentrimoLegendMetrics = function(lw, lh, id_w, pv_w, sq_w) {
  "use strict";
  this.width = lw;
  this.height = lh;
  this.id_width = id_w;
  this.pv_width = pv_w;
  this.sq_width = sq_w;
};

var CentrimoGraphMetrics = function(legend_metrics, top_edge, bottom_edge,
    left_mark, left_val, right_mark, right_val) {
  if (typeof legend_metrics !== "object" || legend_metrics === null) {
    this.legend_width = 10;
    this.legend_height = 10;
  } else {
    this.legend_width = legend_metrics.width;
    this.legend_height = legend_metrics.height;
  }
  this.top_edge = top_edge;
  this.bottom_edge = bottom_edge;
  this.left_mark = left_mark;
  this.left_val = left_val;
  this.right_mark = right_mark;
  this.right_val = right_val;
};

/*
 * CentrimoGraph
 * Takes a results set and a window weight array and produces a graph. 
 * The weights in the window_weights should be non-negative and sum to 1.
 */
var CentrimoGraph = function(rset, window_weights, fine_text, start, end, mirror, align, motif_width) {
  "use strict";
  var trim_left, trim_right, i, j, k, result, x, y, xpos, ypos, positions;
  var y_neg, ypos_neg, line_thickness;

  // Set the position of the vertical line.
  this.align = align ? align : "center";

  // set the width of motif
  this.motif_width = motif_width ? motif_width : 0;

  // set the length of the sequences.
  this.seq_len = rset.seq_len();

  // Set the size of the smooting window.
  this.window_width = window_weights.length;

  line_thickness = (window_weights.length < 10 ? 1 : 3);
  if (typeof fine_text !== "string") {
    fine_text = "";
  }
  if (typeof mirror !== "boolean") mirror = false;
  this.mirror = mirror;
  if (mirror) {
    if (typeof start === "number") {
      start = Math.max(0, start);
    } else {
      start = 0;
    }
  }
  this.fine_text = fine_text;
  this.lines = [];
  for (i = 0; i < rset.count(); i++) {
    result = rset.get(i);
    x = [];
    y = [];
    if (result.has_neg) {
      y_neg = [];
    }
    xpos = (result.motif_length - rset.seq_len() + (window_weights.length - 1)) / 2;
    if (typeof trim_left === "undefined") {
      trim_left = xpos;
    } else if (trim_left < xpos) {
      trim_left = xpos;
    }
    positions = result.site_counts.length - window_weights.length + 1;
    for (j = 0; j < positions; j++, xpos += 1) {
      ypos = 0;
      // avoid division by zero when no sites are found
      if (result.total_sites > 0) {
        for (k = 0; k < window_weights.length; k++) {
          ypos += window_weights[k] * result.get_site_count(j + k, mirror, 0);
        }
        ypos /= result.total_sites;
      }
      x.push(xpos);
      y.push(ypos);
      // handle the negative dataset
      if (result.has_neg) {
        ypos_neg = 0;
        if (result.neg_total_sites > 0) {
          for (k = 0; k < window_weights.length; k++) {
            ypos_neg += window_weights[k] * result.get_site_count(j + k, mirror, 1);
          }
          ypos_neg /= result.neg_total_sites;
        }
        y_neg.push(ypos_neg);
      }
    }
    // subtract 1 from xpos because for loop will increment it one more than needed.
    xpos -= 1;
    this.lines.push(new CentrimoLine(result.name, result.sig, result.colour, [], line_thickness, true, x, y));
    if (result.has_neg) {
      this.lines.push(new CentrimoLine(result.name, result.sig, result.colour, [6,4], 2, false, x.slice(0), y_neg));
    }
    if (positions > 0) {
      if (typeof trim_right === "undefined") {
        trim_right = xpos;
      } else if (trim_right > xpos) {
        trim_right = xpos;
      }
    }
  }
  if (typeof start !== "undefined" && start != null) {
    if (start > trim_left) {
      trim_left = start;
    }
    this.start = start;
  } else {
    this.start = -Math.ceil(rset.seq_len() / 2);
  }
  if (typeof end !== "undefined" && end != null) {
    if (end < trim_right) {
      trim_right = end;
    }
    this.end = end;
  } else {
    this.end = Math.floor(rset.seq_len() / 2);
  }
  this.max_prob = 0;
  for (i = 0; i < this.lines.length; i++) {
    this.lines[i].trim(trim_left, trim_right);
    this.max_prob = Math.max(this.max_prob, this.lines[i].max());
  }
  this.scale = new CentrimoScale(this.max_prob);
};

/*
 * draw_graph
 *
 * Draws a motif probability graph
 */
CentrimoGraph.prototype.draw_graph = function (ctx, w, h, draw_legend, legend_x, legend_y) {
  "use strict";
  var gap, l_margin, t_margin, b_margin, r_margin, legend_metrics, 
      legend_width, legend_height;
  gap = 10;
  l_margin = gap + 30 + 10 * (2 + this.scale.digits);
  t_margin = 20;
  b_margin = 60;
  r_margin = 30;
  legend_metrics = this.measure_legend(ctx);
  // setting global
  legend_width = legend_metrics.width;
  legend_height = legend_metrics.height;
  // constrain legend to within graph area
  legend_x = Math.round(legend_x);
  legend_y = Math.round(legend_y);
  if (legend_x < (l_margin + gap)) {
    legend_x = l_margin + gap;
  } else if ((legend_x + legend_metrics.width) > (w - r_margin - gap)) {
    legend_x = w - r_margin - legend_metrics.width - gap;
  }
  if (legend_y < (t_margin + gap)) {
    legend_y = t_margin + gap;
  } else if ((legend_y + legend_metrics.height) > (h - b_margin - gap)) {
    legend_y = h - b_margin - legend_metrics.height - gap;
  }

  // draw graph
  ctx.save();
  // draw border
  ctx.beginPath();
  ctx.moveTo(l_margin - 0.5, t_margin +0.5);
  ctx.lineTo(l_margin - 0.5, h - (b_margin - 0.5));
  ctx.lineTo(w - r_margin - 0.5, h - (b_margin - 0.5));
  ctx.lineTo(w - r_margin - 0.5, t_margin +0.5);
  ctx.closePath();
  ctx.stroke();
  // draw fineprint
  ctx.save();
  ctx.font = "9px Helvetica";
  ctx.textAlign = "right";
  ctx.textBaseline = "bottom";
  ctx.fillText(this.fine_text, w - 1, h - 2);
  ctx.restore();
  // draw y axis
  ctx.save();
  ctx.translate(l_margin, t_margin);
  this.draw_y_axis(ctx, 0, h - (t_margin + b_margin));
  ctx.restore();
  // draw y labels
  ctx.save();
  ctx.translate(gap, t_margin);
  this.draw_y_axis_label(ctx, l_margin, h - (t_margin + b_margin));
  ctx.restore();
  // draw x axis
  ctx.save();
  ctx.translate(l_margin, h - b_margin);
  this.draw_x_axis(ctx, w - (l_margin + r_margin), b_margin);
  ctx.restore();
  // draw top axis
  ctx.save();
  ctx.translate(l_margin, t_margin);
  this.draw_top_axis(ctx, w - (l_margin + r_margin), 0);
  ctx.restore();
  // draw x axis labels
  ctx.save();
  ctx.translate(l_margin, h - b_margin);
  this.draw_x_axis_label(ctx, w - (l_margin + r_margin), b_margin - gap);
  ctx.restore();
  // draw lines
  ctx.save();
  ctx.translate(l_margin, t_margin);
  this.draw_lines(ctx, w - (l_margin + r_margin), h - (t_margin + b_margin), 8);
  ctx.restore();
  // draw legend
  if (draw_legend) { 
    ctx.save();
    ctx.translate(legend_x, legend_y);
    this.draw_legend(ctx, legend_metrics);
    ctx.restore();
  }
  ctx.restore();
  return new CentrimoGraphMetrics(legend_metrics, t_margin, h - b_margin,
      l_margin, this.start, w - r_margin, this.end);
};

/*
 * draw_x_axis
 *
 */
CentrimoGraph.prototype.draw_x_axis = function(ctx, w, h) {
  "use strict";
  var scale_x, length, tic_inc, tic_min, tic_max, i, x;
  // pixels per unit
  scale_x = w / (this.end - this.start);
  // calculate a good tic increment
  length = this.end - this.start;
  if (length > 50) {
    // multiple of 10
    tic_inc = Math.max(1, Math.round(length / 100)) * 10;
  } else if (length > 25) {
    tic_inc = 5;
  } else if (length > 10) {
    tic_inc = 2;
  } else {
    tic_inc = 1;
  }
  // work out the min and max values within the start and end
  tic_min = Math.round(this.start / tic_inc) * tic_inc;
  if (tic_min < this.start) {
    tic_min += tic_inc;
  }
  tic_max = Math.round(this.end / tic_inc) * tic_inc;
  if (tic_max > this.end) {
    tic_max -= tic_inc;
  }
  // draw the tics
  ctx.save();
  ctx.font = "19px Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  for (i = tic_min; i <= tic_max; i+= tic_inc) {
    x = Math.round((i - this.start) * scale_x) + 0.5;
    ctx.fillText(""+i, x, 5);
    if (i == this.start || i == this.end) continue;
    ctx.beginPath();
    ctx.moveTo(x, -5);
    ctx.lineTo(x, 3);
    ctx.stroke();
  }
  
  ctx.restore();
};

/*
 * draw_top_axis
 *
 */
CentrimoGraph.prototype.draw_top_axis = function(ctx, w, h) {
  "use strict";
  var scale_x, length, tic_inc, tic_min, tic_max, i, x;
  // pixels per unit
  scale_x = w / (this.end - this.start);
  // calculate a good tic increment
  length = this.end - this.start;
  if (length > 50) {
    // multiple of 10
    tic_inc = Math.max(1, Math.round(length / 100)) * 10;
  } else if (length > 25) {
    tic_inc = 5;
  } else {
    tic_inc = 1;
  }
  // work out the min and max values within the start and end
  tic_min = Math.round(this.start / tic_inc) * tic_inc;
  if (tic_min < this.start) {
    tic_min += tic_inc;
  }
  tic_max = Math.round(this.end / tic_inc) * tic_inc;
  if (tic_max > this.end) {
    tic_max -= tic_inc;
  }
  // draw the tics
  ctx.save();
  ctx.font = "19px Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  for (i = tic_min; i <= tic_max; i+= tic_inc) {
    if (i == this.start || i == this.end) continue;
    x = Math.round((i - this.start) * scale_x) + 0.5;
    ctx.beginPath();
    ctx.moveTo(x, 0);
    ctx.lineTo(x, 8);
    ctx.stroke();
  }
  ctx.restore();
};

/*
 * draw_x_axis_label
 */
CentrimoGraph.prototype.draw_x_axis_label = function(ctx, w, h) {
  "use strict";
  ctx.save();
  ctx.font = "19px Helvetica";
  ctx.textAlign = "center";
  ctx.textBaseline = "bottom";
  ctx.fillText((this.mirror ? 
        "Distance of Best Site from Sequence Center" : 
        "Position of Best Site in Sequence"), w/2, h);
  ctx.restore();
};

/*
 * draw_y_axis
 *
 * TODO some work needs to be done to allow moving the zero
 */
CentrimoGraph.prototype.draw_y_axis = function(ctx, w, h) {
  "use strict";
  var y_scale, p, y;
  ctx.save();
  ctx.font = "19px Helvetica";
  ctx.textBaseline = "middle";
  ctx.textAlign = "right";

  y_scale = h / this.scale.max;
  for (p = 0; p < this.scale.max; p += this.scale.inc) {
    y = Math.round(h - p * y_scale) + 0.5;
    this.draw_y_tic(ctx, this.scale.digits, y, p);
  }
  this.draw_y_tic(ctx, this.scale.digits, 0.5, this.scale.max);

  ctx.restore();
};

/*
 * draw_y_tic
 */
CentrimoGraph.prototype.draw_y_tic = function(ctx, digits, y, p) {
  "use strict";
  ctx.beginPath();
  ctx.moveTo(5, y);
  ctx.lineTo(-3, y);
  ctx.stroke();
  ctx.fillText(p.toFixed(digits), -5, y);
};

/*
 * draw_y_axis_label
 */
CentrimoGraph.prototype.draw_y_axis_label = function(ctx, w, h) {
  "use strict";
  ctx.save();
  ctx.translate(0, h/2);
  ctx.rotate(-Math.PI / 2);
  ctx.font = "19px Helvetica";
  ctx.textBaseline = "top";
  ctx.textAlign = "center";
  ctx.fillText("Probability", 0, 0);
  ctx.restore();
};

/*
 * draw_lines
 */
CentrimoGraph.prototype.draw_lines = function(ctx, w, h, tic_size) {
  "use strict";
  var scale_y, scale_x, i, line, x_points, y_points, j, x, y, dasher;
  if (typeof tic_size === "undefined") {
    tic_size = 0;
  }
  scale_y = h / this.scale.max;
  scale_x = w / (this.end - this.start);

  // draw the horizontal line and write range 
  if (this.motif_width) {
    ctx.save();
    ctx.strokeStyle = '#DDD';
    var txt_height, t1, t2, w1, w2, xlate, xlate1, xlate2;
    ctx.font = "13px san-serif";
    txt_height = parseInt(ctx.font);
    if (this.align == "left") {
      t1 = 0;
      t2 = this.seq_len;
    } else if (this.align == "center") {
      t2 = this.seq_len/2;
      t1 = -t2;
    } else {
      t1 = -this.seq_len;
      t2 = 0;
    }
    xlate = (this.motif_width/2.0 + this.window_width/2.0) * scale_x;
    w1 = ctx.measureText(t1).width;
    xlate1 = xlate > w1 ? xlate : w1;
    w2 = ctx.measureText(t2).width;
    xlate2 = xlate > w2 ? xlate : w2;
    ctx.textAlign = "left";
    ctx.fillText(t1, 0, h);
    ctx.textAlign = "right";
    ctx.fillText(t1, 0, h);
    ctx.fillText(t2, w, h);
    ctx.beginPath();
    ctx.moveTo(0, h-txt_height);
    ctx.lineTo(w, h-txt_height);
    ctx.stroke();
    ctx.restore();
    // Adjust h to allow for X axis labels.
    h -= txt_height;
    scale_y = h / this.scale.max;
  }
  // draw the vertical line
  if (0 > this.start && 0 < this.end) {
    ctx.save();
    if (this.align == "left") {
      //ctx.translate((this.motif_width/2.0 + this.window_width/2.0) * scale_x, 0);
      ctx.translate(0, 0);
    } else if (this.align == "center") {
      ctx.translate((-this.start) * scale_x, 0);
    } else if (this.align == "right") {
      //ctx.translate(w - (this.motif_width/2.0 + this.window_width/2.0) * scale_x - 1, 0);
      ctx.translate(w - 1, 0);
    }
    ctx.strokeStyle = '#DDD';
    ctx.beginPath();
    ctx.moveTo(0.5, tic_size);
    ctx.lineTo(0.5, h - tic_size);
    ctx.stroke();
    ctx.restore();
  }
  // draw the lines
  ctx.save();
  ctx.lineJoin = "bevel";
  ctx.miterLimit = 0;
  for (i = 0; i < this.lines.length; i++) {
    line = this.lines[i];
    ctx.lineWidth = line.thickness;
    x_points = line.xlist;
    y_points = line.ylist;
    if (x_points.length > 1) {
      ctx.strokeStyle = line.colour;
      ctx.beginPath();
      for (j = 0; j < x_points.length; j++) {
        if (isNaN(x_points[j])) {
          throw new Error("X NaN!");
        }
        if (isNaN(y_points[j])) {
          throw new Error("Y NaN!");
        }
        x = (x_points[j] - this.start) * scale_x;
        y = h - y_points[j] * scale_y;
        if (j === 0) {
          dasher = new Dasher(ctx, x, y, line.dash);
        } else {
          dasher.dashTo(x, y);
        }
      }
      ctx.stroke();
    } else if (x_points.length == 1) {
      if (isNaN(x_points[0])) {
        throw new Error("X NaN!");
      }
      if (isNaN(y_points[0])) {
        throw new Error("Y NaN!");
      }
      x = (x_points[0] - this.start) * scale_x;
      y = h - y_points[0] * scale_y;
      ctx.fillStyle = line.colour;
      ctx.beginPath();
      ctx.arc(x, y, 2, 0, 2*Math.PI, false);
      ctx.fill();
    }
  }
  ctx.restore();
};

/*
 * measure_legend
 */
CentrimoGraph.prototype.measure_legend = function(ctx) {
  "use strict";
  var lw, lh, sq_w, id_w, pv_w, lines, i, line, len;
  // initilise the line height to the size of the padding
  lh = 2 * LEGEND_PAD;
  // calculate the column widths
  sq_w = LEGEND_LINE - 2;
  id_w = 0;
  pv_w = 0;
  ctx.save();
  ctx.font = "" + LEGEND_LINE + "px " + LEGEND_FONT; 
  for (i = 0; i < this.lines.length; i++) {
    line = this.lines[i];
    if (!line.show_on_legend) {
      continue;
    }
    lh += LEGEND_LINE * 1.2;
    len = ctx.measureText(line.name).width;
    if (id_w < len) {
      id_w = len;
    }
    len = ctx.measureText(line.sig).width;
    if (pv_w < len) {
      pv_w = len;
    }
  }
  lh = Math.round(lh);
  ctx.restore();
  // legend width is a function of the column widths
  lw = id_w + pv_w + sq_w + 4 * LEGEND_PAD;

  return new CentrimoLegendMetrics(lw, lh, id_w, pv_w, sq_w);
};

/*
 * draw_legend
 */
CentrimoGraph.prototype.draw_legend = function(ctx, metrics) {
  "use strict";
  var ln_h, pad, w, h, id_w, pv_w, sq_w, id_x, pv_x, sq_x, i, line;
  if (this.lines.length === 0) {
    return;
  }
  ln_h = LEGEND_LINE;
  pad = LEGEND_PAD;
  w = metrics.width;
  h = metrics.height;
  id_w = metrics.id_width;
  pv_w = metrics.pv_width;
  sq_w = metrics.sq_width;
  id_x = 0;
  pv_x = id_x + id_w + pad;
  sq_x = pv_x + pv_w + pad;

  ctx.save();
  ctx.font = "" + ln_h + "px " + LEGEND_FONT;
  ctx.textAlign = "left";
  ctx.textBaseline = "alphabetic";
  // draw it
  ctx.save();
  ctx.fillStyle = 'white';
  ctx.fillRect(0.5, 0.5, w-1, h-1);
  ctx.strokeStyle = 'black';
  ctx.strokeRect(0.5, 0.5, w-1, h-1);
  ctx.restore();
  ctx.translate(pad, pad);
  ctx.fillStyle = "black";
  for (i = 0; i < this.lines.length; i++) {
    line = this.lines[i];
    if (!line.show_on_legend) {
      continue;
    }
    ctx.translate(0, ln_h);
    ctx.save();
    ctx.fillStyle = line.colour;
    ctx.fillRect(sq_x, -sq_w + 0.1 * ln_h, sq_w, sq_w);
    ctx.restore();
    ctx.fillText(line.name, id_x, 0);
    ctx.fillText(line.sig, pv_x, 0);
    ctx.translate(0, 0.2 * ln_h);
  }
  ctx.restore();
};

/*
 * triangular_weights
 * Returns an array of length n containing normalized weights.
 *
 */
function triangular_weights(n) {
  "use strict";
  var weights, half, half_i, sum, i, unscaled_weight;
  weights = [];
  half = n/2;
  half_i = Math.floor(half);
  sum = 0;
  for (i = 0; i < half_i; i++) {
    unscaled_weight = (i + 0.5) / half;
    weights[i] = unscaled_weight;
    weights[n - i -1] = unscaled_weight;
    sum += 2 * unscaled_weight;
  }
  if (n % 2 == 1) {
    weights[half_i] = 1;
    sum += 1;
  }
  // normalize
  for (i = 0; i < n; i++) {
    weights[i] /= sum;
  }
  return weights;
}

/*
 * uniform_weights
 * Returns an array of length n containing normalized weights.
 *
 */
function uniform_weights(n) {
  "use strict";
  var weights, weight, i;
  weights = [];
  weight = 1.0 / n;
  for (i = 0; i < n; i++) {
    weights[i] = weight;
  }
  return weights;
}

    </script>
    <script type="text/javascript">
var centrimo_alphabet = new Alphabet(data.alphabet, data.background);
var palate = ["white", "cyan", "blue", "#FF00FF", "#00FF00", "red", "orange", "#008000", "#8A2BE2", "black"];
var text_palate = ["black", "black", "white", "white", "black", "white", "black", "white", "white", "white"];
var INT_MAX = 9007199254740992;
var default_smoothing_window = 20;

var s_motifs = [];
var s_swatches = [];
var s_logos = []
var s_count = 0;
var swap = null;
var alphabet = new Alphabet(data.alphabet, data.background);
var logo_timer = null; // timer to draw motif when the mouse pauses on a row
var logo_motif = null; // motif to draw when timer expires
var logo_row = null; // the row (or tbody) that the mouse is over
var legend_x = 1000;
var legend_y = 1000;
var union_seq_ids = [];
var intersect_seq_ids = [];
var graph_metrics = new CentrimoGraphMetrics(null, 0, 0, 0, 0, 0, 0);
var graph_click = {"start": 0, "stop": 0};
var zooms = [];

var sort_table = {
  "motif": [
    {"name": "<i>E</i>-value", "fn": sort_motif_evalue, "priority": 1, "pair": "evalue"},
    {"name": "Fisher <i>E</i>-value", "fn": sort_motif_fisherpv, "priority": 2, 
      "show": data['options']['neg_sequences'], "pair": "fisherpv"},
    {"name": "Concentration", "fn": sort_motif_concentration, "pair": "evalue"},
    {"name": "Region Position", "fn": sort_motif_position, "pair": "position"},
    {"name": "Region Distance", "fn": sort_motif_center, "pair": "center"},
    {"name": "Region Width", "fn": sort_motif_spread, "pair": "spread"},
    {"name": "Region Matches", "fn": sort_motif_sites, "pair": "sites"},
    {"name": "<i>p</i>-value (Neg Data)", "fn": sort_motif_neg_pvalue,
      "show": data['options']['neg_sequences'], "pair": "neg_pvalue"},
    {"name": "Region Matches in (Neg Data)", "fn": sort_motif_neg_sites, 
      "show": data['options']['neg_sequences'], "pair": "neg_sites"},
    {"name": "Matthew's Correlation Coefficient", "fn": sort_motif_mcc, 
      "show": data['options']['mcc'], "pair": "mcc"},
    {"name": "Sequence Matches", "fn": sort_motif_total_sites, "pair": "evalue"},
    {"name": "Max Probability", "fn": sort_motif_max_probability, "pair": "evalue"},
    {"name": "ID", "fn": sort_motif_id, "pair": "evalue"},
    {"name": "Alt ID", "fn": sort_motif_alt, "pair": "evalue"},
    {"name": "Consensus", "fn": sort_motif_consensus, "pair": "evalue"},
  ],
  "region": [
    {"id": "evalue", "name": "<i>E</i>-value", "fn": sort_peak_evalue,
      "priority": 1},
    {"id": "fisherpv", "name": "Fisher <i>E</i>-value", "fn": sort_peak_fisherpv,
      "priority": 2, "show": data['options']['neg_sequences']},
    {"id": "position", "name": "Region Position", "fn": sort_peak_position},
    {"id": "center", "name": "Region Distance", "fn": sort_peak_center},
    {"id": "spread", "name": "Region Width", "fn": sort_peak_spread},
    {"id": "sites", "name": "Region Matches", "fn": sort_peak_sites},
    {"id": "neg_pvalue", "name": "<i>p</i>-value (Neg Data)",
      "fn": sort_peak_neg_pvalue, "show": data['options']['neg_sequences']},
    {"id": "neg_sites", "name": "Region Matches in (Neg Data)",
      "fn": sort_peak_neg_sites, "show": data['options']['neg_sequences']},
    {"id": "mcc", "name": "Matthew's Correlation Coefficient",
      "fn": sort_peak_mcc, "show": data['options']['mcc']}
  ],
};

pre_load_setup();


/*
 * name_from_source
 *
 * Makes a file name more human friendly to read.
 */
function name_from_source(source) {
  "use strict";
  var file, noext;
  if (source == "-") {
    return "-"
  }
  //assume source is a file name
  file = source.replace(/^.*\/([^\/]+)$/,"$1");
  noext = file.replace(/\.[^\.]+$/, "");
  return noext.replace(/_/g, " ");
}

/*
 * get_central_probability
 *
*/
function get_central_probability() {
  var i, j;
  var windo = default_smoothing_window;
  if ($("windo"))  windo = parseInt($("windo").value);
  var half_windo = windo / 2;
  var motifs = data["motifs"];
  for (i = 0; i < motifs.length; i++) {
    var motif = motifs[i];
    var sites = motif["sites"];
    var sum = 0;
    var j1 = Math.round(-half_windo - ((motif["len"] / 2) - (data["seqlen"] / 2) + 0.5));
    var j2 = j1 + windo;
    for (j = j1; j <= j2; j++) sum += sites[j];
    motif["central_prob"] = sum / motif["total_sites"];
  }
} // get_central_probability

/*
 * pre_load_setup
 *
 *  Sets up initial variables which may be
 *  required for the HTML document creation.
 */
function pre_load_setup() {
  "use strict";
  var i, motifs, params, showlist, show, parts, db_i, id, j, motif;
  var seq_db, db, dbs, sites, max_site, max_site_pos;
  for (i = 0; i < palate.length -1; i++) {
    s_motifs[i] = null;
    s_swatches[i] = null;
    s_logos[i] = null;
  }
  s_count = 0;
  motifs = data["motifs"];
  if (data["options"]["disc"]) {
    motifs.sort(sort_motif_fisherpv);
  } else {
    motifs.sort(sort_motif_evalue);
  }
  // put a copy of the best evalue in the motif
  for (i = 0; i < motifs.length; i++) {
    motif = motifs[i];
    motif["best_log_adj_pvalue"] = motif["peaks"][0]["log_adj_pvalue"];
    // calculate the best probability
    max_site = 0;
    max_site_pos = 0;
    sites = motif["sites"];
    for (j = 0; j < sites.length; j++) {
      if (sites[j] > max_site) {
        max_site = sites[j];
        max_site_pos = j;
      }
    }
    motif["max_prob"] = max_site / motif["total_sites"];
    motif["max_prob_loc"] = max_site_pos + (motif["len"] / 2) - (data["seqlen"] / 2);
  }
  params = parse_params();
  if (params["show"]) {
    showlist = params["show"];
    for (i = 0; i < showlist.length; i++) {
      show = showlist[i];
      parts = show.match(/^db(\d+) (.+)$/);
      db_i = parseInt(parts[1]);
      id = parts[2];
      // loop over the motifs looking for a match
      for (j = 0; j < motifs.length; j++) {
        motif = motifs[j];
        if (motif["db"] == db_i && motif["id"] == id) {
          motif["colouri"] = s_count + 1;
          s_motifs[s_count] = motif;
          s_count++;
          break;
        }
      }
      // give up if we've used all the available colours
      if ((s_count + 1) >= palate.length) break; 
    }
  } else {
    s_count = Math.min(3, motifs.length);
    for (i = 0; i < s_count; i++) {
      motif = motifs[i];
      motif["colouri"] = i+1;
      s_motifs[i] = motif;
    }
  }
  calculate_seq_ids();
  // get the name of the sequence db
  seq_db = data['sequence_db'];
  if (!seq_db['name']) seq_db['name'] = name_from_source(seq_db['source']);
  // get the names of the motif databases
  dbs = data['motif_dbs'];
  for (i = 0; i < dbs.length; i++) {
    db = dbs[i];
    if (!db['name']) db['name'] = name_from_source(db['source']);
  }
}

function num_keys(e) {
  if (!e) var e = window.event;
  var code = (e.keyCode ? e.keyCode : e.which);
  var keychar = String.fromCharCode(code);
  var numre = /\d/;
  // only allow 0-9 and various control characters (Enter, backspace, delete)
  if (code != 8 && code != 9 && code != 13 && code != 46 && !numre.test(keychar)) {
    e.preventDefault();
  }
}

/*
 * toggle_column
 *
 * Adds or removes a class from the table displaying the 
 * centrally enriched motifs. This is primary used to set the visibility
 * of columns by using css rules. If the parameter 'show' is not passed
 * then the existence of the class will be toggled, otherwise it will be
 * included if show is false.
 */
function toggle_column(cls) {
  toggle_class($("motifs"), cls);
}

/*
 * toggle_filter
 *
 * Called when the user clicks a checkbox
 * to enable/disable a filter option.
 */
function toggle_filter(chkbox, filter_id) {
  var filter = $(filter_id);
  filter.disabled = !(chkbox.checked);
  if (!filter.disabled) {
    filter.focus();
    if (filter.select) filter.select();
  }
}

/*
 * enable_filter
 *
 * Called when the user clicks a filter label.
 * Enables the filter.
 */
function enable_filter(chkbox_id, filter_id) {
  var chkbox = $(chkbox_id);
  if (!chkbox.checked) {
    var filter = $(filter_id);
    $(chkbox_id).checked = true;
    filter.disabled = false;
    filter.focus();
    if (filter.select) filter.select();
  }
}

/*
 * update_filter
 *
 * If the key event is an enter key press then
 * update the filter on the CEM table
 */
function update_filter(e) {
  if (!e) var e = window.event;
  var code = (e.keyCode ? e.keyCode : e.which);
  if (code == 13) {
    e.preventDefault();
    make_CEM_table();
  }
}

/*
 * toggle_lock
 *
 */

/*
 * clear_selection
 *
 * Called when the user clicks the X in the
 * title of the centrally enriched motifs and
 * causes all the motifs to be deselected.
 */
function clear_selection() {
  for (var i = 1; i < palate.length; i++) {
    var motif = s_motifs[i-1];
    var swatch = s_swatches[i-1];
    s_motifs[i-1] = null;
    s_swatches[i-1] = null;
    s_logos[i-1] = null;
    if (motif) delete motif['colouri'];
    if (swatch) swatch.style.backgroundColor = palate[0];
  }
  s_count = 0;
  if (!data['options']['noseq']) {
    //reset_sequences_IDs_list();
    union_seq_ids = [];
    intersect_seq_ids = [];
    display_seq_ids();
  }
  make_PM_table();
  make_MP_graph();
}

/*
 * toggle_graph_motif
 *
 * Activated when the user clicks on a swatch in the centrally enriched motifs 
 * table. If the motif is already selected it deselects it otherwise it picks 
 * an unused colour and selects it for graphing.
 */
function toggle_graph_motif(e) {
  "use strict";
  var swatch;
  if (!e) var e = window.event;
  if (e.target) swatch = e.target;
  else if (e.srcElement) swatch = e.srcElement;
  // in case we land on a text node
  if (swatch.nodeType == 3) swatch = swatch.parentNode;
  // find the containing tbody
  var group = find_parent(swatch.parentNode, "peak_group");
  // get the attached motif
  var motif = group['data_motif'];
  if (motif['colouri'] && motif['colouri'] != 0) {
    // deselect the motif
    var i = motif['colouri'];
    s_motifs[i-1] = null;
    s_swatches[i-1] = null;
    s_logos[i-1] = null;
    delete motif['colouri'];
    swatch.style.backgroundColor = palate[0];
    s_count--;
    if (!data['options']['noseq']) calculate_seq_ids();
  } else {
    // select an unused colour
    var i;
    for (i = 1; i < palate.length; i++) {
      if (!s_motifs[i-1]) break;
    }
    if (i == palate.length) {
      alert("All graph colours used. Please deselect motifs before adding more.");
      return;
    }
    s_motifs[i-1] = motif;
    s_swatches[i-1] = swatch;
    motif['colouri'] = i;
    swatch.style.backgroundColor = palate[i];
    s_count++;
    if (!data['options']['noseq']) {
      if (s_count == 1) {
        union_seq_ids = motif["seqs"].slice(0);
        intersect_seq_ids = union_seq_ids.slice(0);
      } else {
        union_seq_ids = union_nums(union_seq_ids, motif["seqs"]);
        intersect_nums(intersect_seq_ids, motif["seqs"]);
      }
    }
  }
  if (!data['options']['noseq']) display_seq_ids();
  make_PM_table();
  make_MP_graph();
}

/*
 * move_legend
 *
 * Called when the user clicks on the graph
 * to move the legend location.
 */
function move_legend(e) {
  var target;
  if (!e) var e = window.event;
  if (e.target) target = e.target;
  else if (e.srcElement) target = e.srcElement;
  var elemXY = coords(target);
  var posx = 0;
  var posy = 0;
  if (e.pageX || e.pageY)   {
    posx = e.pageX;
    posy = e.pageY;
  }
  else if (e.clientX || e.clientY)   {
    posx = e.clientX + document.body.scrollLeft
      + document.documentElement.scrollLeft;
    posy = e.clientY + document.body.scrollTop
      + document.documentElement.scrollTop;
  }
  var x = posx - elemXY[0];
  var y = posy - elemXY[1];
  legend_x = x - graph_metrics.legend_width/2;
  legend_y = y - graph_metrics.legend_height/2;
  if (parseInt($("legend").value) != 0) make_MP_graph();
}

function highlight_peak(e) {
  var target, pop;
  pop = $("pop_peak");
  if (pop.style.visibility === "visible") return;
  if (!e) var e = window.event;
  if (e.target) target = e.target;
  else if (e.srcElement) target = e.srcElement;
  while (!target['data_peak']) {
    if (target.nodeName == 'BODY') return;
    target = target.parentNode;
  }
  var peak = target['data_peak'];

  var l = graph_metrics.left_mark;
  var w = graph_metrics.right_mark - graph_metrics.left_mark;
  var d = graph_metrics.right_val - graph_metrics.left_val;
  var unit = w / d;

  var peak_width = peak["spread"];
  var peak_left = peak["center"] - (peak["spread"] / 2);
  var peak_offscreen = 0;
  if (peak_left < graph_metrics.left_val) {
    peak_offscreen = graph_metrics.left_val - peak_left;
    peak_width = Math.max(0, peak_width - peak_offscreen);
    peak_left = graph_metrics.left_val;
  } else if ((peak_left + peak_width) > graph_metrics.right_val) {
    peak_offscreen = (peak_left + peak_width) - graph_metrics.right_val;
    peak_width = Math.max(0, peak_width - peak_offscreen);
    peak_left = Math.min(peak_left, graph_metrics.right_val);
  }
  
  if (peak_width > 0) {
    pop.style.width = (peak_width * unit) + "px";
    pop.style.left = (l + ((peak_left - graph_metrics.left_val) * unit)) + "px";
    pop.style.visibility = "visible";
  }
}

function dehighlight_peak(e) {
  $("pop_peak").style.visibility = "hidden";
}

/*
 * hover_logo
 *
 * Activated when the user hovers their cursor over a row in the centrally 
 * enriched motifs table. After a fifth of a second delay, displays a box with 
 * the logo and reverse complement logo.
 */
function hover_logo(e) {
  var popup;
  if (this === logo_row) return;
  logo_row = this;
  if (logo_timer) clearTimeout(logo_timer);
  logo_row.addEventListener('mousemove', move_logo, false);
  popup = $("logo_popup");
  if (popup["data_motif"] != logo_row["data_motif"]) {
    logo_timer = setTimeout(popup_logo, 200);
  } else {
    popup.style.display = "block";
  }
}

/*
 * dehover_logo
 *
 * Activated when the user moves their cursor off a row in the centrally 
 * enriched motifs table. Hides the logo box (or stops it from being displayed).
 */
function dehover_logo(e) {
  var popup = $("logo_popup");
  popup.style.display = "none";
  if (logo_timer) clearTimeout(logo_timer);
  if (logo_row) logo_row.removeEventListener('mousemove', move_logo, false);
  logo_row = null;
  logo_timer = null;
}

/*
 * move_logo
 * 
 * keeps the motif logo at a set distance from the cursor.
 */
function move_logo(e) {
  var popup = $("logo_popup");
  popup.style.left = (e.pageX + 20) + "px";
  popup.style.top = (e.pageY + 20) + "px";
}

/*
 * popup_logo
 *
 * Activated when the user has had the cursor over a row in the centrally 
 * enriched motifs table for longer than 1/5th of a second. It draws the
 * motif logos in a popup and displays the popup.
 */
function popup_logo() {
  if (logo_row == null) return;
  var motif = logo_row["data_motif"];
  var pspm = new Pspm(motif['pwm'], motif['id'], 0, 0, 
      motif['motif_nsites'], motif['motif_evalue']);
  var canvas = $("logo_popup_canvas");
  var logo = logo_1(alphabet, "", pspm);
  draw_logo_on_canvas(logo, canvas, false, 0.5);
  if (!data["options"]["norc"]) {
    // draw RC motif
    var canvas_rc = $("logo_popup_canvas_rc");
    var pspm_rc = pspm.copy().reverse_complement(alphabet);
    var logo_rc = logo_1(alphabet, "", pspm_rc);
    draw_logo_on_canvas(logo_rc, canvas_rc, false, 0.5);
  }

  var popup = $("logo_popup");
  popup.style.display = "block";
  popup['data_motif'] = motif;
  logo_timer = null;
}

/*
 * swap_colour
 *
 * Activated when the user clicks a swatch in the plotted motifs table.
 * If a swatch has already been selected then swap colours with this one,
 * otherwise record which swatch has been selected.
 */
function swap_colour(e) {
  var swatch;
  if (!e) var e = window.event;
  if (e.target) swatch = e.target;
  else if (e.srcElement) swatch = e.srcElement;
  var row = swatch;
  while (!row['motif']) row = row.parentNode;
  var motif = row['motif'];
  if (swap == null) {
    swatch.appendChild(document.createTextNode("\u21c5"));
    swap = motif;
  } else if (swap == motif) {
    while (swatch.firstChild) swatch.removeChild(swatch.firstChild);
    swap = null;
  } else {
    var swapi = swap['colouri'];
    var motifi = motif['colouri'];
    motif['colouri'] = swapi;
    swap['colouri'] = motifi;
    // swap swatches
    var temp = s_swatches[swapi-1];
    s_swatches[swapi-1] = s_swatches[motifi-1];
    s_swatches[motifi-1] = temp;
    // swap motifs
    temp = s_motifs[swapi-1];
    s_motifs[swapi-1] = s_motifs[motifi-1];
    s_motifs[motifi-1] = temp;
    // swap logos
    temp = s_logos[swapi-1];
    s_logos[swapi-1] = s_logos[motifi-1];
    s_logos[motifi-1] = temp;
    // update swatch colours
    s_swatches[swapi-1].style.backgroundColor = palate[swapi];
    s_swatches[motifi-1].style.backgroundColor = palate[motifi];
    swap = null;
    make_PM_table();
    make_MP_graph();
  }
}

/*
 * set_colour
 *
 * Activated when the user clicks a swatch in the unused colours section.
 * If a swatch has already been selected then set its colour to this one,
 * otherwise warn the user that they must select a motif swatch first.
 */
function set_colour(e) {
  var swatch;
  if (!e) var e = window.event;
  if (e.target) swatch = e.target;
  else if (e.srcElement) swatch = e.srcElement;
  var colouri = swatch['colouri'];
  if (swap) {
    var swapi = swap['colouri'];
    swap['colouri'] = colouri;
    s_swatches[colouri-1] = s_swatches[swapi-1];
    s_motifs[colouri-1] = s_motifs[swapi-1];
    s_logos[colouri-1] = s_logos[swapi-1];
    s_swatches[swapi-1] = null;
    s_motifs[swapi-1] = null;
    s_logos[swapi-1] = null;
    s_swatches[colouri-1].style.backgroundColor = palate[colouri];
    swap = null;
    make_PM_table();
    make_MP_graph();
  } else {
    alert("You must select a motif to set to this colour first.");
  }
}

/*
 * page_loaded
 *
 * Called when the page has loaded for the first time.
 */
function page_loaded() {
  first_load_setup();
  post_load_setup();
}

/*
 * page_loaded
 *
 * Called when a cached page is reshown.
 */
function page_shown(e) {
  if (e.persisted) post_load_setup();
}

/*
 * union_nums
 *
 * Returns a union of two sorted lists of numbers.
 */
function union_nums(list1, list2) {
  "use strict";
  var i, j, list_out;
  i = j = 0;
  list_out = [];
  while (i < list1.length && j < list2.length) {
    if (list1[i] < list2[j]) {
      list_out.push(list1[i]);
      i++;
    } else if (list1[i] === list2[j]) {
      list_out.push(list1[i]);
      i++;
      j++;
    } else { // list1[i] > list2[j]
      list_out.push(list2[j]);
      j++;
    }
  }
  if (i < list1.length) {
    for (; i < list1.length; i++) {
      list_out.push(list1[i]);
    }
  } else {
    for (; j < list2.length; j++) {
      list_out.push(list2[j]);
    }
  }
  return list_out;
}

/*
 * intersect_nums
 *
 * Removes numbers from the target_list which do not also appear in the
 * incoming_list. Both lists must be sorted.
 */
function intersect_nums(target_list, incoming_list) {
  "use strict";
  var i, j, shift;
  shift = i = j = 0;
  while (i < target_list.length && j < incoming_list.length) {
    if (target_list[i] > incoming_list[j]) {
      j++;
    } else if (target_list[i] < incoming_list[j]) {
      i++;
      shift++;
    } else {
      if (shift > 0) target_list[i - shift] = target_list[i];
      i++;
      j++;
    }
  }
  target_list.length = i - shift;
}

function calculate_seq_ids() {
  var i, motif;
  // calculate sequence id sets
  if (!data['options']['noseq']) {
    if (s_count == 0) {
      union_seq_ids = [];
      intersect_seq_ids = [];
    } else {
      for (i = 0; i < s_motifs.length; i++) {
        motif = s_motifs[i];
        if (motif) {
          union_seq_ids = motif["seqs"].slice(0);
          intersect_seq_ids = union_seq_ids.slice(0);
          break;
        }
      }
      for (; i < s_motifs.length; i++) {
        motif = s_motifs[i];
        if (motif === null) continue;
        union_seq_ids = union_nums(union_seq_ids, motif["seqs"]);
        intersect_nums(intersect_seq_ids, motif["seqs"]);
      }
    }
  }
}

function display_seq_ids() {
  var u_n_cont, u_p_cont, i_n_cont, i_p_cont, i_s_cont;
  var union_count, intersect_count, total_count;
  var union_percent, intersect_percent, intersect_seqs, i;
  var sequences;
  sequences = data["sequences"];
  union_count = union_seq_ids.length;
  intersect_count = intersect_seq_ids.length;
  total_count = sequences.length;
  union_percent = Math.round((union_count / total_count) * 100);
  intersect_percent = Math.round((intersect_count / total_count) * 100);
  u_n_cont = $('matching_union_number');
  u_p_cont = $('matching_union_percentage');
  i_n_cont = $('matching_intersection_number');
  i_p_cont = $('matching_intersection_percentage');
  i_s_cont = $('matching_intersection_sequences');
  u_n_cont.innerHTML = "";
  u_n_cont.appendChild(document.createTextNode(union_count));
  u_p_cont.innerHTML = "";
  u_p_cont.appendChild(document.createTextNode(union_percent));
  i_n_cont.innerHTML = "";
  i_n_cont.appendChild(document.createTextNode(intersect_count));
  i_p_cont.innerHTML = "";
  i_p_cont.appendChild(document.createTextNode(intersect_percent));
  intersect_seqs = [];
  for (i = 0; i < intersect_count; i++) {
    intersect_seqs.push(sequences[intersect_seq_ids[i]]);
  }
  i_s_cont.value = intersect_seqs.join("\n");
}

/*
 * find_highest_peaks
 *
 * Locate highest peaks for every motif.
 * Compute every x position and keep the highest one.
 */
/*
function find_highest_peaks(smoothing_type) {
  var sequence_length=data['seqlen'];
  var windo=parseInt($("windo").value);
  var half_window = windo / 2;
  var weights = [];
  var tbl = $("motifs");
  var tbody = tbl.tBodies[0];
  if (smoothing_type==1) { // Only computed for weighted moving average
    var total_weight = 0;
    for (var i = 0; i < windo; i++) {
      var pos = i + 0.5;
      var weight = (pos < half_window ? pos / half_window : (windo - pos) / half_window);
      weights.push(weight);
      total_weight += weight;
    }
  }
  for (var i = 0; i < data['motifs'].length; i++) { // For each motif
    var motif = data['motifs'][i];
    var sites = motif['sites'];
    var max_prob=-1;
    var index_max_prob=-1;
    var xpos = (motif.len / 2) - (sequence_length / 2) + half_window;
    var end = sites.length - windo;
    for (var j = 0; j < end; j++, xpos += 1) {
      var sum = 0;
      for (var k = 0; k < windo; k++) {
        sum += (smoothing_type==1) ? sites[j + k] * weights[k] : sites[j + k];
      }
      var avg = (smoothing_type==1) ? sum / total_weight : sum / windo;
      var prob = avg / motif['total_sites'];
      if (prob>max_prob) { // If Y axis value is higher than saved one
        max_prob=prob; // Save it
        index_max_prob=Math.floor(xpos); // Save the location
      }
    }
    motif["highest_peak"]=index_max_prob; // Save highest peak location for this motif
  }
}*/

/*
 * first_load_setup
 *
 * Setup state that is dependent on everything having been loaded already.
 * On browsers which cache state this is only run once.
 */
function first_load_setup() {
  if (data['options']['noseq']) {
    // no sequence ids to display
    $('seq_area').style.display='none';
  }
  if (!data['options']['local']) {
    // bins are centered, there is only one peak
    $('show_blocation').checked = false;
    $('CB_show_blocation').style.display='none';
    $('box_peak_sort').style.display = 'none';
    toggle_class($('motifs'), 'hide_OEbins', true);
  }
  if (!data['options']['neg_sequences']) {
    $('show_fisherpv').checked = false;
    $('show_negtsites').checked = false;
    $('show_negbsites').checked = false;
    $('show_negative_binomial').checked = false;
    // no negative sites, so hide negative bin sites and total
    $('CB_show_plot_negative').style.display= 'none';
    $('plot_negative').value = 0;
    $('CB_show_negbsites').style.display= 'none';
    $('CB_show_negtsites').style.display= 'none';
    $('CB_show_negative_binomial').style.display='none';
    $('CB_filter_on_negbintest').style.display='none';
    $('cb_show_fisherpv').style.display = 'none';
    $('cb_filter_on_fisherpv').style.display = 'none';
  }
  if (!data['options']['disc']) {
    // negative data set was not used with a discriminative search
    $('cb_show_fisherpv').style.display = 'none';
  }
  if (!data['options']['mcc']) {
    $('CB_show_MCC').style.display='none';
  }
  if (!data['options']['optimize_score']) {
    // per motif score optimisation turned off, so hide column
    $('show_score').checked = false;
  }
  if (data['options']['dist']) {
    // distance-to-center objective so hide Region Matches and show total matches.
    $('show_bsites').checked = false;
    $('show_tsites').checked = true;
  }
}

/*
 * post_load_setup
 *
 * Setup state that is dependent on everything having been loaded already.
 */
function post_load_setup() {
  "use strict";
  var tbl, i;
  if (data["options"]["norc"]) $("logo_popup_canvas_rc").style.display = "none";
  $("filter_id").disabled = !($("filter_on_id").checked);
  $("filter_alt").disabled = !($("filter_on_alt").checked);
  $("filter_evalue").disabled = !($("filter_on_evalue").checked);
  $("filter_binwidth").disabled = !($("filter_on_binwidth").checked);
  $("filter_negbintest").disabled = !($("filter_on_negbintest").checked);
  tbl = $("motifs");
  toggle_class(tbl, "hide_db", !$("show_db").checked);
  toggle_class(tbl, "hide_id", !$("show_id").checked);
  toggle_class(tbl, "hide_name", !$("show_name").checked);
  toggle_class(tbl, "hide_consensus", !$("show_consensus").checked);
  toggle_class(tbl, "hide_fisherpv", !$("show_fisherpv").checked);
  toggle_class(tbl, "hide_evalue", !$("show_evalue").checked);
  toggle_class(tbl, "hide_pvalue", !$("show_pvalue").checked);
  toggle_class(tbl, "hide_MCC", !$("show_MCC").checked);
  toggle_class(tbl, "hide_blocation", !$("show_blocation").checked);
  toggle_class(tbl, "hide_bwidth", !$("show_bwidth").checked);
  toggle_class(tbl, "hide_bsites", !$("show_bsites").checked);
  toggle_class(tbl, "hide_tsites", !$("show_tsites").checked);
  toggle_class(tbl, "hide_negbsites", !$("show_negbsites").checked);
  toggle_class(tbl, "hide_negtsites", !$("show_negtsites").checked);
  toggle_class(tbl, "hide_negative_binomial", !$("show_negative_binomial").checked);
  toggle_class(tbl, "hide_maxprob", !$("show_maxprob").checked);
  toggle_class(tbl, "hide_hpeak", !$("show_hpeak").checked); //max prob location
  toggle_class(tbl, "hide_nbinstested", !$("show_nbinstested").checked);
  toggle_class(tbl, "hide_score", !$("show_score").checked);
  get_central_probability();
  make_PM_table();
  make_CEM_table();
  make_MP_graph();
  add_MP_graph_listeners();
  if (!data['options']['noseq']) display_seq_ids();
}

/*
 *  sort_motif_id
 *
 *  Takes 2 motif objects and compares them based on id and database.
 */
function sort_motif_id(m1, m2) {
  var diff;
  diff = m1['id'].localeCompare(m2['id']);
  if (diff == 0) {
    diff = m1['db'] - m2['db'];
  }
  return diff;
}

/*
 * sort_motif_alt
 *
 * Takes 2 motif objects and compares them based on alternate id.
 */
function sort_motif_alt(m1, m2) {
  var diff;
  if (m1['alt'] && m2['alt']) {
    diff = m1['alt'].localeCompare(m2['alt']);
    if (diff != 0) return diff;
    return sort_motif_evalue(m1, m2);
  } else {
    if (m1['alt']) {
      return -1;
    } else {
      return 1;
    }
  }
}

/*
 * sort_motif_consensus
 *
 * Takes 2 motif objects and compares them based on consensus.
 */
function sort_motif_consensus(m1, m2) {
  var diff;
  if (m1['consensus'] && m2['consensus']) {
    diff = m1['consensus'].localeCompare(m2['consensus']);
    if (diff != 0) return diff;
    return sort_motif_evalue(m1, m2);
  } else {
    if (m1['consensus']) {
      return -1;
    } else {
      return 1;
    }
  }
}

/*
 * sort_motif_fisherpv
 *
 * Takes 2 motif objects and compares them based on the Fisher pvalue
 */
function sort_motif_fisherpv(m1, m2) {
  var diff, p1, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p1['fisher_log_adj_pvalue'] - p2['fisher_log_adj_pvalue'];
  if (diff != 0) return diff;
  diff = p2['pos_sites'] - p1['pos_sites'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

function sort_motif_neg_pvalue(m1, m2) {
  var diff, p1, p2;
  //return sort_motif_evalue(m1, m2);
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p1['neg_log_adj_pvalue'] - p2['neg_log_adj_pvalue'];
  if (diff != 0) return diff;
  diff = p2['neg_sites'] - p1['neg_sites'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

function sort_motif_neg_sites(m1, m2) {
  var diff, p1, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p1['neg_sites'] - p2['neg_sites'];
  if (diff != 0) return diff;
  diff = p1['neg_log_adj_pvalue'] - p2['neg_log_adj_pvalue'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

/*
 * sort_motif_evalue
 *
 * Takes 2 motif objects and compares them based on the log_adj_pvalue.
 */
function sort_motif_evalue(m1, m2) {
  var diff, p1, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p1['log_adj_pvalue'] - p2['log_adj_pvalue'];
  if (diff != 0) return diff;
  diff = p1['spread'] - p2['spread'];
  if (diff != 0) return diff;
  return sort_motif_id(m1, m2);
}

/*
 * sort_motif_spread
 *
 * Takes 2 motif objects and compares them based on the bin_width.
 */
function sort_motif_spread(m1, m2) {
  var diff, p2, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p1['spread'] - p2['spread'];
  if (diff != 0) return diff;
  diff = p1['log_adj_pvalue'] - p2['log_adj_pvalue'];
  if (diff != 0) return diff;
  return sort_motif_id(m1, m2);
}

/*
 * sort_central_probability
 *
 * Takes 2 motif objects and compares them based on the concentration
 * of sites in the central region of width equal to the smoothing
 * window width.
 */
function sort_motif_concentration(m1, m2) {
  var diff;
  diff = m2['central_prob'] - m1['central_prob'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

/*
 * sort_motif_max_probability
 *
 * Takes 2 motif objects and compares them based on the maximum probability.
 */
function sort_motif_max_probability(m1, m2) {
  var diff;
  diff = m2['max_prob'] - m1['max_prob'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

/*
 * sort_motif_sites
 *
 * Takes 2 motif objects and compares them based on the bin sites.
 */
function sort_motif_sites(m1, m2) {
  var diff, p1, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p2['sites'] - p1['sites'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

/*
 * sort_motif_center
 *
 * Takes 2 motif objects and compares them based on the abs(bin location).
 */
function sort_motif_center(m1, m2) {
  var diff, p1, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = Math.abs(p1['center']) - Math.abs(p2['center']);
  if (diff != 0) return diff;
  diff = p1['center'] - p2['center'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

/*
 * sort_motif_position
 *
 * Takes 2 motif objects and compares them based on the bin location.
 */
function sort_motif_position(m1, m2) {
  var diff, p1, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p1['center'] - p2['center'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

/*
 * sort_motif_mcc
 *
 * Takes 2 motif objects and compares them based on the Matthews Correlation Coefficient.
 */
function sort_motif_mcc(m1, m2) {
  var diff, p1, p2;
  p1 = m1['peaks'][0];
  p2 = m2['peaks'][0];
  diff = p2['mcc'] - p1['mcc'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}

/*
 * sort_motif_total_sites
 *
 * Takes 2 motif objects and compares them based on the total sites.
 */
function sort_motif_total_sites(m1, m2) {
  var diff;
  diff = m2['total_sites'] - m1['total_sites'];
  if (diff != 0) return diff;
  return sort_motif_evalue(m1, m2);
}


/*
 * get_sort_cmp
 *
 * Gets the sorting comparator by index.
 *
 */
function motif_sort_cmp(index) {
  "use strict";
  if (index > 0 && index < sort_table["motif"].length) {
    return sort_table["motif"][index]["fn"];
  }
  return sort_motif_evalue;
}

/*
 * sort_peak_fisherpv
 *
 * Takes 2 peak objects and compares them based on the Fisher pvalue
 */
function sort_peak_fisherpv(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = p1['fisher_log_adj_pvalue'] - p2['fisher_log_adj_pvalue'];
  if (diff != 0) return diff;
  diff = p2['pos_sites'] - p1['pos_sites'];
  if (diff != 0) return diff;
  return sort_peak_evalue(p1, p2);
}

function sort_peak_evalue(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = p1['log_adj_pvalue'] - p2['log_adj_pvalue'];
  if (diff != 0) return diff;
  diff = p1['spread'] - p2['spread'];
  if (diff != 0) return diff;
  return p1['center'] - p2['center']; 
}

function sort_peak_mcc(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = p2['mcc'] - p1['mcc'];
  if (diff != 0) return diff;
  return sort_peak_evalue(p1, p2);
}

function sort_peak_center(p1, p2) {
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = Math.abs(p1['center']) - Math.abs(p2['center']); 
  if (diff != 0) return diff;
  return p1['center'] - p2['center']; 
}

function sort_peak_position(p1, p2) {
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  return p1['center'] - p2['center']; 
}

function sort_peak_spread(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = p1['spread'] - p2['spread'];
  if (diff != 0) return diff;
  diff = p1['log_adj_pvalue'] - p2['log_adj_pvalue'];
  if (diff != 0) return diff;
  return p1['center'] - p2['center']; 
}

function sort_peak_sites(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = p2['sites'] - p1['sites'];
  if (diff != 0) return diff;
  return sort_peak_evalue(p1, p2);
}

function sort_peak_neg_pvalue(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = p1['neg_log_adj_pvalue'] - p2['neg_log_adj_pvalue'];
  if (diff != 0) return diff;
  diff = p2['neg_sites'] - p1['neg_sites'];
  if (diff != 0) return diff;
  return sort_peak_evalue(p1, p2);
}

function sort_peak_neg_sites(p1, p2) {
  var diff;
  if (p1['filtered'] != p2['filtered']) return (p1['filtered'] ? 1 : -1);
  diff = p1['neg_sites'] - p2['neg_sites'];
  if (diff != 0) return diff;
  diff = p1['neg_log_adj_pvalue'] - p2['neg_log_adj_pvalue'];
  if (diff != 0) return diff;
  return sort_peak_evalue(p1, p2);
}

function peak_sort_cmp(index) {
  "use strict";
  if (index > 0 && index < sort_table["region"].length) {
    return sort_table["region"][index]["fn"];
  }
  return sort_peak_evalue;
}

/*
 * log2str
 *
 * Converts a log value into scientific notation.
 */
function log2str(log_val, precision, max) {
  var log10_val, e, m;
  if (log_val < 0) {
    log10_val = log_val / Math.log(10);
    e = Math.floor(log10_val);
    m = Math.pow(10, log10_val - e);
    if (m + (0.5 * Math.pow(10, -precision)) >= 10) {
      m = 1;
      e += 1;
    }
    return "" + m.toFixed(precision) + "e" + e;
  } else if (typeof max !== "number" || Math.exp(log_val) < max) {
    return Math.exp(log_val).toFixed(precision);
  } else {
    return ">"+max;
  }
}

/*
 * str2log
 *
 * Converts a scientific notation number string to a log value.
 */
function str2log(str, default_value) {
  var sci_num_re, parts, m, e, log_num;
  if (typeof default_value === "undefined") {
    default_value = null;
  }
  sci_num_re = /^([+]?\d+(?:\.\d+)?)(?:[eE]([+-]\d+))?$/;
  parts = sci_num_re.exec(str);
  if (parts && parseFloat(parts[1]) != 0) {
    m = parseFloat(parts[1]);
    if (m === 0) return default_value;
    e = (parts.length == 3 && parts[2] != null ? parseInt(parts[2]) : 0);
    log_num = (((Math.log(m)/Math.log(10)) + e) * Math.log(10));
    return log_num;
  } else {
    return default_value;
  }
}

/*
 * pvstr
 *
 * Gets the p-value of the motif in string form.
 */
function pvstr(peak) {
  return log2str(peak['log_adj_pvalue'], 1);
}

/*
 * evstr
 *
 * Gets the E-value of the motif in string form.
 */
function evstr(peak, type) {
  return log2str(peak[type] + Math.log(data['tested']), 1);
}

/*
 * make_swatch
 *
 * Make a swatch block.
 */
function make_swatch(colouri) {
  var swatch = document.createElement('div');
  swatch.className = 'swatch';
  swatch.style.backgroundColor = palate[colouri];
  swatch.style.color = text_palate[colouri];
  return swatch;
}

function make_CEM_main_row(tbody, motif) {
  "use strict";
  var colouri, row, swatch, peak, expander;
  peak = motif['peaks'][0];
  colouri = motif['colouri'];
  if (!colouri) colouri = 0;
  row = tbody.insertRow(tbody.rows.length);
  row['data_peak'] = peak;
  swatch = make_swatch(colouri);
  swatch.onclick = toggle_graph_motif;
  if (colouri != 0) {
    s_swatches[colouri -1] = swatch;
  }
  add_cell(row, swatch);
  add_text_cell(row, motif_dbs[motif['db']]['name'], 'col_db');
  add_cell(row, make_link(motif['id'], motif['url']), 'col_id');
  add_text_cell(row, motif['alt'], "col_name");
  add_text_cell(row, motif['consensus'], "col_consensus");
  add_text_cell(row, motif["central_prob"].toFixed(4), "col_concentration");
  add_text_cell(row, evstr(peak, 'log_adj_pvalue'), 'col_evalue');
  if (data['options']['neg_sequences']) {
    add_text_cell(row, evstr(peak, 'fisher_log_adj_pvalue'), "col_fisherpv");
  }
  add_text_cell(row, pvstr(peak), 'col_pvalue');
  if (data['options']['neg_sequences']) {
    add_text_cell(row, log2str(peak['neg_log_adj_pvalue'],1), "col_negative_binomial");
  } else {
    add_text_cell(row, '', "col_negative_binomial");
  }
  if (data['options']['mcc']) {
    add_text_cell(row, peak['mcc'].toFixed(3), "col_MCC");
  } else {
    add_text_cell(row, '', "col_MCC");
  }
  add_text_cell(row, peak['center'], "col_blocation");
  add_text_cell(row, peak['spread'], 'col_bwidth');
  add_text_cell(row, Math.round(peak['sites']), "col_bsites");
  add_text_cell(row, motif['total_sites'], "col_tsites");
  if (data['options']['neg_sequences']) {
    add_text_cell(row, Math.round(peak['neg_sites']), "col_negbsites");
    add_text_cell(row, motif['neg_total_sites'], "col_negtsites");
  } else {
    add_text_cell(row, '', "col_negbsites")
    add_text_cell(row, '', "col_negtsites");
  }
  add_text_cell(row, motif["max_prob"].toFixed(4), "col_maxprob");
  add_text_cell(row, motif["max_prob_loc"], "col_problocation");
  add_text_cell(row, motif['n_tested'], "col_nbinstested");
  add_text_cell(row, motif['score_threshold'].toExponential(2), "col_score");
  if (motif['peaks'].length > 1) {
    expander = document.createElement('span');
    expander.appendChild(document.createTextNode("\u21A7"));
    expander.className = "expander";
    expander.addEventListener("click", toggle_peaks, false);
    add_cell(row, expander, "col_OEbins");
  } else {
    add_text_cell(row, '-', "col_OEbins");
  }
  row.addEventListener('mouseover', highlight_peak, false);
  row.addEventListener('mouseout', dehighlight_peak, false);
}

function make_CEM_sub_row(tbody, peak) {
  var row = tbody.insertRow(tbody.rows.length);
  row['data_peak'] = peak;
  row.className = "sub_peak";
  add_text_cell(row,'\u2022', 'no_swatch');
  add_text_cell(row, '', 'col_db');
  add_text_cell(row, '', 'col_id');
  add_text_cell(row, '', 'col_name');
  add_text_cell(row, evstr(peak, 'log_adj_pvalue'), 'col_evalue');
  if (data['options']['neg_sequences']) {
    add_text_cell(row, evstr(peak, 'fisher_log_adj_pvalue'), "col_fisherpv");
  }
  add_text_cell(row, pvstr(peak), 'col_pvalue');
  if (data['options']['neg_sequences']) {
    add_text_cell(row, log2str(peak['neg_log_adj_pvalue'],1), "col_negative_binomial");
  } else {
    add_text_cell(row, '', "col_negative_binomial");
  }
  if (data['options']['mcc']) {
    add_text_cell(row, peak['mcc'].toFixed(3), "col_MCC");
  } else {
    add_text_cell(row, '', "col_MCC");
  }
  add_text_cell(row, peak['center'], "col_blocation");
  add_text_cell(row, peak['spread'], 'col_bwidth');
  add_text_cell(row, Math.round(peak['sites']), "col_bsites");
  add_text_cell(row, '', "col_tsites");
  if (data['options']['neg_sequences']) {
    add_text_cell(row, Math.round(peak['neg_sites']), "col_negbsites");
  } else {
    add_text_cell(row, '', "col_negbsites")
  }
  add_text_cell(row, '', "col_negtsites");
  add_text_cell(row, '', "col_maxprob");
  add_text_cell(row, '', "col_problocation");
  add_text_cell(row, '', "col_nbinstested");
  add_text_cell(row, '', "col_score");
  add_text_cell(row, '', "col_OEbins");
  row.addEventListener('mouseover', highlight_peak, false);
  row.addEventListener('mouseout', dehighlight_peak, false);
}

function make_CEM_skip_row(tbody, n_skipped) {
  var row, cell, desc;
  if (n_skipped === 0) return;
  row = tbody.insertRow(tbody.rows.length);
  row.className = "sub_peak";

  if (n_skipped === 1) {
    desc = "1 peak hidden due to filters";
  } else {
    desc = n_skipped + " peaks hidden due to filters";
  }

  cell = row.insertCell(row.cells.length);
  cell.colSpan = 19;
  cell.style.textAlign = "center";
  cell.style.fontWeight = "bold";
  cell.appendChild(document.createTextNode(desc));
}

/*
 * make_CEM_table
 *
 * Generate the table which lists centrally enriched motifs.
 */
function make_CEM_table() {
  var motif_sort, peak_sort;
  var filter, motifs, filtered, motif, peaks, motif_dbs;
  var tbl, tbody, row, cell, i, j, skipped;
  // get the filter and sort comparator
  motif_sort = motif_sort_cmp(parseInt($('motif_sort').value));
  peak_sort = peak_sort_cmp(parseInt($('peak_sort').value));
  filter = get_filter();

  motifs = data['motifs'];
  // sort the motif peaks
  for (i = 0; i < motifs.length; i++) {
    motif = motifs[i];
    peaks = motif['peaks'];
    for (j = 0; j < peaks.length; j++) {
      peaks[j]["filtered"] = filter_peak(filter, peaks[j]);
    }
    peaks.sort(peak_sort);
  }
  // filter the motifs
  filtered = [];
  for (i = 0; i < motifs.length; i++) {
    if (filter_motif(filter, motifs[i])) continue;
    if (motifs[i]["peaks"][0]["filtered"]) continue;
    filtered.push(motifs[i]);
  }
  // sort
  filtered.sort(motif_sort);
  // limit
  if (filter["on_count"]) {
    if (filtered.length > filter["count"]) filtered.length = filter["count"];
  }
  // re-add any omitted s_motifs motifs
  outer_loop:
  for (i = 0; i < s_motifs.length; i++) {
    if (s_motifs[i] == null) continue;
    for (j =0; j < filtered.length; j++) {
      if (filtered[j] === s_motifs[i]) {
        continue outer_loop;
      }
    }
    filtered.push(s_motifs[i]);
  }
  // sort again
  filtered.sort(motif_sort);

  // clear the table
  tbl = $("motifs");
  for (i = tbl.tBodies.length - 1; i >= 0; i--) {
    tbody = tbl.tBodies[i];
    tbody.parentNode.removeChild(tbody);
  }

  motif_dbs = data['motif_dbs'];
  // add the new rows to the table
  for (i = 0; i < filtered.length; i++) {
    motif = filtered[i];
    peaks = motif['peaks'];
    tbody = document.createElement('tbody');
    tbody.className = "peak_group";
    tbody["data_motif"] = motif;
    tbody.addEventListener('mouseover', hover_logo, false);
    tbody.addEventListener('mouseout', dehover_logo, false);
    make_CEM_main_row(tbody, motif);
    skipped = 0;
    for (j = 1; j < peaks.length; j++) {
      if (filter_peak(filter, peaks[j])) {
        skipped++;
        continue;
      }
      make_CEM_sub_row(tbody, peaks[j]);
    }
    make_CEM_skip_row(tbody, skipped);
    tbl.appendChild(tbody);
  }
  // note the count of filtered motifs
  if (filtered.length != motifs.length) {
    skipped =  motifs.length - filtered.length;
    tbody = document.createElement('tbody');
    row = tbody.insertRow(tbody.rows.length);

    if (skipped === 1) {
      desc = "1 motif hidden due to filters";
    } else {
      desc = skipped + " motifs hidden due to filters";
    }
    cell = row.insertCell(row.cells.length);
    cell.colSpan = 19;
    cell.style.textAlign = "center";
    cell.style.fontWeight = "bold";
    cell.appendChild(document.createTextNode(desc));
    tbl.appendChild(tbody);
  }
}

function get_filter() {
  var filter, id_pat, alt_pat, alt_re, log_evalue_max, spread, count;
  var neg_log_pvalue_min;
  filter = {};
  // get the db filter
  filter["on_db"] = $("filter_on_db").checked;
  filter["db"] = $("filter_db").value;
  // get the id filter
  filter["on_id"] = $("filter_on_id").checked;
  id_pat = $("filter_id").value;
  try {
    filter["id"] = new RegExp(id_pat, "i");
    $("filter_id").className = "";
  } catch (err) {
    $("filter_id").className = "error";
    filter["on_id"] = false;
  }
  // get the name filter
  filter["on_alt"] = $("filter_on_alt").checked;
  alt_pat = $("filter_alt").value;
  try {
    filter["alt"] = new RegExp(alt_pat, "i");
    $("filter_alt").className = "";
  } catch (err) {
    filter["on_alt"] = false;
    $("filter_alt").className = "error";
  }
  // get the evalue filter
  filter["on_pvalue"] = $("filter_on_evalue").checked;
  if ((log_evalue_max = str2log($("filter_evalue").value)) != null) {
    filter["log_pvalue"] = log_evalue_max - Math.log(data['tested']);
    $("filter_evalue").className = "";
  } else {
    filter["on_pvalue"] = false;
    $("filter_evalue").className = "error";
  }
  // get the Fisher pv filter
  filter["on_fisherpv"] = $("filter_on_fisherpv").checked;
  if ((log_fisherpv_max = str2log($("filter_fisherpv").value)) != null) {
    filter["log_fisherpv"] = log_fisherpv_max - Math.log(data['tested']);
    $("filter_fisherpv").className = "";
  } else {
    filter["on_fisherpv"] = false;
    $("filter_fisherpv").className = "error";
  }
  // get the spread filter
  filter["on_spread"] = $("filter_on_binwidth").checked;
  spread = parseInt($("filter_binwidth").value);
  if (isNaN(spread) || spread < 1) {
    filter["on_spread"] = false;
    $("filter_binwidth").className = "error";
  } else {
    filter["spread"] = spread;
    $("filter_binwidth").className = "";
  }
  // get the negative binomial test filter
  filter["on_neg"] = data['options']['neg_sequences'] && $("filter_on_negbintest").checked;
  if ((neg_log_pvalue_min = str2log($("filter_negbintest").value)) != null) {
    $("filter_negbintest").className = "";
    filter["neg_log_pvalue"] = neg_log_pvalue_min - Math.log(data['tested']);
  } else {
    filter["on_neg"] = false;
    $("filter_negbintest").className = "error";
  }
  // get the motif count limit
  filter["on_count"] = $("filter_on_top").checked;
  count = parseInt($("filter_top").value);
  if (isNaN(count) || count < 1) {
    filter["on_count"] = false;
    $("filter_top").className = "error";
  } else {
    filter["count"] = count;
    $("filter_top").className = "";
  }
  return filter; 
}

function filter_motif(filter, motif) {
  if (filter["on_db"] && motif["db"] != filter["db"]) return true;
  if (filter["on_id"] && !filter["id"].test(motif["id"])) return true;
  if (filter["on_alt"] && !filter["alt"].test(motif["alt"])) return true;
  return false;
}

function filter_peak(filter, peak) {
  if (filter["on_fisherpv"] && peak["fisher_log_adj_pvalue"] > filter["log_fisherpv"]) return true;
  if (filter["on_pvalue"] && peak["log_adj_pvalue"] > filter["log_pvalue"]) return true;
  if (filter["on_spread"] && peak["spread"] > filter["spread"]) return true;
  if (filter["on_neg"] && peak["neg_log_adj_pvalue"] < filter["neg_log_pvalue"]) return true;
  return false;
}

function filter_CEM_table() {
  "use strict";
  var tbl, tbody, tr, motif, peaks, i, j, filter;
  tbl = $("motifs");
  filter = get_filter();
  for (i = 0; i < tbl.tBodies.length; i++) {
    tbody = tbl.tBodies[i];
    motif = tbody["data_motif"];
    toggle_class(tbody, "filtered", filter_motif(filter, motif));
    for (j = 0; j < tbody.rows.length; j++) {

    }
  }
}

/*
 * show_all_peaks
 *
 * Show or hide sub-peaks
 */
function show_all_peaks(param) {
  var tbl = $("motifs");
  var tbody = tbl.tBodies[0];
  var NValue=param.childNodes[0].nodeValue; // Catch the motif (based on argument value sent by clicking on arrow)
  var bin_number=0;
  for (var i=0; i<tbody.rows.length;i++) { // For each motif
    if (tbody.rows[i].className==param.className) {    // For each sub-peaks
      bin_number++;
      if (must_be_display(param.className,bin_number)==false || NValue=="\u21A5") { // If it has to be hidden or arrow was up
        tbody.rows[i].style.display="none";    // Hide it
      }
      else {
      tbody.rows[i].style.display="table-row";    // Show it
      }
    }
  }
  param.childNodes[0].nodeValue= (NValue=="\u21A7") ? "\u21A5" : "\u21A7" ; // Change arrow orientation
}

function toggle_peaks(e) {
  var expander, group;
  if (!e) e = window.event;
  if (e.target) expander = e.target;
  else if (e.srcElement) expander = e.srcElement;
  group = find_parent(expander.parentNode, "peak_group");
  toggle_class(group, "more");
}

/*
 * must_be_display
 *
 * Check all sub-peaks and verify if they have to be displayed or not (based on filters)
 */
function must_be_display(ID, bin_number) {
  "use strict";
  var motifs, i, motif, peak, log_pvalue_max, log_evalue_max, log_pvalue_min;
  motifs = data['motifs'];
  for (i = 0; i < motifs.length; i++) {
    motif = motifs[i];
    if (motif['db'] + motif['id'] == ID) {    // Catch the motif
      peak = motif['peaks'][bin_number];    // Catch the sub-peaks
      if ($("filter_on_evalue").checked) {
        if ((log_evalue_max = str2log($("filter_evalue").value)) != null) {
          log_pvalue_max = log_evalue_max - Math.log(data['tested']);
        } else {
          log_pvalue_max = 0;
        }
        if (log_pvalue_max < peak['log_adj_pvalue']) return false; 
      }
      if ($("filter_on_fisherpv").checked) {
        if ((log_evalue_max = str2log($("filter_fisherpv").value)) != null) {
          log_pvalue_max = log_evalue_max - Math.log(data['tested']);
        } else {
          log_pvalue_max = 0;
        }
        if (log_pvalue_max < peak['fisher_log_adj_pv']) return false; 
      }
      if ($("filter_on_negbintest").checked) {
        if ((log_pvalue_max = str2log($("filter_negbintest").value)) == null) {
          log_pvalue_min = Math.log(data['tested']);
        }
        if (log_pvalue_min > peak['neg_log_adj_pvalue']) return false; 
      }
      if ($("filter_on_binwidth").checked && 
          parseInt($("filter_binwidth").value) > peak['spread']) {
            return false;
      }
    }
  }
  return true;
}

/*
 * make_PM_table
 *
 * Generate the table which lists plotted motifs
 */
function make_PM_table() {
  swap = null;
  var graphed = [];
  var unused = [];
  for (var i = 1; i < palate.length; i++) {
    if (s_motifs[i-1]) graphed.push(s_motifs[i-1]);
    else unused.push(i);
  }
  graphed.sort(sort_motif_evalue);

  var tbl = $("graph_list");
  var tbody = tbl.tBodies[0];
  while (tbody.rows.length > 0) {
    tbody.deleteRow(0);
  }
  // add the new rows to the table
  for (var i = 0; i < graphed.length; i++) {
    var motif = graphed[i];
    var colouri = motif['colouri'];
    if (!colouri) colouri = 0;
    var row = tbody.insertRow(tbody.rows.length);
    row['motif'] = motif;
    var swatch = make_swatch(colouri);
    swatch.onmousedown = swap_colour;
    add_cell(row, swatch);
    add_cell(row, make_link(motif['id'], motif['url']));
    if (!s_logos[colouri-1]) {
      s_logos[colouri-1] = document.createElement("canvas");
      var pspm = new Pspm(motif['pwm'], motif['id'], 0, 0, 
          motif['motif_nsites'], motif['motif_evalue']);
      var logo = logo_1(alphabet, "", pspm);
      draw_logo_on_canvas(logo, s_logos[colouri-1], false, 0.3);
    }
    add_cell(row, s_logos[colouri-1]);
  }
  var div = $("unused_colours");
  while (div.firstChild) div.removeChild(div.firstChild);
  $("unused_colours_section").style.display = (unused.length > 0 ? "block" : "none");
  for (var i = 0; i < unused.length; i++) {
    var swatch = make_swatch(unused[i]);
    swatch['colouri'] = unused[i];
    swatch.onclick = set_colour;
    div.appendChild(swatch);
  }
}

/*
 * make_MP_graph
 *
 * Create a motif probability graph on the canvas.
 */
function make_MP_graph() {
  var canvas = $("graph");
  canvas.width = canvas.width;
  if (canvas.getContext) {
    var ctx = canvas.getContext('2d');
    make_MP_graph2(ctx, canvas.width, canvas.height);
  }
}

function handle_MP_graph_mousemove(e) {
  "use strict";
  var graph, start, stop, left, width, pop;
  graph = $("graph");
  graph_click["stop"] = e.pageX - graph.getBoundingClientRect().left;
  // constrain stop and start to the graph
  start = graph_click["start"];
  if (start < graph_metrics.left_mark) {
    start = graph_metrics.left_mark;
  } else if (start > graph_metrics.right_mark) {
    start = graph_metrics.right_mark;
  }
  stop = graph_click["stop"];
  if (stop < graph_metrics.left_mark) {
    stop = graph_metrics.left_mark;
  } else if (stop > graph_metrics.right_mark) {
    stop = graph_metrics.right_mark;
  }
  // pick the smaller to be the left
  if (start < stop) {
    left = start;
    width = stop - start;
  } else {
    left = stop;
    width = start - stop;
  }
  // visualize the selected range 
  pop = $("pop_peak");
  if (width > 10) {
    pop.style.width = width + "px";
    pop.style.left = left + "px";
    pop.style.visibility = "visible";
  } else {
    pop.style.visibility = "hidden";
  }
}

function handle_MP_graph_mouseup(e) {
  "use strict";
  var graph, start, stop, left, right, left_val, right_val, pop, l, w, d, unit;
  document.removeEventListener("mouseup", handle_MP_graph_mouseup, false);
  document.removeEventListener("mousemove", handle_MP_graph_mousemove, false);
  graph = $("graph");
  graph_click["stop"] = e.pageX - graph.getBoundingClientRect().left;
  // hide the range preview
  pop = $("pop_peak");
  pop.style.visibility = "hidden";
  // constrain stop and start to the graph
  start = graph_click["start"];
  if (start < graph_metrics.left_mark) {
    start = graph_metrics.left_mark;
  } else if (start > graph_metrics.right_mark) {
    start = graph_metrics.right_mark;
  }
  stop = graph_click["stop"];
  if (stop < graph_metrics.left_mark) {
    stop = graph_metrics.left_mark;
  } else if (stop > graph_metrics.right_mark) {
    stop = graph_metrics.right_mark;
  }
  // pick the smaller to be the left
  if (start < stop) {
    left = start;
    right = stop;
  } else {
    left = stop;
    right = start;
  }
  l = graph_metrics.left_mark;
  w = graph_metrics.right_mark - graph_metrics.left_mark;
  d = graph_metrics.right_val - graph_metrics.left_val;
  unit = w / d;
  // convert into graph values
  left_val = graph_metrics.left_val + Math.round((left - l) / unit);
  right_val =  graph_metrics.left_val + Math.round((right - l) / unit);
  // check if we're doing a legend move and not a zoom
  if ((right - left) < 10 || left_val == right_val) {
    move_legend(e);
    return;
  }
  // add a zoom to the stack
  zooms.push({"left_val": left_val, "right_val": right_val});
  make_MP_graph();
  $("zoom_out").disabled = false;
  $("zoom_center").disabled = false;
}

function handle_MP_graph_mousedown(e) {
  "use strict";
  var graph;
  document.addEventListener("mouseup", handle_MP_graph_mouseup, false);
  document.addEventListener("mousemove", handle_MP_graph_mousemove, false);
  graph = $("graph");
  graph_click["start"] = e.pageX - graph.getBoundingClientRect().left;
  
}

function handle_zoom_out_click() {
  if (zooms.length > 0) {
    zooms.pop();
    make_MP_graph();
    if (zooms.length == 0) {
      $("zoom_out").disabled = true;
      $("zoom_center").disabled = true;
    }
  }
}

function handle_zoom_center_click() {
  var zoom, reach;
  if (zooms.length > 0) {
    zoom = zooms.pop();
    reach = Math.max(1, Math.round((zoom["right_val"] - zoom["left_val"]) / 2));
    zooms.push({"left_val": -reach, "right_val": reach});
    make_MP_graph();
  }
}

function add_MP_graph_listeners() {
  "use strict";
  var graph, zoom_out, zoom_center;
  graph = $("graph");
  graph.addEventListener("mousedown", handle_MP_graph_mousedown, false);
  zoom_out = $("zoom_out");
  zoom_out.disabled = true;
  zoom_out.addEventListener("click", handle_zoom_out_click, false);
  zoom_center = $("zoom_center");
  zoom_center.addEventListener("click", handle_zoom_center_click, false);
  zoom_center.disabled = true;
}

function download_eps() {
  var canvas = $("graph");
  canvas.width = canvas.width;
  if (canvas.getContext) {
    var ctx = canvas.getContext('2d');
    var eps_ctx = new EpsContext(ctx, canvas.width, canvas.height);
    eps_ctx.register_font("19px Helvetica", "Helvetica", 19);
    eps_ctx.register_font("16px Helvetica", "Helvetica", 16);
    eps_ctx.register_font("9px Helvetica", "Helvetica", 9);
    make_MP_graph2(ctx, canvas.width, canvas.height);
    $("eps_content").value = eps_ctx.eps();
  }
}

function make_MP_graph2(ctx, width, height) {
  "use strict";
  var windo, type, legend, plot_negative, plot_distance, motifs, rset, i, motif;
  var name, sig, colour, weights, graph, peak_highlight;
  // get the graph settings
  windo = parseInt($("windo").value);
  if (isNaN(windo) || windo < 1) {
    $("windo").value = windo = default_smoothing_window;
  }
  type = parseInt($("plot_type").value);
  legend = parseInt($("legend").value);
  plot_negative = parseInt($("plot_negative").value);
  plot_distance = parseInt($("plot_distance").value) != 0;
  // get the selected motifs
  motifs = [];
  for (i = 0; i < s_motifs.length; i++) {
    if (s_motifs[i] != null) motifs.push(s_motifs[i]);
  }
  // sort the motifs
  motifs.sort(sort_motif_evalue);
  // create a result set with all the selected motifs
  rset = new CentrimoRSet(data["seqlen"]);
  for (i = 0; i < motifs.length; i++) {
    motif = motifs[i];
    name = motif["id"];
    if (motif["alt"]) name = motif["alt"] + " " + motif["id"];
    sig = "p=" + log2str(motif["best_log_adj_pvalue"], 1);
    colour = palate[motif["colouri"]];
    if (plot_negative) {
      rset.add(name, sig, colour, motif["len"], motif["total_sites"],
        motif["sites"], motif["neg_total_sites"], motif["neg_sites"]);
    } else {
      rset.add(name, sig, colour, motif["len"], motif["total_sites"],
        motif["sites"], 0, 0);
    }
  }
  // get the smoothing weights
  weights = (type == 1 ? triangular_weights(windo) : uniform_weights(windo));
  // get the zoom
  var range_left = null;
  var range_right = null;
  if (zooms.length > 0) {
    var zoom = zooms[zooms.length - 1];
    range_left = zoom["left_val"];
    range_right = zoom["right_val"];
  }
  // now make a new graph from the result set and smoothing weights
  graph = new CentrimoGraph(rset, weights, "CentriMo " + data["version"], range_left, range_right, plot_distance);
  graph_metrics = graph.draw_graph(ctx, width, height, legend, legend_x, legend_y);
  peak_highlight = $("pop_peak");
  peak_highlight.style.top = graph_metrics.top_edge + "px";
  peak_highlight.style.height = (graph_metrics.bottom_edge - graph_metrics.top_edge) + "px";
}

function sync_sort_selection () {
  "use strict";
  var i, mapper, motif_sort, region_sort;
  motif_sort = $("motif_sort");
  region_sort = $("peak_sort");
  if (typeof sync_sort_selection.mapper === "undefined") {
    var id2idx;
    // first map region id to index
    id2idx = {};
    for (i = 0; i < region_sort.options.length; i++) {
      id2idx[sort_table["region"][parseInt(region_sort.options[i].value, 10)]["id"]] = i;
    }
    // now generate a mapping of index in motif sort to index in region sort
    mapper = [];
    for (i = 0; i < motif_sort.options.length; i++) {
      mapper[i] = id2idx[sort_table["motif"][parseInt(motif_sort.options[i].value, 10)]["pair"]];
    }
    sync_sort_selection.mapper = mapper;
  } else {
    mapper = sync_sort_selection.mapper;
  }
  if (!$('allow_peak_sort').checked) {
    region_sort.selectedIndex = mapper[motif_sort.selectedIndex];
  }
}

function populate_sort_list (sellist, items) {
  var i, j, item, opt, priority, selected;
  priority = 0;
  selected = 0;
  for (i = 0, j = 0; i < items.length; i++) {
    item = items[i];
    if (typeof item["show"] === 'undefined' || item["show"]) {
      opt = document.createElement("option");
      opt.innerHTML = item["name"];
      opt.value = i;
      sellist.add(opt, null);
      if (typeof item["priority"] !== 'undefined' && item["priority"] > priority) {
        selected = j;
        priority = item["priority"];
      }
      j++;
    }
  }
  sellist.selectedIndex = selected;
}

function populate_sort_lists() {
  "use strict";
  var i, motif_sort, region_sort, motif_sort_list, region_sort_list;
  motif_sort = $("motif_sort");
  region_sort = $("peak_sort");
  try {motif_sort.removeEventListener("click", sync_sort_selection, false);} catch (e) {}
  try {motif_sort.removeEventListener("change", sync_sort_selection, false);} catch (e) {}
  for (i = motif_sort.options.length-1; i >= 0; i--) motif_sort.remove(i);
  for (i = region_sort.options.length-1; i >= 0; i--) region_sort.remove(i);
  motif_sort_list = sort_table["motif"];
  region_sort_list = sort_table["region"];
  populate_sort_list(motif_sort, motif_sort_list);
  populate_sort_list(region_sort, region_sort_list);
  sync_sort_selection();
  motif_sort.addEventListener("click", sync_sort_selection, false);
  motif_sort.addEventListener("change", sync_sort_selection, false);
}

function make_other_settings() {
  $("opt_obj").textContent = data.options.cd ? "central distance enrichment (CD)" : (data.options.local ? "local region enrichment (LE)" : "central region enrichment (CE)");
  $("opt_xalph").textContent = data.options.xalph != "" ? "Yes: use alphabet in file" + data.options.xalph: "No";
  $("opt_motif_pseudo").textContent = data.options.motif_pseudo;
  $("opt_seqlen").textContent = data.options.seqlen == 0 ? "None" : data.options.seqlen;
  $("opt_use_pvalues").textContent = data.options.use_pvalues ? "p-values" : "log-odds scores";
  $("opt_score").textContent = data.options.use_pvalues ? data.options.score : 
    data.options.use_lo_fraction ? 100*data.options.score + "% of maximum log-odds score" : data.options.score + " (bits)";
  $("opt_optimize_score").textContent = data.options.optimize_score ? "Yes" : "No";
  $("opt_minreg").textContent = data.options.minbin;
  $("opt_maxreg").textContent = data.options.maxbin;
  $("opt_strands").textContent = data.options.norc ? (data.options.sep ? "scan with complementary motifs, too" : "scan given strands only") : "scan both strands if alphabet is complementable";
  $("opt_flip").textContent = data.options.flip ? "'reflected' around sequence centers" : "same as for positive strand";
  $("opt_noseq").textContent = data.options.noseq ? "No" : "Yes";

}

    </script>
    <script type="text/javascript">
//
// citation.js
//
function get_citation_text(doc_type, extra) {
  var html;

  switch (doc_type) {
    case 'AMA':
      return(get_citation_text("GOMo", extra));
    case 'AME':
      return(extra + `
        <span class="citation">
          Robert C. McLeay and Timothy L. Bailey,
          &quot;Motif Enrichment Analysis: a unified framework and an evaluation on ChIP data&quot;,
          <i>BMC Bioinformatics</i>, <b>11</b>:165, 2010.
          <a href="http://www.biomedcentral.com/1471-2105/11/165">[full text]</a>
        </span>
      `);
    case 'CentriMo':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey and Philip Machanick,
          &quot;Inferring direct DNA binding from ChIP-seq&quot;,
          <i>Nucleic Acids Research</i>, <b>40</b>:e128, 2012.
          <a href="http://nar.oxfordjournals.org/content/40/17/e128">[Full Text]</a>
        </span>
      `);
    case 'DREME':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey,
          &quot;DREME: Motif discovery in transcription factor ChIP-seq data&quot;,
          <i>Bioinformatics</i>, <b>27</b>(12):1653-1659, 2011.
          <a href="http://bioinformatics.oxfordjournals.org/content/27/12/1653">[full text]</a>
        </span>
      `);
    case 'FIMO':
      return(extra + `
        <span class="citation">
          Charles E. Grant, Timothy L. Bailey and William Stafford Noble,
          &quot;FIMO: Scanning for occurrences of a given motif&quot;,
          <i>Bioinformatics</i> <b>27</b>(7):1017-1018, 2011.
          <a href="http://bioinformatics.oxfordjournals.org/content/27/7/1017">[full text]</a>
        </span>
      `);
    case 'GLAM2':
    case 'GLAM2SCAN':
      return(extra + `
        <span class="citation">
          Martin C. Frith, Neil F. W. Saunders, Bostjan Kobe and Timothy L. Bailey,
          &quot;Discovering sequence motifs with arbitrary insertions and deletions&quot;,
          <i>PLoS Computational Biology</i>, <b>4</b>(5):e1000071, 2008.
          <a href="https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1000071">[full text]</a>
        </span>
      `);
    case 'GOMo':
      return(extra + `
        <span class="citation">
          Fabian A. Buske, Mikael Bod&eacute;n, Denis C. Bauer and Timothy L. Bailey,
          &quot;Assigning roles to DNA regulatory motifs using comparative genomics&quot;,
          <i>Bioinformatics</i>, <b>26</b>(7), 860-866, 2010.
          <a href="http://bioinformatics.oxfordjournals.org/cgi/content/full/26/7/860">[full text]</a>
        </span>
      `);
    case 'MAST':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey and Michael Gribskov,
          &quot;Combining evidence using p-values: application to sequence homology searches&quot;,
          <i>Bioinformatics</i>, <b>14</b>(1):48-54, 1998.
          <a href="http://bioinformatics.oxfordjournals.org/content/14/1/48">[full text]</a>
        </span>
      `);
    case 'MCAST':
      return(extra + `
        <span class="citation">
          Timothy Bailey and William Stafford Noble,
          &quot;Searching for statistically significant regulatory modules&quot;,
          <i>Bioinformatics (Proceedings of the European Conference on Computational Biology)</i>,
          <b>19</b>(Suppl. 2):ii16-ii25, 2003.
          <a href="http://bioinformatics.oxfordjournals.org/cgi/content/abstract/19/suppl_2/ii16">[full text]</a>
        </span>
      `);
    case 'Meta-MEME':
      return(extra + `
        <span class="citation">
	  William N. Grundy, Timothy L. Bailey, Charles P. Elkan and Michael E. Baker.
	  &quot;Meta-MEME: Motif-based Hidden Markov Models of Protein Families&quot;
	  <i>Computer Applications in the Biological Sciences (CABIOS)</i>,
	  <b>13</b>(4):397-406, 1997.
	  <a href="http://bioinformatics.oxfordjournals.org/content/13/4/397">[full text]</a>
        </span>
      `);
    case 'MEME':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey and Charles Elkan,
          &quot;Fitting a mixture model by expectation maximization to
          discover motifs in biopolymers&quot;,
          <em>Proceedings of the Second International Conference on Intelligent Systems
          for Molecular Biology</em>, pp. 28-36, AAAI Press, Menlo Park, California, 1994.
          <a href="http://www.aaai.org/Papers/ISMB/1994/ISMB94-004.pdf">[full text]</a>
        </span>
      `);
    case 'MEME-ChIP':
      return(extra + `
        <span class="citation">
          Philip Machanick and Timothy L. Bailey,
          &quot;MEME-ChIP: motif analysis of large DNA datasets&quot;,
          <i>Bioinformatics</i> <b>27</b>(12):1696-1697, 2011.
        <a href="http://bioinformatics.oxfordjournals.org/content/27/12/1696.full">[full text]</a>
        </span>
      `);
    case 'MEME_SUITE':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey, James Johnson, Charles E. Grant, William S. Noble,
          &quot;The MEME Suite&quot;,
          <i>Nucleic Acids Research</i>, <b>43</b>(W1):W39-W49, 2015.
          <a href="https://academic.oup.com/nar/article/43/W1/W39/2467905">[full text]</a>
        </span>
      `);
    case 'MoMo':
      return(extra + `
        <span class="citation">
          Alice Cheng, Charles Grant, Timothy L. Bailey and William Noble,
          &quot;MoMo: Discovery of statistically significant post-translational modification motifs&quot;, 
          <i>Bioinformatics</i>, <b>35</b>(16):2774-2782, 2018.
          <a href="https://doi.org/10.1093/bioinformatics/bty1058">[full text]</a>
        </span>
      `);
    case 'PSPs':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey, Mikael Bod&eacute;n, Tom Whitington and Philip Machanick,
          &quot;The value of position-specific priors in motif discovery using MEME&quot;,
          <i>BMC Bioinformatics</i>, <b>11</b>(1):179, 2010.
          <a href="http://www.biomedcentral.com/1471-2105/11/179">[full text]</a>
        </span>
      `);
    case 'SEA':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey, &quot;SEA: Simple Enrichment Analysis of motifs&quot;,
          <i>BioRxiv</i>, 2021.
          <a href="FIXME">[full text]</a>
        </span>
      `);
    case 'SpaMo':
      return(extra + `
        <span class="citation">
          Tom Whitington, Martin C. Frith, James Johnson and Timothy L. Bailey
          &quot;Inferring transcription factor complexes from ChIP-seq data&quot;,
          <i>Nucleic Acids Res.</i> <b>39</b>(15):e98, 2011.
          <a href="http://nar.oxfordjournals.org/content/39/15/e98">[full text]</a>
        </span>
      `);
    case 'STREME':
      return(extra + `
        <span class="citation">
          Timothy L. Bailey,
          &quot;STREME: accurate and versatile sequence motif discovery&quot;,
          <i>Bioinformatics</i>, Mar. 24, 2021.
          <a href="https://academic.oup.com/bioinformatics/advance-article-abstract/doi/10.1093/bioinformatics/btab203/6184861" >[full text]</a>
        </span>
      `);
    case 'Tomtom':
      return(extra + `
        <span class="citation">
          Shobhit Gupta, JA Stamatoyannopolous, Timothy Bailey and William Stafford Noble,
          &quot;Quantifying similarity between motifs&quot;,
          <i>Genome Biology</i>, <b>8</b>(2):R24, 2007.
          <a href="http://genomebiology.com/2007/8/2/R24">[full text]</a>
        </span>
      `);
    case 'T-Gene':
      return(extra + `
        <span class="citation">
          Timothy O'Connor, Charles E. Grant, Mikael Bod&eacute;n, Timothy L. Bailey,
          &quot;T-Gene: Improved target gene prediction&quot;,
            <i>Bioinformatics</i>, <b>36</b>(12):3902-3904, 2020.
          <a href="https://academic.oup.com/bioinformatics/article/36/12/3902/5815978?guestAccessKey=aa625a49-a2aa-4d7a-858e-8bc82867a534">[Full Text]</a>
        </span>
      `);
    case 'XSTREME':
      return(extra + `
        <span class="citation">
          Charles E. Grant and Timothy L. Bailey, &quot;XSTREME: comprehensive motif analysis of biological sequence datasets&quot;,
          <i>BioRxiv</i>, 2021.
          <a href="FIXME">[full text]</a>
        </span>
      `);
    default:
      return("Unknown program: " + doc_type);
  }
} // get_citation_text

//
// Function to replace the innerHTML of element "id" with an HTML paragraph
// containing the text for 'program', which is known to function get_citation_text.
// If "id" is either "citation" or "reference" some extra text is printed.
//
function print_citation(id, program) {
  var extra;
  switch (id) {
    case 'citation':
      extra = "If you use " + program + " in your research, please cite the following paper:<br>";
      break;
    case 'reference':
      extra = "<h5>Reference</h5>";
      break;
    default:
      extra = "";
      break;
  };
  var html = get_citation_text(program, extra);
  document.getElementById(id).insertAdjacentHTML('beforeend', html);
} // print_citation

// 
// Function to convert a citation for a program to a C #define statement.
//
function print_citation_define(lang, pgm) {
  var citation = get_citation_text(pgm, '');
  citation = citation.replace(/<[^>]*>/g, '');
  citation = citation.replace(/\[.*\]/g, '');
  citation = citation.replace(/\n\s*/g, '\\n');
  citation = citation.replace(/&quot;/g, '\\"');
  citation = citation.replace(/&eacute;/g, 'e');
  citation = citation.replace(/^\\n/, '');
  pgm = pgm.replace(/-/, '');
  citation = "If you use this program in your research, please cite:\\n\\n" + citation;
  if (lang == "C") {
    citation = "#define " + pgm + '_CITE "' + citation + '"';
  } else if (lang == "perl") {
    citation = '"' + pgm + '" => "' + citation + '",';
  }
  return(citation);
} // print_citation_define

//
// Main program (for use with nodejs "node" javascript engine)
// to create citation.js.h and citation.pm from citation.js.
// The command line:
//   node citation.js C > citation.js.h
// will output the C #define statements for each of the
// programs listed below, defining macros <program>_CITE.
// The command line:
//   node citation.js perl > citation.js.pm
// will output perl hash <program> => text
//
//
if (typeof process !== 'undefined') {
  var lang = process.argv[2];
  var programs = ['AMA', 'AME', 'CentriMo', 'DREME', 'FIMO', 'GLAM2', 
    'GLAM2SCAN', 'GOMo', 'MAST', 'MCAST', 'Meta-MEME', 'MEME',
    'MEME-ChIP', 'MEME_SUITE', 'MoMo', 'PSPs', 'SEA', 'SpaMo',
    'STREME', 'Tomtom', 'T-Gene', 'XSTREME'];

  if (lang == "C") {
    console.log("// Do not edit this file.  It is created from etc/citation.js.");
    console.log("#ifndef citation_js_h\n#define citation_js_h\n");
    for (var i=0; i<programs.length; i++) {
      console.log(print_citation_define(lang, programs[i]));
    }
    console.log("\n#endif");
  } else if (lang == "perl") {
    console.log("# Do not edit this file.  It is created from etc/citation.js.");
    console.log("package Citation;");
    console.log("sub cite {\n  my ($pgm) = @_;\n  return $citation{$pgm};\n}");
    console.log("%citation = (");
    for (var i=0; i<programs.length; i++) {
      console.log(print_citation_define(lang, programs[i]));
    }
    console.log(");");
  }
}

    </script>
    <script type="text/javascript">
//
// description_section.js
//

//
// Create a description element taking into account newlines (line breaks) 
// and multiple newlines (paragraph breaks) in the source text.
//
function make_description(container, description) {
  "use strict";
  var header, box, paragraphs, p, lines, i, j;
  container.innerHTML = "";
  if (description) {
    header = document.createElement("h2");
    header.className = "mainh pad2";
    header.id = "description";
    header.appendChild(document.createTextNode("Description"));
    container.appendChild(header);
    box = document.createElement("div");
    box.className = "box";
    container.appendChild(box);
    var text = description.replace(/\\n/g, "\n");
    paragraphs = text.split(/\n\n+/);
    for (i = 0; i < paragraphs.length; i++) {
      p = document.createElement("p");
      lines = paragraphs[i].split("\n");
      for (j = 0; j < lines.length; j++) {
        if (j != 0) p.appendChild(document.createElement('br'));
        p.appendChild(document.createTextNode(lines[j]));
      }
      box.appendChild(p);
    }
  }
}

    </script>
    <style type="text/css">
div.graph_box {
  position: relative;
}
div.pop_graph_peak {
  position:absolute; 
  left: 0;
  top: 0; 
  z-index: 5; 
  width: 10px;
  height: 10px; 
  opacity: 0.2; 
  background-color: #3333ff;
  visibility: hidden;
}
table.inputs, table.alpha_bg_table {
  margin-top: 20px;
  border-collapse:collapse;
}
table.inputs * td, table.inputs * th, table.alpha_bg_table * td, table.alpha_bg_table * th {
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 1px;
  padding-bottom: 1px;
}
table.motifs {
  margin-top: 20px;
  border-collapse:collapse;
}
table.motifs * td, table.motifs * th {
  padding-left: 15px;
  padding-right: 15px;
  padding-top: 1px;
  padding-bottom: 1px;
}
table.motifs * td.col_blocation, table.motifs * td.col_bwidth, 
table.motifs * td.col_bsites, table.motifs * td.col_tsites,
table.motifs * td.col_negbsites, table.motifs * td.col_negtsites,
table.motifs * td.col_maxprob, table.motifs * td.col_concentration,
table.motifs * td.col_problocation,
table.motifs * td.col_nbinstested, table.motifs * td.col_score {
  text-align: right;
  padding-right: 40px;
}
table.motifs tbody:hover { 
  background: #ddddff; 
}
table.motifs tbody tr:hover {
  background: #ccccff; 
}
table.hide_db .col_db {
  display: none;
}
table.hide_id .col_id {
  display: none;
}
table.hide_name .col_name {
  display: none;
}
table.hide_consensus .col_consensus {
  display: none;
}
table.hide_fisherpv .col_fisherpv {
  display: none;
}
table.hide_evalue .col_evalue {
  display: none;
}
table.hide_pvalue .col_pvalue {
  display: none;
}
table.hide_MCC .col_MCC {
  display: none;
}
table.hide_concentration .col_concentration {
  display: none;
}
table.hide_maxprob .col_maxprob {
  display: none;
}
table.hide_bsites .col_bsites {
  display: none;
}
table.hide_negbsites .col_negbsites {
  display: none;
}
table.hide_blocation .col_blocation {
  display: none;
}
table.hide_hpeak .col_problocation {
  display: none;
}
table.hide_bwidth .col_bwidth {
  display: none;
}
table.hide_tsites .col_tsites {
  display: none;
}
table.hide_negtsites .col_negtsites {
  display: none;
}
table.hide_nbinstested .col_nbinstested {
  display: none;
}
table.hide_score .col_score {
  display: none;
}
table.hide_negative_binomial .col_negative_binomial {
  display: none;
}
table.hide_OEbins .col_OEbins {
  display: none;
}
div.graph_options_section {
  width:30%; 
  float:right;
}
div.graph_options_section h5 {
  margin-top: 10px;
}
table.graph_list {
  border-collapse:collapse;
}
table.graph_list * td, table.graph_list * th {
  padding-left: 5px;
  padding-right: 5px;
  padding-top: 1px;
  padding-bottom: 1px;
}
th.deselect {
  font-size:25px; 
  cursor: default;
}
th.deselect:hover {
  color: red;
}
div.filter {
  display: inline-block;
  padding-right: 10px;
}
div.swatch {
  margin: auto;
  width: 20px;
  height: 20px;
  text-align: center;
  font-size: 16px;
  border: 1px solid black;
  cursor: default;
}
div.swatch:hover {
  width: 16px;
  height: 16px;
  font-size: 16px;
  border: 3px outset black;
}
div.swatch:active {
  width: 16px;
  height: 16px;
  font-size: 16px;
  border: 3px inset black;
}
span.expander {
  cursor: pointer;
  font-size: larger;
}
div.pop_logo {
  position:absolute;
  z-index:1;
  top:0px;
  left:0px;
  border: 3px outset black;
  background-color: white;
  display:none;
}
div.pop_colour {
  position:absolute;
  z-index:1;
  top:0px;
  left:0px;
  margin-left: -13px;
  margin-top: -13px;
  display:none;

}
div.pop_content {
  position:absolute;
  z-index:1;
  width:300px;
  padding: 5px;
  background: #E4ECEC;
  font-size: 12px;
  font-family: Arial;
  border-style: double;
  border-width: 3px;
  border-color: #AA2244;
  display:none;
}

span.arrow {
  font-size: larger;
  color: red;
}

#unused_colours div.swatch {
  display: inline-block;
  margin-right: 5px;
}

.no_swatch {
  text-align: center;
  font-size: larger;
}

input.error:enabled {
  background: #FF5555;
}

tr.sub_peak {
  display: none;
}

tbody.more > tr.sub_peak {
  display: table-row;
}

    </style>
    <style type="text/css">
/* The following is the content of meme.css */
body { background-color:white; font-size: 12px; font-family: Verdana, Arial, Helvetica, sans-serif;}

div.help {
  display: inline-block;
  margin: 0px;
  padding: 0px;
  width: 12px;
  height: 13px;
  cursor: pointer;
  background-image: url(data:image/gif;base64,R0lGODlhDAANAIABANR0AP///yH5BAEAAAEALAAAAAAMAA0AAAIdhI8Xy22MIFgv1DttrrJ7mlGNNo4c+aFg6SQuUAAAOw==);
}

div.help:hover {
  background-image: url(data:image/gif;base64,R0lGODlhDAANAKEAANR0AP///9R0ANR0ACH+EUNyZWF0ZWQgd2l0aCBHSU1QACH5BAEAAAIALAAAAAAMAA0AAAIdDGynCe3PgoxONntvwqz2/z2K2ImjR0KhmSIZUgAAOw==);
}

p.spaced { line-height: 1.8em;}

span.citation { font-family: "Book Antiqua", "Palatino Linotype", serif; color: #004a4d;}

p.pad { padding-left: 30px; padding-top: 5px; padding-bottom: 10px;}

td.jump { font-size: 13px; color: #ffffff; background-color: #00666a;
  font-family: Georgia, "Times New Roman", Times, serif;}

a.jump { margin: 15px 0 0; font-style: normal; font-variant: small-caps;
  font-weight: bolder; font-family: Georgia, "Times New Roman", Times, serif;}

h2.mainh {font-size: 1.5em; font-style: normal; margin: 15px 0 0;
  font-variant: small-caps; font-family: Georgia, "Times New Roman", Times, serif;}

h2.line {border-bottom: 1px solid #CCCCCC; font-size: 1.5em; font-style: normal;
  margin: 15px 0 0; padding-bottom: 3px; font-variant: small-caps;
  font-family: Georgia, "Times New Roman", Times, serif;}

h4 {border-bottom: 1px solid #CCCCCC; font-size: 1.2em; font-style: normal;
  margin: 10px 0 0; padding-bottom: 3px; font-family: Georgia, "Times New Roman", Times, serif;}

h5 {margin: 0px}

a.help { font-size: 9px; font-style: normal; text-transform: uppercase;
  font-family: Georgia, "Times New Roman", Times, serif;}

div.pad { padding-left: 30px; padding-top: 5px; padding-bottom: 10px;}

div.pad1 { margin: 10px 5px;}

div.pad2 { margin: 25px 5px 5px;}
h2.pad2 { padding: 25px 5px 5px;}

div.pad3 { padding: 5px 0px 10px 30px;}

div.box { border: 2px solid #CCCCCC; padding:10px; overflow: hidden;}

div.bar { border-left: 7px solid #00666a; padding:5px; margin-top:25px; }

div.subsection {margin:25px 0px;}

img {border:0px none;}

th.majorth {text-align:left;}
th.minorth {font-weight:normal; text-align:left; width:8em; padding: 3px 0px;}
th.actionth {font-weight:normal; text-align:left;}

.explain h5 {font-size:1em; margin-left: 1em;}

div.doc {margin-left: 2em; margin-bottom: 3em;}

th.trainingset {
  border-bottom: thin dashed black; 
  font-weight:normal; 
  padding:0px 10px;
}
div.pop_content {
  position:absolute;
  z-index:50;
  width:300px;
  padding: 5px;
  background: #E4ECEC;
  font-size: 12px;
  font-family: Arial;
  border-style: double;
  border-width: 3px;
  border-color: #AA2244;
  display:none;
}
div.pop_content_wide {
  position:absolute;
  z-index:1;
  width:700px;
  padding: 5px;
  background: #E4ECEC;
  font-size: 12px;
  font-family: Arial;
  border-style: double;
  border-width: 3px;
  border-color: #AA2244;
  display:none;
}

div.pop_content > *:first-child {
  margin-top: 0px;
}

div.pop_content h1, div.pop_content h2, div.pop_content h3, div.pop_content h4, 
div.pop_content h5, div.pop_content h6, div.pop_content p {
  margin: 0px;
}

div.pop_content p + h1, div.pop_content p + h2, div.pop_content p + h3, 
div.pop_content p + h4, div.pop_content p + h5, div.pop_content p + h6 {
  margin-top: 5px;
}

div.pop_content p + p {
  margin-top: 5px;
}

div.pop_content > *:last-child {
  margin-bottom: 0px;
}

div.pop_content div.pop_close {
  /* old definition */
  float:right;
  bottom: 0;
}

div.pop_content span.pop_close, div.pop_content span.pop_back {
  display: inline-block;
  border: 2px outset #661429;
  background-color: #CCC;
  padding-left: 1px;
  padding-right: 1px;
  padding-top: 0px;
  padding-bottom: 0px;
  cursor: pointer;
  color: #AA2244; /*#661429;*/
  font-weight: bold;
}

div.pop_content span.pop_close:active, div.pop_content span.pop_back:active {
  border-style: inset;
}

div.pop_content span.pop_close {
  float:right;
  /*border: 2px outset #AA002B;*/
  /*color: #AA2244;*/
}

div.pop_content:not(.nested) .nested_only {
  display: none;
}

div.pop_back_sec {
  margin-bottom: 5px;
}

div.pop_close_sec {
  margin-top: 5px;
}

table.hide_advanced tr.advanced {
  display: none;
}
span.show_more {
  display: none;
}
table.hide_advanced span.show_more {
  display: inline;
}
table.hide_advanced span.show_less {
  display: none;
}


/*****************************************************************************
 * Program logo styling
 ****************************************************************************/
div.prog_logo {
  border-bottom: 0.25em solid #0f5f60;
  height: 4.5em;
  width: 25em;
  display:inline-block;
}
div.prog_logo img {
  float:left;
  width: 4em;
  border-style: none;
  margin-right: 0.2em;
}
div.prog_logo h1, div.prog_logo h1:hover, div.prog_logo h1:active, div.prog_logo h1:visited {
  margin:0;
  padding:0;
  font-family: Arial, Helvetica,  sans-serif;
  font-size: 3.2em;
  line-height: 1em;
  vertical-align: top;
  display: block;
  color: #026666;
  letter-spacing: -0.06em;
  text-shadow: 0.04em 0.06em 0.05em #666;
}
div.prog_logo h2, div.prog_logo h2:hover, div.prog_logo h2:active, div.prog_logo h2:visited {
  display: block;
  margin:0;
  padding:0;
  font-family: Helvetica, sans-serif;
  font-size: 0.9em;
  line-height: 1em;
  letter-spacing: -0.06em;
  color: black;
}
div.prog_logo h3, div.prog_logo h3:hover, div.prog_logo h3:active, div.prog_logo h3:visited {
  display: block;
  margin:0;
  padding:0;
  font-family: Helvetica, sans-serif;
  font-size: 0.9em;
  line-height: 1.5em;
  letter-spacing: -0.06em;
  color: black;
}

div.big.prog_logo {
  font-size: 18px;
}

/* These are for centered columns in tables */
td.ctr {
  text-align: center;
}

/* These are for the navigation bars at the top of outputs. */
table.navigation {
  margin-top: 0px;
  border-collapse:collapse;
}
table.navigation * td
{
  padding-left: 0px;
  padding-right: 10px;
  padding-top: 0px;
  padding-bottom: 0px;
}

    </style>
  </head>
  <body onload="page_loaded()" onpageshow="page_shown(event)">
    <!-- Popups -->
    <div id="logo_popup" class="pop_logo">
      <canvas id="logo_popup_canvas" width="200" height="50"></canvas>
      <canvas id="logo_popup_canvas_rc" width="200" height="50"></canvas>
    </div>
    <!-- Help popups -->
    <div class="pop_content" id="pop_alph_name">
      <script>print_doc_para('pop_alph_name', 'shared', 'alph-name', 'The ');</script>
      <div class="pop_close">[<a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_alph_bg">
      <script>print_doc_para('pop_alph_bg', 'shared', 'alph-bg', 'The ');</script>
      <div class="pop_close">[<a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_results">
      <script>print_doc("pop_results", "centrimo", "centrimo-results-tsv");</script>
      <script>print_doc("pop_results", "shared", "motif-consensus");</script>
      <div style="float:right; bottom:0px;">[
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_sites">
      <script>print_doc("pop_sites", "centrimo", "centrimo-sites-txt");</script>
      <div style="float:right; bottom:0px;">[
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" style="width:400px" id="pop_prob_graph">
      <p>Each "motif probability curve" shows the (estimated) probability of the
      <b>best</b> match to a given motif occurring at a given position in the
      input sequences.  This estimated probability is based only on sequences that
      contain at least one match with <span id="ins_pop_prob_graph2"></span> <span id="ins_pop_prob_graph1"></span>
      than the <span id="ins_pop_prob_graph3"></span> threshold defined for this motif, 
      and is the maximum likelihood estimate of the conditional probability shown below.</p>
      <p>Points (X,Y) on the plot are:<br>
      &nbsp;&nbsp;Y = Pr(best match occurs at position X | sequence contains a match)</p>
      <p><b>Note:</b> The plots are smoothed according to the function 
      selected from the "Smoothing" menu on the right. Setting the smoothing
      window size to 1 turns off smoothing.</p>
      <p>If a negative dataset has been supplied then two curves are drawn for
      each motif, one for each dataset. The distribution of the motif in the
      primary dataset is plotted with a single unbroken curve, whereas the distribution in
      the negative dataset is plotted with a dashed curve.</p>
      <script>
	$("ins_pop_prob_graph1").innerHTML = (data['options']['use_pvalues']) ? "below" : "above";
	$("ins_pop_prob_graph2").innerHTML = (data['options']['use_pvalues']) ? "adjusted motif <i>p</i>-value" : "score";
	$("ins_pop_prob_graph3").innerHTML = (data['options']['use_pvalues']) ? "<i>p</i>-value" : "score";
      </script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_plotting">
      <p>This shows a listing of all motifs currently plotted on the graph.</p>
      <p>The color used to plot a motif can be changed by clicking on the
      color swatch next to the motif you want to change, followed by clicking
      on the color swatch you wish to swap it with.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_unused_colours">
      <p>These are extra colors you may use for plotting motifs.</p>  
      <p>Click on the color swatch next to one of the above motifs, then click 
      on one of these "unused color" swatches to change the color of the 
      motif's plot.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" style="width: 500px" id="pop_graph">
      <p>These options change the display of the graph.</p>
      <dl>
        <dt>Smoothing:</dt>
        <dd><p>Allows selection of the smoothing function applied to the graph.</p>
        <p>The weighted moving average option uses weights shaped as an isosceles 
        triangle where the central point (or points in an even sized window) 
        get the maximum weight.</p>
        <p>The moving average simply weights all points in the smoothing window 
        equally.</p> 
        <p><b>Note:</b> Setting the smoothing window size to 1 turns off 
        smoothing.</dd></p>
        <dt>Window</dt>
        <dd><p>The window size used to smooth the graph. The larger the smoothing
        window size, the smoother the graph, at the cost of hiding detail.</p> 
        <p>Below a smoothing window size of 10, thinner lines are used on the 
        graph to allow more detail to be visible.</p>
        <p><b>Note:</b> Remember to press "return" or "enter" after changing 
        the number in the input box in order to see the effect of the new 
        smoothing window size.</p></dd>
        <dt>Legend</dt>
        <dd><p>Choose to display/disable the on-graph legend. The legend can be 
        moved by clicking on the graph.</p></dd>
        <dt>Negative Sequences</dt>
        <dd><p>Choose whether to plot the motif probability curve(s) for the
        negative sequences (if provided). The curve(s) are plotted as dashed
        lines, using the same color as the corresponding curve for the positive
        sequences.</p></dd>
        <dt>Zoom</dt>
        <dd>Drag a range on the graph to zoom into that section. Clicking
        "Undo Zoom" will return the view to the previously displayed part of the
        graph and clicking "Center on 0" will move the view so 0 is in the
        center.</dd>
        <dt>Download EPS</dt>
        <dd><p>Download the graph that you are currently viewing as an 
        encapsulated postscript (EPS) image. EPS images are scalable making them
        suitable for publication.</p></dd>
      </dl>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_filtering">
      <p>List only enriched motifs that meet the selected filter criteria below.</p>
      <p><b>Selected motifs are always listed</b>; deselect all motifs first by clicking on
      the "X" above the color swatches if you wish to filter all motifs.</p>
      <p>To filter on "ID" or "Name", you can enter any Javascript regular
      expression pattern.  See <a href="http://www.w3schools.com/jsref/jsref_obj_regexp.asp">here</a>
      for documentation on Javascript regular expression patterns.</p>
      <div style="float:right; bottom:0px;">[
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_sorting">
      <p>Sorting is applied after filtering where possible (the exception being
      the "Top" filter) so the filters applied will affect the sort.  You can
      choose the motif sorting feature using the "Motifs:" menu.</p> 
      <p>If CentriMo is searching for locally enriched regions (not just centrally
      enriched regions), then multiple regions may be found per motif, and
      the "Regions:" menu will also be displayed.  In this case, 
      CentriMo first sorts all regions using the feature
      shown in the "Regions:" menu, and then it sorts the highest-ranked
      region of each motif according to the feature shown in the "Motifs:" menu.
      </p>
      <p>
      Unless you check the box next to the "Regions:" menu, it will automatically 
      show the same feature as the "Motifs:"
      menu (or "<i>E</i>-value" if a motif-only feature is chosen in the "Motifs:" menu). 
      </p>
      <p>
      <b>Note:</b>The motif <i>p</i>-value shown in the plot legend will always be for
      the region with the lowest <i>p</i>-value, and therefore may not match the value
      shown in the table "<i>p</i>-value" column 
      when the "Regions:" menu is not set to "<i>p</i>-value".
      </p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_db">
      <script>print_doc_para('pop_db', 'shared', 'motif-db', 'motif.');</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_id">
      <script>
        var html2 = '<p>If more than one motif has the same ID, CentriMo uses only the first such motif.</p>';
        print_doc_para('pop_id', 'shared', 'motif-id');
        document.getElementById('pop_id').insertAdjacentHTML('beforeend', html2);
      </script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_name">
      <script>print_doc_para('pop_name', 'shared', 'motif-alt-id');</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_consensus">
      <script>print_doc("pop_consensus", 'shared', "motif-consensus");</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_fisherpv">
      <p>The expected number motifs that would have least one 
        region as <b>comparatively</b> enriched for 
        best matches to the motif as the reported region in the
        <b>positive</b> sequences compared with the <b>negative</b>
        sequences.  
      </p>
      <p>
        The Fisher <i>E</i>-value is the (one-sided) <i>p</i>-value of 
	the one-sided Fisher's exact test that <b>at least</b> as many best matches 
	in the region in the positive sequences that contain at least 
	one match, multiplied by the number of motifs in the input database(s).
        The Fisher's exact test <i>p</i>-value is corrected for the number
	of regions and score thresholds tested ("Multiple Tests").
      </p>
      <p>
        Fisher's exact test assumes that the probability that the best match 
	(if any) falls into a given region is the same for all 
	positive and negative sequences.
      </p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_pvalue">
      <script>print_doc_para("pop_pvalue", "centrimo", "centrimo-adj-pvalue", "<p>The enrichment <i>p</i>-value of a motif is <span id='ins_pop_pvalue'></span></p>");</script>
      <script>
        if (data['options']['disc']) {
	  $("ins_pop_pvalue").innerHTML = 'calculated using Fisher\'s exact test on the enrichment of best matches in the positive sequences ("Region Matches") relative to the negative sequences ("Negative Region Matches"), corrected for the number of regions and score thresholds tested ("Multiple Tests").  The test assumes that the probability that the best match (if any) falls into a given region is the same for all positive and negative sequences.';
        } else if (data['options']['cd']) {
	  $("ins_pop_pvalue").innerHTML = 'the probability that the optimal average distance between the best site and the sequence center would be as low or lower than observed, computed using the cumulative Bates distribution.';
        } else {
 	  $("ins_pop_pvalue").innerHTML = 'calculated by using the one-tailed binomial test on the number of sequences with a match to the motif ("Sequence Matches") that have their best match in the reported region ("Region Matches"), corrected for the number of regions and score thresholds tested ("Multiple Tests").  The test assumes that the probability that the best match in a sequence falls in the region is the region width divided by the number of places a motif can align in the sequence (sequence length minus motif width plus 1).';
        }
      </script>

      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_evalue">
      <script>print_doc_para("pop_evalue", "centrimo", "centrimo-evalue", "<span id='ins_pop_evalue'></span>");</script>
      <script>
	$("ins_pop_evalue").innerHTML = (data['options']['cd'] ?
		"optimal average distance to the sequence center as low as observed."
		: "at least one region as enriched for best matches to the motif as the reported region.");
      </script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_MCC">
      <p>The Matthew's Correlation Coefficient (MCC) gives a measure of the ability
      of the motif to discriminate the positive sequences from the negative sequences:
      <dl>
        <dt> MCC = [TP*TN - FP*FN] / [(TP + FP) * (TP + FN) * (TN + FP) * (TN + FN)]</dt>
      </dl>
      where 
      <dl>
        <dd>TP is the number of positive sequences with a best match in the reported region,</dd>
        <dd>FP is the number of negative sequences with a best match in the reported region,</dd>
        <dd>TN is the number of negative sequences without a best match in the reported region, and</dd>
        <dd>FN is the number of positive sequences without a best match in the reported region.</dd>
      </dl>
      <p>MCC ranges from -1 to +1, where a +1 result indicates that the occurrence
      of the best match to the motif in the reported region perfectly discriminates positive
      sequences from negative sequences.
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_binw">
      <script>print_doc_para("pop_binw", "centrimo", "centrimo-bin-width");</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_bin_sites">
      <script>print_doc_para("pop_bin_sites", "centrimo", "centrimo-sites-in-bin", "<span id='ins_bin_sites'></span>");</script>
      <script>
	$("ins_bin_sites").innerHTML = (data['options']['cd']) ? "is anywhere in the sequence." : "is in the reported region.";
      </script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_neg_bin_sites">
      <p>The number of <b>negative</b> sequences where the <b>best</b> match to
      the motif falls in the reported region. This value is rounded but the
      underlying value may contain fractional counts.</p>
      <p><b>Note:</b> This number may be less than the number of <b>negative</b>
      have a best match in the region. The reason for this is that a sequence may
      have many matches that score equally best. If <i>n</i> matches have the
      best score in a sequence, 1/<i>n</i> is added to the appropriate bin
      for each match.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_total_sites">
      <p>The number of sequences containing a match to the motif 
      <b><span id="ins_pop_total_sites1"></span></b> the <span id="ins_pop_total_sites2"></span>
      threshold ("Score Threshold").</p>
      <script>
	$("ins_pop_total_sites1").innerHTML = (data['options']['use_pvalues']) ? "below" : "above";
	$("ins_pop_total_sites2").innerHTML = (data['options']['use_pvalues']) ? "<i>p</i>-value" : "score";
      </script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_score">
      <p>This is the <span id="ins_pop_score1"></span> threshold 
        (<span id="ins_pop_score2"></span>)
        for determining if a sequence contains a match to this motif.</p>  
      <script>
	$("ins_pop_score1").innerHTML = (data['options']['use_pvalues']) ? "<i>p</i>-value" : "score";
	$("ins_pop_score2").innerHTML = (data['options']['use_pvalues']) ? "adjusted motif <i>p</i>-value" : "bits";
      </script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_neg_total_sites">
      <p>The number of <b>negative</b> sequences containing a match to the motif
      above the score threshold. When score optimization is enabled the
      score threshold may be raised higher than the minimum.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_negative_binomial">
      <p>The probability that any tested region in the <b>negative</b>
      sequences would be as enriched for best matches to this motif according
      to the Binomial test.</p> 
      <p>Use the filter to display only motifs differentially enriched in both
      datasets (low <i>p</i>-value and high negative <i>p</i>-value).</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_prob">
      <p>The maximum probability that the best match occurs at any single sequence position.
      If the smoothing window size ("Window:", to right of graph) is set to "1", then this is value is
      the maximum value of the match-probability curve.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_concentration">
      <p><b>Concentration</b> is defined as the total probability of all the positions in the central
	region whose width is the same as the size of the "smoothing window".
	You can change the size of the smoothing window using the "Window:" 
	input field in the <b>Graph</b> options section, above.
        (A value of "NaN" indicates that the smoothing window size is too
        large for the motif.)</p>
      <p>The "concentration" of the motif sites in the central window
	can somtimes be more informative than the <i>E</i>-value.  For example,
	in some ChIP-seq datasets, motifs for cofactors show more significant
	enrichment overall (smaller <i>E</i>-value), but are less
	concentrated in a small (20 to 50bp) window than the motif for
	the ChIP-ed transcription factor.  In such cases, you may wish
	to sort the motifs by Concentration, using the <b>Sort</b>
	menu, below.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_nbinstested">
      <script>print_doc_para("pop_nbinstested", "centrimo", "centrimo-mult-tests");</script>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_bin_location">
      <p>Location of the center of the most enriched region.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_SMmotifs">
      <p>The text box lists the sequence identifiers for sequences that 
      <span id="ins_pop_SMmotifs"></span> <b>all</b> the
      selected motifs.
      <script>
	$("ins_pop_SMmotifs").innerHTML = (data['options']['cd']) 
          ? "contain a match to" 
          : "have at least one of their best matches in the most significant region of";
      </script>
      <p>The "Intersection" subheading gives the number of identifiers in the
      text box and their percentage out of the total number of input sequences.</p>
      <p>The "Union" subheading lists the number and percentage of
      sequences that have at least one of their best matches in the most
      significant region of <b>any</b> of the selected motifs and their 
      percentage out of the total number of input sequences.</p>
      <p>Note that the number of sequences with a match to a given motif in
      its best region may be larger than the value of "Region Matches". This is because
      a sequence may have multiple equally best matches and in that case a
      fractional match count is assigned to each of them when "Region Matches" is computed.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_OEbins">
      <p>When more than one significant, non-overlapping region is found,
      they can be shown (and hidden again) by clicking the arrow.</p>
      <p>By default the regions are sorted by <i>E</i>-value, but this can be
      changed by the menu on the right of the page.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <div class="pop_content" id="pop_problocation">
      <p>Sequence position where the (unsmoothed) match-probability curve for this motif 
      attains its maximum.  Set the smoothing window size ("Window:", to right of graph) to
      "1" to see the unsmoothed match probability curve.</p>
      <div style="float:right; bottom:0px;">[ 
        <a href="javascript:help_popup()">close</a> ]</div>
    </div>
    <!-- Page starts here -->
    <div id="top" class="pad1">
      <div class="prog_logo big">
        <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A/wD/oL2nkwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wLGwYsOTtZCG8AAAA8dEVYdENvbW1lbnQAIEltYWdlIGdlbmVyYXRlZCBieSBHUEwgR2hvc3RzY3JpcHQgKGRldmljZT1wbm1yYXcpCgcnzvAAACAASURBVHja7Z13YBVVvsc/M3P7vSk3BVJIQiihN0MVUDpSFBAFsXcEy/pW1HXbs6xrWZ9dV11FBSuKCNK7CSUJoQYIJKT3kH57mZn3R9wgG1TePnUp8/nrkjNzuHPO9/7O+f3OOb8BDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDY0LBwGYoTXDRYkE5AmAqrXFRctrun9+qnZUXxRPbPs2A+v0mahhoQguN4FxY2j64C2UENtF0+sxITH//OgXLzbJq4cOosTE0Lzic3x/fAxd9j7CHnviojUBuovtgS2HjqLExRBI6YpvyCBCDXrMz/yN0IR4Wh59UBPABT/rPZqLGtsRzGYAWhbegZhzGNNfngWzmZYH5l9U7XFRDQECAkJeHnKneBSD/ru5sITjlb/hHz8W01+exX7zfPRllZoALkRM1XWoXi9K56TT/i6bjTR99QmeJ/+MYd0GwqdejTn7gCaAC46DB0CSkLt0PkNLCDjuuY2WbevB6cQ2Yw7mzds1AVxIGA4cBp2OQJekH7zG07cn7k1rICwU263zMezZrwngQkGfcwTVoEfo0vVHr3N1S6L+2w2oOh2Wt96FYFATwAXB4cOodjt+i/EnL1WiIghMnoBYUQmKqgngvP/1O90IzS0IPXqc3Q2qCp3i0bu9oCpaHOC8p6oK1etBGZx6lj6jgBofj1pdDYqiWYDzXumFJUg+P57+vc5aAP6YaITGRjAaNQGc70ilZSDLCH36nvU9SlgoCAKWonJNAOc7QkUFqiThTu509jeZLaghIQhHczUBnNe/fn8QQ85R6N///3SfGmJFlWUoLdUEcF7+6hGwffAJ4eOnIW3cjNK79//pfjnEhmoPR19UonkB5yNhL7+J4c9PooaF4X/rTZrmzfy/VWBrFYCxtEITwHlpATKzEEwmasuO/XsVWK0QEoJaVKQNAefduN/UjFhcijpp0r9dhyJAMCoCios1AZx3pq28CqmxCffll/6/6lHjO4HXi9EvawI4r6goh9palIkT/n/1dOgAgoCQl68J4LxBUTHk5EJiIu7O8e2K606KNDVKZ+cJxH23g7aiQhPAeYMcRJ++i0D3LhA83XR7PAKP3BfJhtWWs6oqkBCHKghIpeWaAM6b2X9QRneiAOXSESCd/og1FQZkWUT26VHPZpU3Ng5BkjBeoPsEL0gBGCtroLoaT+oAEITTylwugSum+SgqUThZrf/pSWBsDKooIlyg0cALUwDrN0NoKGrHju2nB0EdtjA/kZHwzfKfPg0UkECwWS/YWMAFKQDTtjSCneJROnZoV5a+XU/QL3HNdV4qKqG08Cx2ByUlITU2oUPSBHCuo/cFULduRe3RnWB4GHJQIBA4VV5braNzdw9Gi59x41Ty83+6CcROCaheL9TXaQI417E98DAEAnhuv56KSj2vvxBGwXETAJXlOgYNDtCtG4SEKlSUK8g+Iyerfzwi7kvpAl4v+HwYyqswf7lSE8A5afrTMzB89TXBeXPwXnopW1ZbSP/WiNP5XbkJfP4gDmfr9H/srHryD+rJ2Wf5UY/A370rkttD2KI/EnbFDGwPPYZO1GkCOKdcP7cb82t/R7VaaXnzZfJyTbhcCjfdpLBto5VgQGD3Dj15R83ExysU6gqYFT8G9x1vU17vY/OaH54QCsnJ4PMhrV6DUN8AHg9i/glNAOcS5uwDGHbuxvniswR1IscO6+nWXWHSzHoMBijKN3HssIVOyT42GVax0HgvC4IL2J7yNrV9t1JcYGTLevOZXcHkzsijR+LctBbP6y+B14tYUHhBtNsFsxxsXPYlckQknkmjqTspIcsiyd1dmC0K/foHKSoUSUkOUtX/W57Xv8hDwd8x0jcSxaxwYtRaEvPGYzQJeL0CJtPp44G3QwTeVV+h6lRM0bFYVDDk5uGdNE6zAOcKWfvCmB94kxVfR7Pi40jKysAe0dqRktGLKBtxRlazVPcR98sPMMY3Bhs2+gb74hIceGNKqCgTQBXaWwBRZKt5K0f0R0jrcZLN41XI1YaAc4ajh60szenJlKFVOINmevZ14mhRiYpuXQfo1SdIdrbMn9ZlMioyha7Bbhhp9f97BnpSL7dQMvk9jmVbyT3cGh1UVdi4KozHng3wpO45Xje+zkf6j3ja8DivPGbG66xE9Po1AfwnkBDaZuFHc6xsfa+B+8RPuWKqgRtvqyNkUia3/qm47frwUIVyXxNGVySDE8PpHezXVmbBwj3yAgp0RxBG7aH4kAk5CLJPz0dZBexw7yNtrY2Xvc+w0LOQhf75NHWNZNm4WoT65vZBIwWKThg0Afxine/2EHrNjYRPmI4MrF6vY5qcRqB3BgtnL+N18z+41XwTu8O30iA0AFBiLaDsjwuZ/1ALs71z29XZP9CPErUC57CtrDdsBsXElFXvUx6zl2FjXdxdvwh/Tl8S1AQmByYxUBqM33ESt9LYrq5VX1p57y2zJoCfiz+Z/8QH5g9w4kRGQVdQhO7gIYTdmWz7u4/OyUHqRnzNvW+35rtrFppZJC9isbiY983vc0I6wfPWZxgU04G7el1yxv/DolpI9+wgOgoqLEV0qx6Pf28/bruiA08NGk+oTeDggVMh43GmmfxjdgPVupPt6qqsEHC0SPi8p5pWQSFIEPUczMh3TnsBx3THyJfyyVAz2G3bTX95EDef0BHe2EQpCWzd2kT0u5tZVv4NY04kce/Av6N3tcbre+l78Zn+M24038gUeQoLvAsw88O/zKASZJF0O6GNejq8O4ERE3zMDk3EHB4gKgoOlonsyzLRp7+PS02TmbAplNWzMriXkQQIEhT8GHw29mWY6N8fHPUSUic/aVIa5bpysoVsbgneQrKcTIQScXEK4NB+A+HhKonJgZ+8VkHhPcN7DFBSucl3A4XiCT40fEhyoInkSCNvVC4kNOU9DsS3cP+iAFe7+1E/49RiTWogFb/qx2PwsMC7gA5qh58OJhkgPsKAuLEnMf2dWDq4ARg8wk1NjYUd28xIokhdrQ9f4UJ2vdCdkiF76XZdOsVCMfKH99F7UiIOWz07mv2s6f4UkUIUBsVAuBrOK4ZXMGPm4cDDdPN3Q0VFQPhpF7egGH9UBGpY6PktgG2bjDQ0wBPP/rQAsvXZWAQryWsOk9RFT6fEy2gQ6nk7eQEV8X+hZ3wN7ybt5LIsC1evEAn8sf2p3+HB4aQGUzFwlpMyAUZd7iPnoJ4hw07vmGkz3eQfC/LZUjNGQSSpLIz3Zn5K46E7MQ2OoigqHzXsKJkRX9LSIrC/Io4OQw084H2A2GAsKirlunLWGNcwWz+bDcIGYnwxP/mVLLVNhAwcjvcvT9D8wN3t9jec8wKQkZGQKC/VceSQkSumygguJ2J5FUpiAqrZ1N4cC0FW6FZwkMO89VQstXM203L99YyouYoty4s5On8A+XVViLM/4v5Prkfn24ErdeAZ+lM4+87/p8cQGeSxJ5rOWNa9p5/f/VlGb5Tx/b6aPl/m0HD3CKq/uoKHrrqd9X7oFyGzNXInwRWTeXDiTad9l8RgItOUaYgmkZm6mSxWF9Pb3/60kqpCY50evyDTNWMnKiDu2An33AJG0/k1CdyhS+cV9W12rzczbFiQA7kC0hNvEXX5ZAy7sk5/8ICH/boDvG98nxNSAYsrnufbrAYWvyjw0WILmZ+5SFlTzr6kN9n7yF957P5G4t5aCagoQwb/KlZMb2yNLYQPSGbaqnJi9UbscQLLV4dwsthGnz4K8xNHEFQkdm5tb7ITlUSu9V7LLfItPKd/jlyp/cFTQYC/v2rjzVciOLKsCAEwHMulIq+1/Gw3tP5HBZCbY6JJamKN4ROWfiyxOPlvdBlWS4cYhcyl5eByYyg4yqovjGxZG8KKbc2MDZ3CBuNasqQsLlFSCb52jKXMI7pyN3ODq5lt/JSH2E94r0PEKV2ZWtQPtbQYtUsX/Cb9rzmaocbEgM3GpQ0bKGswsDlNZNgoDyoqepvKhMkBMjMkREGkuFBH7hEJv6+14yKUCOb55mHCxCbDprY6C6VC7jHfxhcfRBLbUeXycR4ycmOQkXAUN+I8VMfVUyOpqzYi/0zHFCTgcYBFv1/087WOIjFqsB2/tZl1H3VioLEHoaKNzbPvxVdWimuDlR7xu3E3dMA/aTrr19nIi1pPy+PhjO14GffF3sw49xW8fFMp13XYzpQ+lcSufhdzcxNSbEdCb7yXm5TbCT1ahn7vPoTLLsN19ZW/qgAEjxfDmvUY31tM0oaldIwIMO7WaGSLEUSRpiaRELOO99+y4mwMIPgMLFtmpaTAQLhdpWO4ngQlgcWG9+ikJqEPGHjb/DY7duo4khbFbxdKOBpshL36Eo6ufZHjE/hkezJTHu3Gjm16EpIUwuz/ngpeeOaFf37c/YsIIHu3mRkzg7ynLuG6a1VKX7+SxX81Y1Pt+N44wcqZFey8009pwEzx8ZsZen8223UbuHzLEfh8GEXmS9ixTqHH5rcZMzcE7rsJw/sfIZSWEpg2gbiJd2PFht7pQv/1N7hvnod/2OBfVQCKPQxlyGDUrl2xW730P/EV5udfxphXAKqC7vgxXOv3EJq5hXFrf0/IltX0uXMw2ZXR1FWKREVCj9BoGur0PLFzO3szLaS/l8KEyhvQz1rD9h5LuCJa4t3lNuqGdGK/5zIqx+3nnoXdKGxwUXciioQuXgz/sqPNjx/pJ7aufV8Abe8LePVNN3Nuavn/m0YFDuwI4cGMlQx9YgUPehfRKdgFVZCRvD5KLn+Qj53TCV/SzMY3jyCPGkfCfcuIXbaNP92g4BfspP1pFcETlUxeegvGla/jGTeGqCvnIuzYieud13Ff23rKVzpZT8iKNTinTSQYH/sf86UFBKSiEszb0jF/8BGUlSGIAogqamISvpHDMX2wFDnSTsub77LCPRx3vY6YWD+NTUH+enwVl4xv4KqmG7hiLOQ6K3i1w5NUCw70HxaT9s3nXNOUzaplC5kUOpnwQCLeRU9y5ywT5VUSU2e4ECVIM6SRKWTyW99vf1QE30sX/z9tAnjjbQcDLgnQrefZLXB89ZmVcZP8mEwKJsspU9TshFufKabPwm9J6ubmLs+CU/7s7izCrpnLopR16Hr2ZGfNF/jfeB9dbICls90k+uLRpaXju/NOxOoq9Bs2Ut9QgazKmIsrsA0cStO+XacSPf5zG8/P7Br9++pXIRD4LqnUd99JFMGgR19YQsTEK1sbe9JEXq+eTXWtgP2OSaTctIOBxl4YldM9FvNLL2F46jnq0jKQKiux3ziHPa/dwNI7bGwpy2H8+ucZG5PCsrdsTHhzLU8l3c0oZTTPu5/HivW0upqkJp4y/DdxB6bzt8Ft3sn/tLmB+yx7qG0QCJGiiJDDKc61UVWhZ/R4Z1v7+pQgLn+AwsM2tmXIHM6xMnKEyvE8gWkzXIQmFPHi6t1Iccm4u+3nLs/Lp/ucWXsRvH6mP96TpR9KPLz5EOVf1LHnpu50TT+A88MnkDp3xrRkCaqqol51JbLaKi5P53j0f3iUYJfOtL3k5Fzp+O9P3w1ndjsDXZJo2LaOsNk3wKZN3Cutw18voyzugWfUqwRT2t9nOngcnSxiGdAdtWsMeoOFEZ9WET93Kclx/+CrO++m6vBUDPN78O6OWq5OmM02cRt7TbsoeHE2o8f4iepdzXLzcg5KB8hUM0mo6X/mOIDX3MDnNUfZGdjPDPMoWtb8hp17BAYMdhMWrtCktrC9Lp8lSyQUXQDTb9ZjcvRBFcYyREzk7xtryFV3UetQeHCWibmel0+LdAkuF8aNWwmOHIm9l55uqRYi9rQw47MYmgYtBPPd+Pv1xj+gH/ZvViM0NNBy582nfVnHw785J+PpZ0sgMZ7G9A0ITlerS7nvALb/egTz5Om4nvgjrpuv+557JiAUFCKkpBCQA2A2IfTqDQf3Eerycjt30kvXh419VrOqvI4Rzmu48dBdjOy3jE8PltCyQ6HM56B+yJ8JF+z0Dw7ggfJn+a+N1Wd2Ax8eOowrch5hiDKYJV8KHI/JYPoUH888FoEiuniy6mOefjHAkF4W7rnXy+xePdh36WtsH/4Cn8y4hxXDniU0ez/zPrEyTe7YNja24Xajz9pD4Pp5REcGmDu/hYGjTKhHsgn94DMCnRMI2qwEOkQSmHoFxMbiG3r64o16AbzeSDYZCUZFEIyKwDNpHE0Z30JiIpann0f/vUwkQkUlYn0DwZHDTzXhnbcg1ddjXLkKgBHBETzs+QPLx9xKbO5EasolbEdHUVgaILqThxOG45TmWVjgWsAdnrvY+UUCd13S58wC6BCqp3t3mcaHH8ZbFca+zl9xdOprSPO+IvmBnWz6OJprh8fyu4m9uUI/mmu9c9ji3EaFUEm9oYnHK/fz6hcZPFG4gI7Hs9o9uG3rTrBYcA8ZiE4Cm05FN6h369HrZV+gjhgOoaGg0+GeOQ153BhU6cI7iNHOKoRYcbz1CmJVFebPl5/yz2tqERsa8Q44tXfBNXcWakICpi+/RnS521YyO8vduHV+A8s+DqHy2+5E7ZvI5892o653Ov2+/gN2TwzLPwlBb1QZPkI5swBECS5PrUPK3Ml/p8zlkpFumrvsparbDuYOS+bJrtfzyMwkBMPpiZMXO99nQc2VPLCglJQUH8LYkVjeeb/9gsY77xHs2welQ3Tb37yDB4IkgdGI95IBqGKrxQgMHYxj0W/OvTH+F8LTqzvyvHmY/v4PpNq6NgEgy6gjT09w4Xzij+j2HUB//PQtafEJMtOudpCbp7JwdjxxoUam945gkD2OPz8agSCJjJjspEOs/4cjgXEFO3mleh6p4h4eEe7nLvd9vBA/n+dm92LW1f4fWj9h4gd1iE3NeN54Hfc1MxH27sNYXnUqfNrYgnjwEIHhQ057O5c8oH/rrNlkItivz2k+tq9b54tGAEDrq2ocDqzvLW3tmPoGBJ0Ob9fTU9v7JoxBtVoJff2ddnVMnOLhnodbGBus49kba3n0nk+RdmWRUyQxLTaTAV+9jCn74A8sBgWDWLZtRzpZTdJ9t1OXk0mUEolO1BE5ajTuBXfhuO369rHkhkbMy5ahjh+Pc/glGEKsYDRifuMdfM/8d6uZ+nw5KAqBy0edPh5KAq5nn0INBpB797ygkzL/FP6e3fFdOwvzcy9gWrEKtbISevVC/Zfj7XJ4KL47bsH0xNPonnmcYMeo08qj7Cqhtz3CDVtAiDjODZun0FMYSmLaTlAU5Icf/IEhwOFEt3I1crduCEVFWF98HQD7xKsgNxfzQ48S/sifEevqT/dVt6Yj5uXjfPg3rQ/SpwfBgf0xvL8EndCqL/0HS1FjY/CPap+vx7XwTtwPLEC5iDu/1eaLeG69kcDgSwjqROROcXh/ILrpmTIBwsMI+c3D7crMOzMR0nYQvOsOakpyke65keHDnAT+6wGCvXpgKyg9swUwZh9AdLtp/vJjbIt+j/HNt9FnZSPu2oXrb38FfwDr088RsWMXjrdexde/N8aCYqz3Pkhg/Fjcg08tx/pvuA7dtm8Jvete/JMnIOTlE7x+LrKIxo9ZgaGpNGz+5qcnjr164L9qOsYPlmLO3ItnWOteCMHnx7h4CWJ0NA1P/aE1APS3v7TdZ6+oQN2V2W4IVwGCl41G9XpoXPEpereX8MGjUJubkZ96gvoH54OqYjici/3Ka1GNRlxffIzltrtRT56kees6At2ST6s48vHn0L31DorXiyDLONM24x7UV+vlnwmd20tEcm/ky0bRuGwJigCGvELsQ0bhfe1lmm+e094Te/wZrK+8gXDqDSj/c2oISEvHN34MSmgIvphoPA8sRLlyOvX339kW5fL3601D2kYArCPHIuTl4/nL4+06H6D+8UdpPH6QwNxrELp21Tr/ZyZoMeF/dBG6jCz06bvQF5YQftd9qD174ph25sxoQlJSq9d1Jgsg22y0bF6Dr0/rGzVEtwdBVpBDrO0qMhw5RvjsG5CHD6Xhg7d+MkCjb3YSCLNpvfZzTxuCClEDhiPbw5Hy8pE7RON66Tk8E8ee8XrL1nSs825BcrvbrwUIyZ3bOh9AsfzwDlp/n540fv0pcmLCWUXntM7/haKKOhH3ow9hfuC3BOfOoelPDyN3ivvRULRq0IP7DBagvjSPgD1Ua9XzzQrU1qEvLcc7sC/ofnyLpz4gE5YyAF1dXXsLoHX+eWoFOkQhd4g6q2sDegk1PAxOCQDNMbvIEPr1O3MgSOMi8R5SumkCuJjx9eutCeBiRu2jCeDitgDJiZoALmoL8C+ri5oALnI0AWgC0NAEoKEJQEMTwK+Kx+OhqrKK5sZm1q9eT0Z6Bk0NTWxYvYGKsgr8Pj8b126kuKCY+pP1bFi9AUeLg/qT9axbtQ6P23PGeutP1rNp3SYEBERBZNPaTdT/yza2qsoqcg/nosoqu9J2AVBe/OPvBDqQfYCW5hYydmRQmHfmNLGCKrDum3U0NTRRW1MLwJGcIzTUN5C1O4uc/TnnnAD+Y0mimuqbWPXFKm6/73aGXTqM2upa1q9az3W3XkdxQTEbvtnAtKunsS9rHy0NLUycOpHtm7Zjs9mYPH0y+zL2MWjYILJ2ZiEKIsNGDwNgd9pups+eTnZWNo4WBxOnTmT9yvWYrCa6dO1CXEIc1RXV1NXUUV5STr+B/cjYkcHK5St55qVnqK2qpbKykpiYGFxOF117dAWgIK+AohNFjJkwhqyMLLqkdGHrxq04WhzMuGYGAEdzjpI6OJXCvEKWf76cp196msqSSvSSnrUr13LH/Dvant+6ah3qWb6V3P27315YAlBVldwjuZSXl1NbWYstzIaiKIRHhHMg+wB5x/KIT4gnNyeXDas3MOeGOTTUNWAxWdAb9aRvSae6uprO3Ttjtpg5cugIiqJQXV2NoAosfWcp8cnx9O3XlyVvL6HwRCFxCXHU1dYRciQEi8UCIugkHau+WsWU6VMYMWoEABXlFeTn5rNpzSYGpA4g/dt0xk4YS+buTCZNncT6b9azf+9+Jk+fTDAQxOVykXs4l11pu5g1ZxY5B3MoPF6IyWIiOyObupo6GhsamXXtLDJ2ZJCQnACAZdsO+OqrHzxL+GsJoG0/QLWj+lcVQUVpBfEJ8ZQUl5CUnERjQyNetxeH04HJaCIkJIT6+noUWSEiKoKa6hr0ej2hYaG4HC4UFEJCQyjMKyQyKhJ7hB2vz4vJYKKhsYG4TnEoQYXqqmpCw0LxeDyEhoYSHRNNTVUNzY3NhIaH4mhxEBsfS211LZ0SO5GXm4fZYqa2ppbUoalUlFUQ3TGaksISOsZ2pLmpGVEUkSQJWZaRFZmo6Cjq6+oxGAz4vX6iO0bj9XrpENOBkoISwuxhVJZXEhIWQkJSqwB09Y3gcp3V2YdgQvzP2vbfPx7+q1mAuto60ramMW3WNDat3YTRaCTcHk7+sXzKS8sZedlIDhUfov8l/Sk4XsD2LduZNXcWJ46fYG/WXsZNHode3z4NTFlxGW6Xmx59elBcWMzRI0cZM3FMW3l4ZDiH9h/CarMSHRPN4UOHiYiIwOV2kdI7hZjvXgxp++7ASp/+fWhpaWH/3v306deHE/knSEhIIPdoLm6Pm9ShqYhi+6mT3+cnLCyMNavWMHTEUOTvcrjU1ddhNBsxGow01je2CSAYaYdI+8UzB9ixaQdXzrmS+tp6PG4PqUNT2bhmI4OHDEZn0pGRnsHuHbvp1bcXNRU1jJs8jvxj+Zw4doI+A/qgyApe2cuqL1Yxetxo7JF26mrrsNvtHDpwiEFDB2E2mqmprsHV7GL9mvVcNv4y7BF2SgpK6JrSlU8Xf4ov6GPwkMFUlVUxaPAgyovLKSwoxGwx069/P0xWE2UFZVx19VV8tuQzRl42kq2btjL1qqkU5hUiiiKfL/mcjnEdGTJ8CJJOoqW5hXWr19Gvbz8C3gAmo4lnH3+Wv77yV+qq6zAajGxev5nUwadS2S03LqdRbUREJJJIDnCAoQxlN7sZwhAqqMCMmTDCmOmfef4LQG/Sk3s4l4iICMpKyji07xDxneLZv28/zhYnOr2OpK5JrFmxhsjISLZv2o4kSQiCQGV5JRGREaio+Pw+9mfup76xnqioKFRZJSM9g/FXjKeosIigP0ja9jRqKmsoLiimoa6BQDDAyZqTmGwmSo6W4HA48Pq8NNQ30NTYRNrmNGwhNvQGPUdzjhIfH8/iNxczcsxIqiqrMFvN7Nm5h0HDBuFyupCDMik9U/h86efo9DqunXct/Qb0w2a10aVbF9atXEdcQhwFeQV4fV58fh82q42qylPH5UrFUqqEKiQk3LjZz37iiGMf+4ghhnzysWEjmmj4BZOS/2pzgObGZhwOBxGREQSCAcLCwtrcM1FoNan2SDulxaWEhYW1JohQ1dZO9/roENMBr8fLpnWbGD95PF6PF71ej6RrHYsFQSAYDKKqKmazGWeLk4joCPR6PSerT2I0GwkNC6W5qRmdXofX7cXv8+P3+7HZbHi8ntZ5hNeLs8VJaHgoer0el8tFZGQkLc0tREVHcXDvQeKT4rHarDQ3NiMIAhFREXi9XgQEHC0Owu3hyIqMxWLhZM1JbCE2fF4fKir2iFaz7xbcKCjf+eIifvwYMeLDhwEDMnKrK4uIRbX8YnOAX1QAjQ2NbFq7ialXTqWqqoqIqAjCwsPITM+kxdHC2PFj2bJpC1arldFjR7Nn9x6Gjx7O0ZyjHNp/iOtuvo4jB49QeKKQSdMnYTS2f8dfdmY2HqeH0eNHk388n+ITxUycNvG0a7J2ZREZHUlpUSlms7nt8/gp43/wux87coy4TnFsWL2B6TOms3vnbrr36E5C54T2Xo2iUlZSRqekTuQfz6djx46kb0tH0klYrVbiYuPIPZZLIBBg2lXTMFlM/9Fx//sC+GXSxH3Hzu07mXHNDMpKy8ja3eqvHz9ynJQez1wLzgAAAv1JREFUKcQlxJGdmU3Pnj0Jt4eTsz+H9G3ppA5JpaSghKGXDqXoRBFlJWWkDkvFZDIRCAZY9cUqTGYTsizjcXsw6UwcOXyEvgP7IqgCB/cepGPHjnyz/BvC7eGtnZlzDLPZTHh4OAf2HiAqMoqq0ip6DehFWVEZ6dvSqa6qxh5ux+V24ff5+ccb/2DCpAmEhISQeziXkuIS7HY7HWM78sn7n9DS3ILBYMDr9eLxeNiyYQs9e/bkjZffYMpVU7CYLZjNZqrLqhF1ImMnjqW8qJye/XoC8OE7ocgBicMHdez61srxowa8bj3794nsTrNRUqjD1WwiO1ugRy/5Z+2X72cJ+0XnABaLhQ1rNhCfGI/T4aSxsRF7uJ3jx45TUlxCYlIiWRlZ+L1+zBYzYyeN5ctPvqRTQie2btja1tHZGdmMmTAGFZXq6mryjuRxsu4kEREROFuciKJIWWkZzmYn5eXlHD18lOaGZpobW1225uZmbI02nA4ndSfrcLQ4aGxspLK8ktraWo7lHEOQBELDQjm07xBzbppD3/59cbvdpG1NI3VIKmu/WUvnLp05efIkgiDQuUtn1q5c2zYHSOmVgmSQGDR4EACZOzO55sZryPg2gxB7CCuXrWTC1AnfG3slQD4tICsAAiKCKiIgAiKq8ssekf9Fh4BgIIjX68VkMiErMjqdDkEQ8Lg9CGJrqFZRFARBQBRFjCYjTocTvV6PoiiIooiqqgSDQSxWC16vl+yMbC697FKCgWDbuC9KrX65qrReazQaCQQCGI1GREnE7XIjSRLBYOs9Or0ORVZwOVwEg0HCI8Lb7gsGgxhNRnxeH3q9Hq/Xi9FoxOvzYtQbKcwvpHP3zuh0Ovw+P4IgtN4nB1uv93gxmU1tz+1xe5B0EsFA6zOcapvWBGKq+l2yM6E1JKCq3/XId/9GBUn3yw0BujP8UUNbDNLQBKBxMWAVAJPWDhclAhDQmkFDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0ND4wLjfwE9VJhuBfJALAAAAABJRU5ErkJggg==" alt="CentriMo Logo">
        <h1>CentriMo</h1>
        <h2>Local Motif Enrichment Analysis</h2>
      </div>
      <p>
        For further information on how to interpret these results please access
        <a href="https://meme-suite.org/meme/doc/centrimo-output-format.html">https://meme-suite.org/meme/doc/centrimo-output-format.html</a>.</br>
        To get a copy of the MEME software please access 
        <a href="https://meme-suite.org">https://meme-suite.org</a>. 
      </p>
      <p id="citation"> <script>print_citation("citation", "CentriMo");</script> </p>
    </div>
    <!-- navigation -->
    <div class="pad2">
      <a class="jump" href="#graph_sec">Motif Probability Graph</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="#data_sec">Enriched Motifs</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="#inputs">Input Files</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="#info_sec">Program information</a>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="centrimo.tsv">Results in TSV Format</a>&nbsp;<span id="results_help"></span>
      &nbsp;&nbsp;|&nbsp;&nbsp;
      <a class="jump" href="site_counts.txt">Sequence position vs. number of matches for each motif</a>&nbsp;<span id="sites_help">
      <script>
        make_help_button($("results_help"), "pop_results");
        make_help_button($("sites_help"), "pop_sites");
      </script>
    </div>
    <!-- alert the user when their browser is not up to the task -->
    <noscript><h1 style="color:red">Javascript is required to view these results!</h1></noscript>
    <h1 id="html5_warning" style="color:red; display:none;">Your browser does not support canvas!</h1>
    <script>
      if (!window.HTMLCanvasElement) $("html5_warning").style.display = "block";
    </script>
    <!-- description -->
    <!-- write out the job description -->
    <span id="ins_desc"></span>
    <script>make_description($("ins_desc"), data.job_description);</script>
    <h2 class="mainh pad2">Results</h2>
    <div class="box">
      <div>
        <div style="float:left; width:70%">
          <h4 id="graph_sec">Motif Probability Graph 
            (<span id="ins_score2"></span>)&nbsp;
            <div class="help" onclick="help_popup(this, 'pop_prob_graph')"></div>
          </h4>
          <script>
            var compare1 = (data['options']['use_pvalues']) ? "motif <i>p</i>-value &le; " : "motif score &ge; ";
	    var score = (data['options']['optimize_score']) ? "optimal Score Threshold for given motif" : data['options']['score'];
            var compare2 = (data['options']['use_pvalues']) ? " &le; " : " &ge; ";
            var thresh = data['options']['score'];
            $("ins_score2").innerHTML = compare1 + score + (data['options']['optimize_score'] ? compare2 + thresh : "");
          </script>
          <div class="graph_box">
            <div id="pop_peak" class="pop_graph_peak"></div>
            <canvas id="graph" width="700" height="400"></canvas>
          </div>
        </div>
        <div class="graph_options_section">
          <h4 id="graph_sec">Options</h4>
          <h5>Plotting&nbsp;<div class="help" onclick="help_popup(this, 'pop_plotting')"></div></h5>
          <div style="max-height:200px; min-height:100px; overflow-y: auto;">
            <table class="graph_list" id="graph_list"><tbody></tbody></table>
          </div>
          <div id="unused_colours_section">
            <h5>Unused Colors&nbsp;<div class="help" onclick="help_popup(this, 'pop_unused_colours')"></div></h5>
            <span id="unused_colours"></span>
          </div>
          <h5>Graph&nbsp;<div class="help" onclick="help_popup(this, 'pop_graph')"></div></h5>
          <div>
            <label for="plot_type">Smoothing:</label>
            <!-- <select id="plot_type" onchange="recreate_table=true; make_MP_graph(); recreate_table=false">-->
            <select id="plot_type" onchange="make_MP_graph('smoothing');">
              <option value="0">Moving Average</option>
              <option value="1" selected>Weighted Moving Average</option>
            </select>
          </div>
          <div>
            <label for="windo">Window:</label>
            <input type="number" style="min-width:40px;" id="windo" 
            onkeypress="num_keys(event)"
            onchange="make_MP_graph('window'); get_central_probability(); make_CEM_table()" value="20" size="2" step="1" min="1">
            <!-- onchange="recreate_table=true; make_MP_graph(); recreate_table=false" value="20" size="2" step="1" min="1"> -->
          </div>
          <div>
            <label for="legend">Legend:</label>
            <select id="legend" onchange="make_MP_graph('legend')">
              <option value="0">Disabled</option>
              <option value="1" selected>Enabled (click on graph to move)</option>
            </select>
          </div>
          <div>
            <label for="plot_distance">X-axis:</label>
            <select id="plot_distance" onchange="make_MP_graph('x-axis')">
              <option value="0">Position of Best Site in Sequence</option>
              <option value="1">Distance of Best Site from Sequence Center</option>
            </select>
          </div>
          <div id="CB_show_plot_negative">
            <label for="plot_negative">Negative sequences:</label>
            <select id="plot_negative" onchange="make_MP_graph('plot-negative')">
              <option value="0">Not plotted</option>
              <option value="1" selected>Plotted as dashed line</option>
            </select>
          </div>
          <div>
            <label>Zoom:</label>
            <input type="button" id="zoom_out" value="Undo Zoom"/>
            <input type="button" id="zoom_center" value="Center on 0"/>
          </div>
          <div style="margin-top:10px;"> 
            <form id="eps_form" method="post" action="">
              <script>$("eps_form").action = site_url + "/utilities/save_generated_file";</script>
              <input type="hidden" name="name" value="centrimo.eps">
              <input type="hidden" name="mime_type" value="application/postscript">
              <input type="hidden" id="eps_content" name="content" value="">
              <input type="submit" onclick="download_eps()" value="Download EPS (for publication)">
            </form>
          </div>
        </div>
      </div>
      <div>
        <div style="float:left; width:70%">
          <h4 id="data_sec">Enriched motifs (<i>E</i>-value &le; 
            <span id="ins_ethresh"></span> using 
            <span id="ins_test"></span> )
          </h4>
          <script>
            $("ins_ethresh").innerHTML = data['options']["ethresh"];
            $("ins_test").innerHTML = (data['options']['cd'] ? "the cumulative Bates distribution" : ((data['options']['disc']) ? "Fisher's exact test" : "the binomial test"));
          </script>
          <table class="motifs hide_db hide_maxprob hide_tsites" id="motifs">
            <thead>
            <tr align="center">
              <th class="deselect" onclick="clear_selection()" 
                title="clear selection">&#x2612;</th>
              <th class="col_db">Database&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_db')"></div></th>
              <th class='col_id'>ID&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_id')"></div></th>
              <th class="col_name">Alt ID&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_name')"></div></th>
              <th class="col_consensus">Consensus&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_consensus')"></div></th>
              <th class="col_concentration">Concentration&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_concentration')"></div></th>
              <th class='col_evalue'><i>E</i>-value&nbsp;<div class="help" 
                    onclick="help_popup(this, 'pop_evalue')"></div></th>
              <th class='col_fisherpv'>Fisher <i>E</i>-value&nbsp;<div class="help" 
                    onclick="help_popup(this, 'pop_fisherpv')"></div></th>
              <th class="col_pvalue"><i>p</i>-value&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_pvalue')"></div></th>
              <th class="col_negative_binomial">Negative <i>p</i>-value&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_negative_binomial')"></div></th>
              <th class="col_MCC">MCC&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_MCC')"></div></th>
              <th class="col_blocation">Region Center&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_bin_location')"></div></th>
              <th class='col_bwidth'>Region Width&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_binw')"></div></th>
              <th class="col_bsites">Region Matches&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_bin_sites')"></div></th>
              <th class="col_tsites">Sequence Matches&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_total_sites')"></div></th>
              <th class="col_negbsites">Negative Region Matches&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_neg_bin_sites')"></div></th>
              <th class="col_negtsites">Negative Sequence Matches&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_neg_total_sites')"></div></th>
              <th class="col_maxprob">Max Probability&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_prob')"></div></th>
              <th class="col_problocation">Max Probability Location&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_problocation')"></div></th>
              <th class="col_nbinstested">Multiple Tests&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_nbinstested')"></div></th>
              <th class="col_score">Score Threshold&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_score')"></div></th>
              <th class="col_OEbins">Other Regions&nbsp;<div class="help" 
                  onclick="help_popup(this, 'pop_OEbins')"></div></th>
            </tr>
            </thead>
            <tbody>
            </tbody>
          </table>
        </div>
        <div style="float:right; width:30%">
          <div id="seq_area">
            <h4>Matching sequences (out of <span id="ins_seqN"></span>) 
              <div class="help" onclick="help_popup(this, 'pop_SMmotifs')"></div></h4>
            <script>$("ins_seqN").innerHTML = data['sequence_db']['count'];</script>
            <h5>Union: <span id="matching_union_number">0</span> sequences 
              (<span id="matching_union_percentage">0</span>%).</h5>
            <h5>Intersection: <span id="matching_intersection_number">0</span>
              sequences (<span id="matching_intersection_percentage">0</span>%).</h5>
                    <textarea id="matching_intersection_sequences" rows="10" cols="50" readonly></textarea>
                    </div>
          <h4>Filter &amp; Sort</h4>
          <h5>Filters&nbsp;<div style="margin-top:5px;" class="help" 
              onclick="help_popup(this, 'pop_filtering')" ></div></h5>
          <div id="filters">
            <div >
              <input type="checkbox" id="filter_on_top" value="1" 
              onclick="toggle_filter(this, 'filter_top')">
              <label for="filter_top" 
                onclick="enable_filter('filter_on_top', 'filter_top')">Top</label>
              <input type="number" id="filter_top" value="10" size="4" min="1" step="1"
              onkeypress="num_keys(event); update_filter(event)" disabled>
            </div>
            <div >
              <input type="checkbox" id="filter_on_db" value="1" 
              onclick="toggle_filter(this, 'filter_db')">
              <label for="filter_db" 
                onclick="enable_filter('filter_on_db', 'filter_db')"
                >Database is</label>
              <select id="filter_db" disabled>
                <script>
                  var filter_db = $("filter_db");
                  filter_db.options.length = 0;
                  for (var i = 0; i < data['motif_dbs'].length; i++) {
                    var db = data['motif_dbs'][i];
                    filter_db.add(new Option(db['name'], i));
                  }
                </script> 
              </select>
            </div>
            <div >
              <input type="checkbox" id="filter_on_id" value="1" 
              onclick="toggle_filter(this, 'filter_id')">
              <label for="filter_id" 
                onclick="enable_filter('filter_on_id', 'filter_id')"
                >ID matches</label>
              <input type="text" id="filter_id" value=".*" size="12" 
              onkeypress="update_filter(event)" disabled>
            </div>
            <div >
              <input type="checkbox" id="filter_on_alt" value="1" 
              onclick="toggle_filter(this, 'filter_alt')">
              <label for="filter_alt"
                onclick="enable_filter('filter_on_alt', 'filter_alt')"
                >Alt ID matches</label>
              <input type="text" id="filter_alt" value=".*" size="12" 
              onkeypress="update_filter(event)" disabled>
            </div>
            <div >
              <input type="checkbox" id="filter_on_evalue" value="1" 
              onclick="toggle_filter(this, 'filter_evalue')">
              <label for="filter_evalue"
                onclick="enable_filter('filter_on_evalue', 'filter_evalue')"
                ><i>E</i>-value &le;</label>
              <input type="text" id="filter_evalue" value="1" size="7" 
              onkeypress="update_filter(event)" disabled>
            </div>
            <div id='cb_filter_on_fisherpv' >
              <input type="checkbox" id="filter_on_fisherpv" value="1" 
              onclick="toggle_filter(this, 'filter_fisherpv')">
              <label for="filter_fisherpv"
                onclick="enable_filter('filter_on_fisherpv', 'filter_fisherpv')"
                >Fisher <i>E</i>-value&le;</label>
              <input type="text" id="filter_fisherpv" value="1" size="7" 
              onkeypress="update_filter(event)" disabled>
            </div>
            <div >
              <input type="checkbox" id="filter_on_binwidth" value="1" 
              onclick="toggle_filter(this, 'filter_binwidth')">
              <label for="filter_binwidth"
                onclick="enable_filter('filter_on_binwidth', 'filter_binwidth')"
                >Region Width &le;</label>
              <input type="number" id="filter_binwidth" value="200" size="7" 
              min="1" onkeypress="num_keys(event); update_filter(event)" disabled>
            </div>
            <div id='CB_filter_on_negbintest'>
              <input type="checkbox" id="filter_on_negbintest" value="1" 
              onclick="toggle_filter(this, 'filter_negbintest')">
              <label for="filter_negbintest"
                onclick="enable_filter('filter_on_negbintest', 'filter_negbintest')"
                >Negative set <i>E</i>-value &ge;</label>
              <input type="text" id="filter_negbintest" value="1" size="7" 
              onkeypress="update_filter(event)" disabled>
            </div>
          </div>
          <div style="margin: 5px 0;">
            <h5>Sort&nbsp;<div class="help"
                onclick="help_popup(this, 'pop_sorting')"></div></h5>
            <div>
              <label for="motif_sort">Motifs:&nbsp;&nbsp; </label>
              <select id="motif_sort"></select>
            </div>
            <div id="box_peak_sort">
              <input type="checkbox" id="allow_peak_sort" value="1" 
              onclick="toggle_filter(this, 'peak_sort')">
              <label for="peak_sort" 
                onclick="enable_filter('allow_peak_sort', 'peak_sort')"
                >Regions: </label>
		          <select id="peak_sort" disabled></select>
            </div>
            <script>populate_sort_lists();</script>
          </div>
          <div>
            <input type="button" value="Update" onclick="make_CEM_table()">
          </div>
          <h4>Columns to display</h4>
          <div >
            <input type="checkbox" id="show_db" value="1" 
            onclick="toggle_column('hide_db')">
            <label for="show_db">Show Database</label>
          </div>
          <div >
            <input type="checkbox" id="show_id" value="1" 
            onclick="toggle_column('hide_id')" checked>
            <label for="show_id">Show ID</label>
          </div>
          <div >
            <input type="checkbox" id="show_name" value="1" 
            onclick="toggle_column('hide_name')" checked>
            <label for="show_name">Show Alt ID</label>
          </div>
          <div >
            <input type="checkbox" id="show_consensus" value="1" 
            onclick="toggle_column('hide_consensus')" checked>
            <label for="show_consensus">Show Consensus</label>
          </div>
          <div >
            <input type="checkbox" id="show_concentration" value="1" 
            onclick="toggle_column('hide_concentration')" checked>
            <label for="show_concentration">Show Concentration</label>
          </div>
          <div >
            <input type="checkbox" id="show_evalue" value="1" 
            onclick="toggle_column('hide_evalue')" checked>
            <label for="show_evalue">Show <i>E</i>-value</label>
          </div>
          <div >
            <input type="checkbox" id="show_pvalue" value="1" 
            onclick="toggle_column('hide_pvalue')">
            <label for="show_pvalue">Show <i>p</i>-value</label>
          </div>
          <div id='cb_show_fisherpv'>
            <input type="checkbox" id="show_fisherpv" value="1" 
            onclick="toggle_column('hide_fisherpv')" checked>
            <label for="show_fisherpv">Show Fisher <i>E</i>-value</label>
          </div>
          <div id='CB_show_MCC'>
            <input type="checkbox" id="show_MCC" value="1" 
            onclick="toggle_column('hide_MCC')">
            <label for="show_MCC">Show Matthew's Correlation Coefficient</label>
          </div>
          <div id='CB_show_blocation'>
            <input type="checkbox" id="show_blocation" value="1" 
            onclick="toggle_column('hide_blocation')" checked>
            <label for="show_blocation">Show Region Center</label>
          </div>
          <div >
            <input type="checkbox" id="show_bwidth" value="1" 
            onclick="toggle_column('hide_bwidth')" checked>
            <label for="show_bwidth">Show Region Width</label>
          </div>
          <div >
            <input type="checkbox" id="show_bsites" value="1" 
            onclick="toggle_column('hide_bsites')" checked>
            <label for="show_bsites">Show Region Matches</label>
          </div>
          <div >
            <input type="checkbox" id="show_tsites" value="1" 
            onclick="toggle_column('hide_tsites')">
            <label for="show_tsites">Show Sequence Matches</label>
          </div>
          <div id='CB_show_negative_binomial'>
            <input type="checkbox" id="show_negative_binomial" value="1" 
            onclick="toggle_column('hide_negative_binomial')">
            <label for="show_negative_binomial">Show Negative <i>p</i>-value</label>
          </div>
          <div id='CB_show_negbsites'>
            <input type="checkbox" id="show_negbsites" value="1" 
            onclick="toggle_column('hide_negbsites')" checked>
            <label for="show_negbsites">Show Negative Region Matches</label>
          </div>
          <div id='CB_show_negtsites'>
            <input type="checkbox" id="show_negtsites" value="1" 
            onclick="toggle_column('hide_negtsites')">
            <label for="show_negtsites">Show Negative Sequence Matches</label>
          </div>
          <div >
            <input type="checkbox" id="show_maxprob" value="1" 
            onclick="toggle_column('hide_maxprob')">
            <label for="show_maxprob">Show Max Probability</label>
          </div>
          <div >
            <input type="checkbox" id="show_hpeak" value="1" 
            onclick="toggle_column('hide_hpeak')">
            <label for="show_hpeak">Show Max Probability Location</label>
          </div>
          <div >
            <input type="checkbox" id="show_nbinstested" value="1" 
            onclick="toggle_column('hide_nbinstested')">
            <label for="show_nbinstested">Show Multiple Tests</label>
          </div>
          <div>
            <input type="checkbox" id="show_score" value="1" 
            onclick="toggle_column('hide_score')" checked>
            <label for="show_score">Show Score Threshold</label>
          </div>
        </div>
        <div style="clear:both"></div>
      </div>
    </div>
    <h2 id="inputs" class="mainh pad2">Input Files</h2>
    <div class="box">
      <h4>Alphabet</h4>
      <span id="bg_source"></span>
      <div class="pad" id="alpha_bg"></div>
      <script>
        $("bg_source").appendChild(make_background_source("Background source", data.options['bfile']));
        $("alpha_bg").appendChild(make_alpha_bg_table(centrimo_alphabet));
      </script>
      <h4>Sequences</h4>
      <table class="inputs">
        <tr><th>Database</th><th>Source</th><th>Sequence Count</th></tr>
        <tr>
          <td id="ins_seq_name"></td>
          <td id="ins_seq_source"></td>
          <td id="ins_seq_count"></td>
        </tr>
      </table>
      <script>
      {
        var db = data['sequence_db'];
        $("ins_seq_name").innerHTML = db['name'];
        $("ins_seq_source").innerHTML = db['source'];
        $("ins_seq_count").innerHTML = db['count'];
      }
      </script>
      <div id='neg_seq_input'>
      <h4>Negative sequences</h4>
      <table class="inputs">
        <tr><th>Database</th><th>Source</th><th>Sequence Count</th></tr>
        <tr>
          <td id="ins_negseq_name"></td>
          <td id="ins_negseq_source"></td>
          <td id="ins_negseq_count"></td>
        </tr>
      </table>
      </div>
      <script>
      {
        if (data['options']['neg_sequences']) {
          var db = data['negative_sequence_db'];
          if (!db['name']) db['name'] = name_from_source(db['source']);
          $("ins_negseq_name").innerHTML = db['name'];
          $("ins_negseq_source").innerHTML = db['source'];
          $("ins_negseq_count").innerHTML = db['count'];
        }
        else {
          $('neg_seq_input').style.display='none';
        }
      }
      </script>
      <h4>Motifs</h4>
      <table id="motif_dbs" class="inputs">
        <thead>
          <tr><th>Database</th><th>Source</th><th>Motif Count</th></tr>
        </thead>
        <tbody></tbody>
      </table>
      <script>
      {
        var tbl = $('motif_dbs');
        var tbody = tbl.tBodies[0];
        while (tbody.rows.length > 0) {
          tbody.deleteRow(0);
        }
        var motif_dbs = data['motif_dbs'];
        for (var i = 0; i < motif_dbs.length; i++) {
          var db = motif_dbs[i];
          var row = tbody.insertRow(tbody.rows.length);
          add_text_cell(row, db['name']);
          add_text_cell(row, db['source']);
          add_text_cell(row, db['count']);
        }
      }
      </script>

      <h4>Other Settings</h4>
      <table id="tbl_settings" class="inputs hide_advanced">
	<tr>
	  <th>Objective Function</th>
	  <td id="opt_obj"></td>
	</tr>
	<tr>
	  <th>Convert Motifs to Different Alphabet?</th>
	  <td id="opt_xalph"></td>
	</tr>
	<tr>
	  <th>Motif Pseudo-Counts</th>
	  <td id="opt_motif_pseudo"></td>
	</tr>
	<tr>
	  <th>Required sequence length</th>
	  <td id="opt_seqlen"></td>
	</tr>
	<tr>
	  <th>Site Scoring Method</th>
	  <td id="opt_use_pvalues"></td>
	</tr>
	<tr>
	  <th>Score Threshold</th>
	  <td id="opt_score"></td>
	</tr>
	<tr>
	  <th>Optimize Score Threshold?</th>
	  <td id="opt_optimize_score"></td>
	</tr>
	<tr>
	  <th>Minimum Region Size</th>
	  <td id="opt_minreg"></td>
	</tr>
	<tr>
	  <th>Maximum Region Size</th>
	  <td id="opt_maxreg"></td>
	</tr>
	<tr>
	  <th>Strand Handling</th>
	  <td id="opt_strands"></td>
	</tr>
	<tr>
	  <th>Plotting of Matches on Negative Strand</th>
	  <td id="opt_flip"></td>
	</tr>
	<tr>
	  <th>Sequence IDs Included in Output?</th>
	  <td id="opt_noseq"></td>
	</tr>
	<tr>
      </table>
      <script> make_other_settings(); </script>

    </div>

    <div id="info_sec" class="bar">
      <div class="subsection">
        <a name="version"/>
        <h5>CentriMo version</h5>
        <span id="ins_version"></span>
        (Release date: <span id="ins_release"></span>)
        <script>
          $("ins_version").innerHTML = data["version"];
          $("ins_release").innerHTML = data["release"];
        </script> 
      </div>
      <div class="subsection" id="reference"> <script>print_citation("reference", "CentriMo");</script> </div>
      <div class="subsection">
        <a name="command" />
        <h5>Command line summary</h5>
        <textarea id="cmd" rows="5" style="width:100%;" readonly="readonly">
        </textarea>
        <script>$("cmd").value = data["cmd"].join(" ");</script>
      </div>
    </div>
  </body>
</html>
